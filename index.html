<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="OpenShop — A free, browser-based image editor with layers, AI background removal, selection tools, filters, and PSD import. No installation required.">
<meta property="og:title" content="OpenShop — Free Online Image Editor">
<meta property="og:description" content="Professional image editing in your browser. Layers, AI tools, selections, filters, PSD import. Zero install.">
<meta property="og:type" content="website">
<meta name="theme-color" content="#0a0c10">
<title>OpenShop v0.18.0 — Online Image Editor</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ag-psd@22.2.0/dist/browser/index.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='6' fill='%230f1218'/%3E%3Cpath d='M8 24V8h5l4 8 4-8h5v16h-4V14l-3.5 7h-3L12 14v10z' fill='%236c8cff'/%3E%3C/svg%3E">
<link rel="manifest" id="pwa-manifest">
<style>
:root{
--bg-depth-0:#0a0c10;--bg-depth-1:#0f1218;--bg-depth-2:#161b24;--bg-depth-3:#1c2230;--bg-depth-4:#242b3a;
--border:#2a3142;--border-active:#3d4863;
--text-primary:#e2e8f4;--text-secondary:#8892a6;--text-muted:#5a6480;
--accent:#6c8cff;--accent-hover:#8da6ff;--accent-dim:rgba(108,140,255,.15);
--success:#4ade80;--warning:#fbbf24;--danger:#f87171;
--canvas-bg:#2a2a2a;--tool-size:36px;--panel-width:260px;--topbar-h:38px;--toolbar-w:44px;--statusbar-h:26px;
--glass:rgba(15,18,24,.85);--glass-border:rgba(108,140,255,.12);
}
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:var(--bg-depth-0);color:var(--text-primary);font-family:'DM Sans',sans-serif;font-size:12px;user-select:none;-webkit-user-select:none}
::-webkit-scrollbar{width:5px;height:5px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}::-webkit-scrollbar-thumb:hover{background:var(--text-muted)}

/* === TOPBAR === */
#topbar{height:var(--topbar-h);display:flex;align-items:center;background:var(--bg-depth-1);border-bottom:1px solid var(--border);padding:0 8px;gap:2px;z-index:100}
#topbar .logo{font-family:'JetBrains Mono',monospace;font-weight:600;font-size:13px;color:var(--accent);margin-right:12px;letter-spacing:-.5px}
#topbar .logo span{color:var(--text-muted);font-weight:400;font-size:10px;margin-left:4px}
.menu-item{position:relative;padding:4px 10px;border-radius:4px;cursor:pointer;color:var(--text-secondary);font-size:12px;transition:all .15s}
.menu-item:hover{background:var(--bg-depth-3);color:var(--text-primary)}
.menu-dropdown{display:none;position:absolute;top:100%;left:0;min-width:210px;max-height:calc(100vh - 50px);overflow-y:auto;background:var(--bg-depth-2);border:1px solid var(--border);border-radius:6px;padding:4px;z-index:1000;box-shadow:0 8px 32px rgba(0,0,0,.5)}
.menu-item:hover>.menu-dropdown{display:block}
.dd-item{padding:6px 12px;border-radius:4px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;color:var(--text-secondary);transition:all .1s;white-space:nowrap}
.dd-item:hover{background:var(--accent-dim);color:var(--text-primary)}
.dd-sep{height:1px;background:var(--border);margin:4px 8px}
.dd-sub{position:relative}.dd-sub>.menu-dropdown{display:none;left:100%;top:-4px;max-height:calc(100vh - 50px);overflow-y:auto}
.dd-sub:hover>.menu-dropdown{display:block}
.dd-sub::after{content:'\25B8';float:right;margin-left:12px;font-size:9px;color:var(--text-muted)}
.ctx-sub{position:relative}.ctx-sub>.ctx-submenu{display:none;position:absolute;left:100%;top:-4px;min-width:180px;background:var(--bg-depth-1);border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,.45);padding:4px;z-index:30001}
.ctx-sub:hover>.ctx-submenu{display:block}
.ctx-sub::after{content:'\25B8';float:right;margin-left:12px;font-size:9px;color:var(--text-muted)}

/* === TOOLBAR === */
#toolbar{position:absolute;left:0;top:var(--topbar-h);bottom:var(--statusbar-h);width:var(--toolbar-w);background:var(--bg-depth-1);border-right:1px solid var(--border);display:flex;flex-direction:column;align-items:center;padding:6px 0;gap:2px;z-index:50;overflow-y:auto}
.tool-btn{width:var(--tool-size);height:var(--tool-size);display:flex;align-items:center;justify-content:center;border-radius:6px;cursor:pointer;transition:all .15s;position:relative;border:none;background:transparent;color:var(--text-secondary)}
.tool-btn:hover{background:var(--bg-depth-3);color:var(--text-primary)}
.tool-btn.active{background:var(--accent-dim);color:var(--accent)}
.tool-btn svg{width:18px;height:18px}.tool-sep{width:28px;height:1px;background:var(--border);margin:4px 0}
.tool-btn[data-tip]::after{content:attr(data-tip);position:absolute;left:calc(100% + 8px);top:50%;transform:translateY(-50%);background:var(--bg-depth-3);color:var(--text-primary);padding:4px 8px;border-radius:4px;font-size:11px;white-space:nowrap;pointer-events:none;opacity:0;transition:opacity .2s;border:1px solid var(--border);z-index:200}
.tool-btn:hover[data-tip]::after{opacity:1}
/* Tool Groups */
.tool-group{position:relative}
.tool-group>.tool-btn::before{content:'';position:absolute;bottom:2px;right:2px;border:3px solid transparent;border-bottom-color:var(--text-muted);border-right-color:var(--text-muted);width:0;height:0;pointer-events:none}
.tool-group>.tool-btn.active::before{border-bottom-color:var(--accent);border-right-color:var(--accent)}
.tool-flyout{display:none;position:fixed;background:var(--bg-depth-1);border:1px solid var(--border);border-radius:8px;padding:4px;box-shadow:0 8px 24px rgba(0,0,0,.45);z-index:9999;min-width:36px;backdrop-filter:blur(6px)}
.tool-flyout.show{display:flex;flex-direction:column;gap:2px}
.tool-flyout .tool-btn{width:32px;height:32px}
.tool-flyout .tool-btn svg{width:16px;height:16px}
.tool-flyout .tool-btn[data-tip]::after{left:calc(100% + 6px)}

/* === TOOL OPTIONS === */
#tool-options{position:absolute;left:var(--toolbar-w);top:var(--topbar-h);right:var(--panel-width);height:34px;background:var(--bg-depth-1);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 12px;gap:12px;z-index:40;overflow-x:auto}
.opt-group{display:flex;align-items:center;gap:6px;flex-shrink:0}
.opt-group label{font-size:11px;color:var(--text-muted)}
.opt-group input[type="range"]{-webkit-appearance:none;width:80px;height:4px;background:var(--bg-depth-4);border-radius:2px;outline:none}
.opt-group input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer}
.opt-group input[type="number"],.opt-group select{width:52px;height:22px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);text-align:center;font-size:11px;font-family:'JetBrains Mono',monospace;outline:none}
.opt-group select{width:auto;padding:0 6px;text-align:left;cursor:pointer}
.opt-group input[type="color"]{width:24px;height:22px;border:1px solid var(--border);border-radius:4px;background:none;cursor:pointer;padding:0}
.opt-val{font-family:'JetBrains Mono',monospace;font-size:11px;color:var(--text-secondary);min-width:24px;text-align:center}
.opt-group input[type="checkbox"]{accent-color:var(--accent)}

/* === PANELS === */
#panels{position:absolute;right:0;top:var(--topbar-h);bottom:var(--statusbar-h);width:var(--panel-width);background:var(--bg-depth-1);border-left:1px solid var(--border);display:flex;flex-direction:column;z-index:50;overflow-y:auto;overflow-x:hidden}
.panel-tab-group{border-bottom:1px solid var(--border);display:flex;flex-direction:column;min-height:0}
.panel-tab-group.ptg-flex{flex:1}
.panel-tabs{display:flex;background:var(--bg-depth-2);border-bottom:1px solid var(--border);flex-shrink:0;min-height:28px}
.panel-tab{padding:5px 10px;font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.4px;color:var(--text-muted);cursor:pointer;border:none;background:transparent;border-bottom:2px solid transparent;transition:all .15s;white-space:nowrap;flex-shrink:0}
.panel-tab:hover{color:var(--text-secondary);background:var(--bg-depth-3)}
.panel-tab.active{color:var(--accent);border-bottom-color:var(--accent);background:var(--bg-depth-1)}
.panel-tab-content{display:none;flex-direction:column;overflow-y:auto;min-height:0}
.panel-tab-content.active{display:flex;flex:1}
#ai-progress{position:fixed;top:0;left:0;right:0;bottom:0;z-index:30000;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;backdrop-filter:blur(4px)}
#ai-progress.visible{display:flex}
.ai-box{background:var(--bg-depth-2);border:1px solid var(--border);border-radius:12px;padding:24px 32px;min-width:360px;text-align:center;box-shadow:0 16px 48px rgba(0,0,0,.5)}
.ai-title{font-size:14px;font-weight:600;color:var(--text-primary);margin-bottom:8px}
.ai-msg{font-size:11px;color:var(--text-muted);margin-bottom:12px;min-height:14px}
.ai-bar-wrap{width:100%;height:6px;background:var(--bg-depth-4);border-radius:3px;overflow:hidden}
.ai-bar{height:100%;background:linear-gradient(90deg,var(--accent),#a78bfa);border-radius:3px;transition:width .3s;width:0%}
.ai-pct{font-size:10px;color:var(--text-muted);margin-top:6px;font-family:'JetBrains Mono',monospace}
.ai-spinner{display:inline-block;width:16px;height:16px;border:2px solid var(--text-muted);border-top-color:var(--accent);border-radius:50%;animation:aispin .8s linear infinite;margin-right:6px;vertical-align:middle}
@keyframes aispin{to{transform:rotate(360deg)}}
.panel-tab-content>.ptc-inner{padding:8px 10px}
.panel{border-bottom:1px solid var(--border)}
.panel-header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;cursor:pointer;font-weight:600;font-size:11px;text-transform:uppercase;letter-spacing:.5px;color:var(--text-muted)}
.panel-header:hover{color:var(--text-secondary)}
.panel-body{padding:8px 10px}.panel-body.collapsed{display:none}
.panel-actions{display:flex;gap:2px}
.panel-action{width:22px;height:22px;display:flex;align-items:center;justify-content:center;border-radius:4px;cursor:pointer;color:var(--text-muted);transition:all .15s;border:none;background:transparent}
.panel-action:hover{background:var(--bg-depth-3);color:var(--text-primary)}
.panel-action svg{width:14px;height:14px}

/* Layers */
#layers-list{max-height:180px;overflow-y:auto;display:flex;flex-direction:column;gap:2px}
.layer-item{display:flex;align-items:center;gap:6px;padding:4px 6px;border-radius:4px;cursor:pointer;transition:all .15s;border:1px solid transparent}
.layer-item:hover{background:var(--bg-depth-3)}.layer-item.active{background:var(--accent-dim);border-color:var(--glass-border)}
.layer-lock{background:none;border:none;padding:2px;cursor:pointer;color:var(--text-muted);opacity:.6;transition:all .15s;flex-shrink:0}
.layer-lock:hover{opacity:1;color:var(--text-secondary)}
.layer-lock.locked{opacity:1;color:var(--accent)}
.layer-item .layer-thumb-checker{width:32px;height:32px;border-radius:2px;background-image:linear-gradient(45deg,#444 25%,transparent 25%),linear-gradient(-45deg,#444 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#444 75%),linear-gradient(-45deg,transparent 75%,#444 75%);background-size:8px 8px;background-position:0 0,0 4px,4px -4px,-4px 0;background-color:#666}
#layers-empty{display:none;padding:16px 8px;text-align:center;color:var(--text-muted);font-size:11px;font-style:italic}
#layers-list:empty+#layers-empty{display:block}
.ctx-section{padding:3px 10px;font-size:10px;color:var(--text-muted);letter-spacing:.5px;text-transform:uppercase;pointer-events:none}
.layer-thumb{width:32px;height:32px;border-radius:3px;background:var(--bg-depth-4);border:1px solid var(--border);overflow:hidden;flex-shrink:0}
.layer-info{flex:1;min-width:0}
.layer-name{font-size:11px;color:var(--text-primary);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.layer-name-input{font-size:11px;color:var(--text-primary);background:var(--bg-depth-3);border:1px solid var(--accent);border-radius:3px;padding:0 4px;width:100%;outline:none;font-family:inherit}
.layer-type{font-size:10px;color:var(--text-muted)}
.layer-vis{width:18px;height:18px;display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--text-muted);border-radius:3px;flex-shrink:0;border:none;background:transparent}
.layer-vis:hover{color:var(--text-primary);background:var(--bg-depth-4)}
.layer-vis.hidden{color:var(--danger);opacity:.5}
.blend-row{display:flex;gap:6px;align-items:center;margin-bottom:6px}
.blend-row select{flex:1;height:22px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-size:11px;padding:0 4px;outline:none;cursor:pointer}

/* Color */

.color-swatches{display:flex;gap:4px;flex-wrap:wrap}
.color-swatch{width:18px;height:18px;border-radius:3px;cursor:pointer;border:1px solid var(--border);transition:transform .1s}
.color-swatch:hover{transform:scale(1.2)}
.fg-bg-container{display:flex;align-items:center;gap:8px}
.fg-bg-box{position:relative;width:48px;height:48px}
.color-box{width:30px;height:30px;border-radius:4px;border:2px solid var(--border);position:absolute;cursor:pointer}
.color-box.fg{top:0;left:0;z-index:2}.color-box.bg{bottom:0;right:0;z-index:1}
.color-swap{position:absolute;top:0;right:0;width:16px;height:16px;display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--text-muted);font-size:10px;z-index:3;border:none;background:transparent}
.color-swap:hover{color:var(--text-primary)}

/* Adjustments */
.adj-row{display:flex;align-items:center;gap:6px;margin-bottom:6px}
.adj-row label{width:70px;font-size:11px;color:var(--text-muted);text-align:right;flex-shrink:0}
.adj-row input[type="range"]{-webkit-appearance:none;flex:1;height:4px;background:var(--bg-depth-4);border-radius:2px;outline:none}
.adj-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer}
.adj-val{font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-secondary);min-width:28px;text-align:right}
.adj-btns{display:flex;gap:4px;margin-top:6px}.adj-btns .btn{padding:4px 10px;font-size:11px}

/* Brush presets */
.brush-preset-list{display:flex;flex-wrap:wrap;gap:4px;margin-bottom:6px}
.brush-preset{width:32px;height:32px;border-radius:4px;border:1px solid var(--border);cursor:pointer;display:flex;align-items:center;justify-content:center;background:var(--bg-depth-3);transition:all .15s;font-size:10px;color:var(--text-muted)}
.brush-preset:hover,.brush-preset.active{border-color:var(--accent);color:var(--accent);background:var(--accent-dim)}

/* History */
#history-list{max-height:130px;overflow-y:auto;display:flex;flex-direction:column;gap:1px}
.history-item{padding:3px 8px;border-radius:3px;font-size:11px;color:var(--text-muted);cursor:pointer;transition:all .1s}
.history-item:hover{background:var(--bg-depth-3);color:var(--text-secondary)}
.history-item.current{color:var(--text-primary);background:var(--accent-dim)}
.history-item.future{opacity:.4}

/* === CANVAS === */
#canvas-area{position:absolute;left:var(--toolbar-w);top:calc(var(--topbar-h) + 34px);right:var(--panel-width);bottom:var(--statusbar-h);background:var(--canvas-bg);overflow:hidden;cursor:crosshair;background-image:linear-gradient(45deg,#252525 25%,transparent 25%),linear-gradient(-45deg,#252525 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#252525 75%),linear-gradient(-45deg,transparent 75%,#252525 75%);background-size:20px 20px;background-position:0 0,0 10px,10px -10px,-10px 0}
.selection-rect{position:absolute;pointer-events:none;z-index:100;
background-image:linear-gradient(90deg,#000 50%,#fff 50%),linear-gradient(90deg,#000 50%,#fff 50%),linear-gradient(0deg,#000 50%,#fff 50%),linear-gradient(0deg,#000 50%,#fff 50%);
background-size:8px 1px,8px 1px,1px 8px,1px 8px;
background-position:0 0,0 100%,0 0,100% 0;
background-repeat:repeat-x,repeat-x,repeat-y,repeat-y;
animation:marchAnts .4s linear infinite}
@keyframes marchAnts{to{background-position:8px 0,-8px 100%,0 -8px,100% 8px}}
/* Crop overlay */
.crop-overlay{position:absolute;inset:0;pointer-events:none;z-index:99}
.crop-dim{position:absolute;background:rgba(0,0,0,.55)}
.crop-box{position:absolute;border:2px solid var(--accent);pointer-events:all;cursor:move;z-index:1}
.crop-handle{position:absolute;width:10px;height:10px;background:var(--accent);border:1px solid #fff;border-radius:2px;pointer-events:all;z-index:2;transition:transform .1s}
.crop-handle:hover{transform:scale(1.3)}
.crop-handle.nw{top:-5px;left:-5px;cursor:nw-resize}
.crop-handle.ne{top:-5px;right:-5px;cursor:ne-resize}
.crop-handle.sw{bottom:-5px;left:-5px;cursor:sw-resize}
.crop-handle.se{bottom:-5px;right:-5px;cursor:se-resize}
.crop-handle.n{top:-5px;left:calc(50% - 5px);cursor:n-resize}
.crop-handle.s{bottom:-5px;left:calc(50% - 5px);cursor:s-resize}
.crop-handle.w{top:calc(50% - 5px);left:-5px;cursor:w-resize}
.crop-handle.e{top:calc(50% - 5px);right:-5px;cursor:e-resize}
.crop-grid-line{position:absolute;background:rgba(255,255,255,.25);pointer-events:none}
.crop-grid-line.h{left:0;right:0;height:1px}
.crop-grid-line.v{top:0;bottom:0;width:1px}
.crop-size-label{position:absolute;bottom:-22px;left:50%;transform:translateX(-50%);font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--accent);background:rgba(0,0,0,.7);padding:1px 6px;border-radius:3px;pointer-events:none;white-space:nowrap}

/* === STATUS BAR === */
#statusbar{position:absolute;left:0;right:0;bottom:0;height:var(--statusbar-h);background:var(--bg-depth-1);border-top:1px solid var(--border);display:flex;align-items:center;padding:0 12px;gap:16px;z-index:100;font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-muted)}
#statusbar .sep{width:1px;height:14px;background:var(--border)}
#zoom-display{cursor:pointer}#zoom-display:hover{color:var(--accent)}

/* === MODAL === */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:10000;backdrop-filter:blur(4px);opacity:0;transition:opacity .2s}
.modal-overlay.show{opacity:1}
.modal{background:var(--bg-depth-2);border:1px solid var(--border);border-radius:10px;padding:20px;min-width:340px;max-width:520px;box-shadow:0 16px 48px rgba(0,0,0,.5);transform:translateY(10px);transition:transform .2s;max-height:80vh;overflow-y:auto}
.modal-overlay.show .modal{transform:translateY(0)}
.filter-panel{position:fixed;z-index:10001;background:var(--bg-depth-1);border:1px solid var(--border);border-radius:10px;padding:0;min-width:260px;max-width:300px;box-shadow:0 8px 32px rgba(0,0,0,.6);opacity:0;transform:translateY(8px);transition:opacity .15s,transform .15s}
.filter-panel.show{opacity:1;transform:translateY(0)}
.filter-panel-header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px 8px;cursor:move;user-select:none;border-bottom:1px solid var(--border)}
.filter-panel-header h3{font-size:13px;font-weight:600;color:var(--text-primary);margin:0}
.filter-panel-header .fp-close{background:none;border:none;color:var(--text-muted);cursor:pointer;padding:2px;line-height:1;font-size:16px;transition:color .1s}
.filter-panel-header .fp-close:hover{color:var(--danger)}
.filter-panel-body{padding:10px 14px}
.filter-panel-body .modal-row{margin-bottom:6px}
.filter-panel-footer{display:flex;gap:6px;justify-content:flex-end;padding:8px 14px 12px;border-top:1px solid var(--border)}
.modal h3{font-size:14px;margin-bottom:16px;color:var(--text-primary);font-weight:600}
.modal-row{display:flex;align-items:center;gap:10px;margin-bottom:10px}
.modal-row label{width:90px;font-size:11px;color:var(--text-secondary);text-align:right;flex-shrink:0}
.modal-row input,.modal-row select{flex:1;height:28px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);padding:0 8px;font-family:'JetBrains Mono',monospace;font-size:12px;outline:none}
.modal-row input:focus{border-color:var(--accent)}
.modal-row input[type="range"]{-webkit-appearance:none;height:4px;padding:0}
.modal-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:var(--accent);cursor:pointer}
.modal-btns{display:flex;justify-content:flex-end;gap:8px;margin-top:16px}
.btn{padding:6px 16px;border-radius:5px;font-size:12px;font-weight:500;cursor:pointer;border:1px solid var(--border);background:var(--bg-depth-3);color:var(--text-primary);transition:all .15s}
.btn:hover{background:var(--bg-depth-4)}.btn-primary{background:var(--accent);border-color:var(--accent);color:#fff}.btn-primary:hover{background:var(--accent-hover)}
.btn-danger{background:var(--danger);border-color:var(--danger);color:#fff}
.preset-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:12px}
.preset-btn{padding:6px 8px;border-radius:4px;font-size:11px;cursor:pointer;text-align:center;background:var(--bg-depth-3);border:1px solid var(--border);color:var(--text-secondary);transition:all .15s}
.preset-btn:hover{border-color:var(--accent);color:var(--text-primary)}

/* Toast */
#toast-container{position:fixed;bottom:40px;left:50%;transform:translateX(-50%);z-index:20000;display:flex;flex-direction:column;gap:6px;align-items:center}

/* Color Range Dialog */
.cr-dialog{display:flex;gap:16px;min-width:520px}
.cr-left{flex:1;display:flex;flex-direction:column;gap:10px}
.cr-right{width:90px;display:flex;flex-direction:column;gap:6px}
.cr-right .btn{width:100%;text-align:center;padding:5px 8px;font-size:11px}
.cr-select-row{display:flex;align-items:center;gap:8px;margin-bottom:4px}
.cr-select-row label{font-size:11px;color:var(--text-secondary);white-space:nowrap}
.cr-select-row select{flex:1;height:24px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-size:11px;padding:0 4px}
.cr-fuzz-row{display:flex;align-items:center;gap:8px}
.cr-fuzz-row label{font-size:11px;color:var(--text-secondary);white-space:nowrap;min-width:60px}
.cr-fuzz-row input[type="range"]{flex:1;-webkit-appearance:none;height:4px;background:var(--bg-depth-4);border-radius:2px}
.cr-fuzz-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer}
.cr-fuzz-row input[type="number"]{width:48px;height:22px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);text-align:center;font-size:11px;font-family:'JetBrains Mono',monospace}
.cr-preview{width:100%;aspect-ratio:4/3;background:#000;border:1px solid var(--border);border-radius:4px;overflow:hidden;cursor:crosshair;position:relative}
.cr-preview canvas{width:100%;height:100%;object-fit:contain}
.cr-preview-mode{display:flex;align-items:center;gap:12px;font-size:11px;color:var(--text-secondary)}
.cr-preview-mode label{display:flex;align-items:center;gap:4px;cursor:pointer}
.cr-preview-mode input[type="radio"]{accent-color:var(--accent)}
.cr-eyedroppers{display:flex;gap:4px;align-items:center}
.cr-eyedrop-btn{width:26px;height:26px;border:1px solid var(--border);border-radius:4px;background:var(--bg-depth-3);color:var(--text-secondary);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:14px;transition:all .15s}
.cr-eyedrop-btn:hover,.cr-eyedrop-btn.active{border-color:var(--accent);color:var(--accent);background:var(--accent-dim)}
.cr-invert-row{display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text-secondary)}
.cr-invert-row input[type="checkbox"]{accent-color:var(--accent)}
.toast{padding:8px 16px;border-radius:6px;font-size:12px;color:var(--text-primary);background:var(--bg-depth-2);border:1px solid var(--border);box-shadow:0 4px 20px rgba(0,0,0,.4);opacity:0;transform:translateY(10px);transition:all .3s;white-space:nowrap}
.toast.show{opacity:1;transform:translateY(0)}.toast.success{border-left:3px solid var(--success)}.toast.error{border-left:3px solid var(--danger)}.toast.info{border-left:3px solid var(--accent)}

/* === WELCOME SCREEN === */
#welcome-overlay{position:fixed;inset:0;background:var(--bg-depth-0);z-index:30000;display:flex;flex-direction:column;align-items:center;justify-content:center;opacity:1;transition:opacity .4s}
#welcome-overlay.hidden{opacity:0;pointer-events:none}
.welcome-inner{max-width:700px;width:90%;text-align:center}
.welcome-inner h1{font-family:'JetBrains Mono',monospace;font-size:28px;color:var(--accent);margin-bottom:4px;letter-spacing:-1px}
.welcome-inner p{color:var(--text-muted);font-size:13px;margin-bottom:24px}
.welcome-actions{display:flex;gap:12px;justify-content:center;margin-bottom:28px}
.welcome-actions .btn{padding:10px 24px;font-size:13px}
.template-section h3{color:var(--text-secondary);font-size:12px;text-transform:uppercase;letter-spacing:.5px;margin-bottom:12px;text-align:left}
.template-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;margin-bottom:20px}
.template-card{background:var(--bg-depth-2);border:1px solid var(--border);border-radius:8px;padding:12px;cursor:pointer;transition:all .2s;text-align:center}
.template-card:hover{border-color:var(--accent);transform:translateY(-2px);box-shadow:0 4px 16px rgba(108,140,255,.15)}
.template-card .tpl-preview{width:100%;height:70px;border-radius:4px;margin-bottom:8px;display:flex;align-items:center;justify-content:center;font-size:20px;background:var(--bg-depth-3)}
.template-card .tpl-name{font-size:12px;color:var(--text-primary);font-weight:500}
.template-card .tpl-dims{font-size:10px;color:var(--text-muted);font-family:'JetBrains Mono',monospace;margin-top:2px}
.recent-files{text-align:left;margin-top:20px}
.recent-files h3{color:var(--text-secondary);font-size:12px;text-transform:uppercase;letter-spacing:.5px;margin-bottom:8px}
.recent-item{display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:4px;cursor:pointer;color:var(--text-secondary);font-size:12px;transition:all .15s}
.recent-item:hover{background:var(--bg-depth-3);color:var(--text-primary)}
.recent-item .ri-date{margin-left:auto;font-size:10px;color:var(--text-muted);font-family:'JetBrains Mono',monospace}

/* === GRID OVERLAY === */
.canvas-grid{position:absolute;inset:0;pointer-events:none;z-index:5;opacity:.3;display:none}
.canvas-grid.visible{display:block}

/* === RULERS === */
.ruler-h,.ruler-v{position:absolute;background:var(--bg-depth-2);z-index:45;display:none;overflow:hidden}
.ruler-h.visible,.ruler-v.visible{display:block}
.ruler-h{left:var(--toolbar-w);right:var(--panel-width);top:var(--topbar-h);height:20px;border-bottom:1px solid var(--border)}
.ruler-v{top:calc(var(--topbar-h) + 20px);left:var(--toolbar-w);bottom:var(--statusbar-h);width:20px;border-right:1px solid var(--border)}
.ruler-h canvas,.ruler-v canvas{display:block}
/* Shift canvas when rulers visible */
body.rulers-on #tool-options{top:calc(var(--topbar-h) + 20px)}
body.rulers-on #canvas-area{top:calc(var(--topbar-h) + 34px + 20px);left:calc(var(--toolbar-w) + 20px)}
body.rulers-on .ruler-v{top:calc(var(--topbar-h) + 20px)}

/* === FULLSCREEN === */
body.fullscreen #topbar,body.fullscreen #toolbar,body.fullscreen #panels,body.fullscreen #statusbar,body.fullscreen #tool-options,body.fullscreen .ruler-h,body.fullscreen .ruler-v{display:none!important}
body.fullscreen #canvas-area{left:0;top:0;right:0;bottom:0}

/* === CURVES DIALOG === */
.curves-canvas{background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;cursor:crosshair;display:block;margin:0 auto 12px}
.curves-presets{display:flex;gap:4px;margin-bottom:10px;flex-wrap:wrap}
.curves-presets .btn{padding:3px 8px;font-size:10px}
.curves-channel-row{display:flex;gap:4px;margin-bottom:8px;justify-content:center}
.curves-channel-row .btn{padding:3px 10px;font-size:11px;min-width:44px}
.curves-channel-row .btn.active{background:var(--accent);border-color:var(--accent);color:#fff}

/* === GUIDES === */
.guide-line{position:absolute;z-index:6;pointer-events:all}
.guide-line.horizontal{left:0;right:0;height:1px;background:rgba(108,220,255,.6);cursor:ns-resize}
.guide-line.vertical{top:0;bottom:0;width:1px;background:rgba(108,220,255,.6);cursor:ew-resize}
.guide-line:hover{background:rgba(108,220,255,1)}
#guides-container{position:absolute;inset:0;pointer-events:none;z-index:6}
#guides-container .guide-line{pointer-events:all}

/* === MEASUREMENT OVERLAY === */
.measure-line{position:absolute;pointer-events:none;z-index:98}
.measure-line .ml-line{position:absolute;background:var(--warning);transform-origin:0 50%}
.measure-label{position:absolute;background:var(--bg-depth-2);color:var(--warning);font-family:'JetBrains Mono',monospace;font-size:10px;padding:2px 6px;border-radius:3px;border:1px solid var(--warning);white-space:nowrap;z-index:99}

/* === ALIGN BAR IN PANELS === */
.align-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:3px}
.align-grid button{width:100%;height:28px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--text-muted);transition:all .15s}
.align-grid button:hover{background:var(--bg-depth-4);color:var(--text-primary);border-color:var(--accent)}
.align-grid button svg{width:16px;height:16px}
.distribute-row{display:flex;gap:4px;margin-top:6px}
.distribute-row button{flex:1;height:26px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;cursor:pointer;font-size:10px;color:var(--text-muted);transition:all .15s}
.distribute-row button:hover{background:var(--bg-depth-4);color:var(--text-primary)}

/* === LASSO OVERLAY === */
.lasso-overlay{position:absolute;inset:0;pointer-events:none;z-index:97}
.lasso-overlay svg{width:100%;height:100%}
.lasso-path{fill:rgba(108,140,255,.04);stroke:#000;stroke-width:1.5;stroke-dasharray:6 4;animation:lassoDash .4s linear infinite;filter:drop-shadow(0 0 0.5px #fff)}
@keyframes lassoDash{to{stroke-dashoffset:-10}}

/* === LAYER MASK INDICATOR === */
.mask-indicator{display:inline-block;width:14px;height:14px;border-radius:2px;border:1px solid var(--border);background:linear-gradient(135deg,#fff 50%,#000 50%);margin-left:4px;vertical-align:middle;cursor:pointer;flex-shrink:0}
.mask-indicator.has-mask{border-color:var(--accent)}
.mask-indicator:hover{transform:scale(1.15)}

/* === TEXT EFFECTS PANEL === */
.text-fx-row{display:flex;align-items:center;gap:6px;margin-bottom:5px}
.text-fx-row label{width:60px;font-size:11px;color:var(--text-muted);text-align:right;flex-shrink:0}
.text-fx-row input[type="range"]{-webkit-appearance:none;flex:1;height:4px;background:var(--bg-depth-4);border-radius:2px;outline:none}
.text-fx-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer}

/* === HISTOGRAM === */
.histogram-canvas{width:100%;height:80px;border-radius:4px;background:var(--bg-depth-3);border:1px solid var(--border);display:block}
.histogram-stats{display:flex;justify-content:space-between;font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--text-muted);margin-top:3px}
.histogram-channel-btns{display:flex;gap:3px;margin-bottom:4px}
.histogram-channel-btns button{padding:2px 6px;font-size:10px;border-radius:3px;border:1px solid var(--border);background:var(--bg-depth-3);color:var(--text-muted);cursor:pointer;transition:all .15s}
.histogram-channel-btns button.active{border-color:var(--accent);color:var(--accent);background:var(--accent-dim)}

/* === COLOR WHEEL === */
.color-wheel-wrap{position:relative;width:120px;height:120px;margin:0 auto 8px}
.color-wheel-canvas{width:120px;height:120px;border-radius:50%;cursor:crosshair;display:block}
.color-wheel-cursor{position:absolute;width:10px;height:10px;border:2px solid #fff;border-radius:50%;pointer-events:none;transform:translate(-50%,-50%);box-shadow:0 0 3px rgba(0,0,0,.5)}
.hsb-sliders{display:flex;flex-direction:column;gap:4px;margin-bottom:6px}
.hsb-row{display:flex;align-items:center;gap:4px}
.hsb-row label{width:14px;font-size:10px;color:var(--text-muted);font-weight:600}
.hsb-row input[type="range"]{-webkit-appearance:none;flex:1;height:4px;background:var(--bg-depth-4);border-radius:2px;outline:none}
.hsb-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:10px;height:10px;border-radius:50%;background:var(--accent);cursor:pointer}
.hsb-row .hsb-val{font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-secondary);min-width:24px;text-align:right}

/* === PEN TOOL OVERLAY === */
.pen-overlay{position:absolute;inset:0;pointer-events:none;z-index:96}
.pen-overlay svg{width:100%;height:100%}
.pen-point{fill:var(--accent);cursor:move;pointer-events:all}
.pen-control{fill:none;stroke:var(--accent);stroke-width:1;stroke-dasharray:3 2}
.pen-path-preview{fill:none;stroke:var(--accent);stroke-width:2}

/* === LAYER DRAG === */
.layer-item.dragging{opacity:.4;background:var(--accent-dim)}
.layer-item.drop-above{border-top:2px solid var(--accent)!important}
.layer-item.drop-below{border-bottom:2px solid var(--accent)!important}
.layer-drag-handle{cursor:grab;color:var(--text-muted);padding:0 2px;flex-shrink:0;display:flex;align-items:center}
.layer-drag-handle:active{cursor:grabbing}

/* === PREFERENCES === */
.pref-section{margin-bottom:14px}
.pref-section h4{font-size:11px;color:var(--text-secondary);text-transform:uppercase;letter-spacing:.5px;margin-bottom:8px;border-bottom:1px solid var(--border);padding-bottom:4px}
.pref-row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.pref-row label{flex:1;font-size:12px;color:var(--text-primary)}
.pref-row input[type="number"]{width:60px;height:24px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);text-align:center;font-family:'JetBrains Mono',monospace;font-size:11px;outline:none}
.pref-row select{height:24px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);font-size:11px;padding:0 6px;outline:none;cursor:pointer}

/* === IMAGE INFO === */
.info-grid{display:grid;grid-template-columns:auto 1fr;gap:2px 8px}
.info-grid dt{font-size:10px;color:var(--text-muted);text-align:right}
.info-grid dd{font-size:10px;color:var(--text-secondary);font-family:'JetBrains Mono',monospace}

/* === LAYER STYLES PANEL === */
.layer-style-row{display:flex;align-items:center;gap:6px;margin-bottom:5px;padding:4px 0}
.layer-style-row label{width:70px;font-size:11px;color:var(--text-muted);text-align:right;flex-shrink:0}
.layer-style-row input[type="range"]{-webkit-appearance:none;flex:1;height:4px;background:var(--bg-depth-4);border-radius:2px;outline:none}
.layer-style-row input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--accent);cursor:pointer}
.style-section{margin-bottom:8px;border-bottom:1px solid var(--border);padding-bottom:6px}
.style-section summary{font-size:11px;color:var(--text-secondary);cursor:pointer;padding:3px 0;user-select:none}
.style-section summary:hover{color:var(--accent)}

/* === EXPORT DIALOG === */
.export-preview{width:100%;height:120px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:6px;display:flex;align-items:center;justify-content:center;overflow:hidden;margin-bottom:10px}
.export-preview img{max-width:100%;max-height:100%;object-fit:contain}
.export-size-est{font-family:'JetBrains Mono',monospace;font-size:11px;color:var(--accent);text-align:center;margin-bottom:8px}
.export-format-row{display:flex;gap:6px;margin-bottom:10px;justify-content:center}
.export-format-row .btn{min-width:55px}
.export-format-row .btn.active{background:var(--accent);border-color:var(--accent);color:#fff}

/* === BEFORE/AFTER SPLIT === */
#ba-overlay{position:fixed;inset:0;z-index:29000;background:var(--bg-depth-0);display:none;flex-direction:column}
#ba-overlay.visible{display:flex}
#ba-topbar{height:36px;background:var(--bg-depth-1);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 12px;gap:12px}
#ba-topbar span{font-size:12px;color:var(--text-secondary)}
#ba-topbar .btn{padding:3px 12px;font-size:11px}
#ba-container{flex:1;display:flex;position:relative;overflow:hidden}
#ba-container canvas{position:absolute;top:0;left:0}
#ba-divider{position:absolute;top:0;bottom:0;width:3px;background:var(--accent);cursor:ew-resize;z-index:5}
#ba-divider::after{content:'';position:absolute;top:50%;left:-8px;width:19px;height:32px;background:var(--accent);border-radius:4px;transform:translateY(-50%)}
.ba-label{position:absolute;top:12px;padding:3px 10px;font-size:11px;font-family:'JetBrains Mono',monospace;background:rgba(0,0,0,.6);color:var(--text-primary);border-radius:4px;z-index:6}
.ba-label.before{left:12px}
.ba-label.after{right:12px}

/* === GRADIENT MAP === */
.gm-preview{width:100%;height:24px;border-radius:4px;border:1px solid var(--border);margin-bottom:8px}
.gm-stops{display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px}
.gm-stop{display:flex;align-items:center;gap:3px;background:var(--bg-depth-3);padding:2px 6px;border-radius:4px;font-size:10px;color:var(--text-muted)}
.gm-stop input[type="color"]{width:18px;height:18px;border:none;background:none;cursor:pointer}

/* === COMMAND PALETTE === */
#cmd-palette{position:fixed;top:0;left:0;right:0;bottom:0;z-index:31000;background:rgba(0,0,0,.55);display:none;align-items:flex-start;justify-content:center;padding-top:15vh;backdrop-filter:blur(4px)}
#cmd-palette.visible{display:flex}
#cmd-box{width:480px;max-width:90vw;background:var(--bg-depth-1);border:1px solid var(--border);border-radius:10px;box-shadow:0 16px 48px rgba(0,0,0,.5);overflow:hidden}
#cmd-input{width:100%;padding:14px 16px;background:transparent;border:none;border-bottom:1px solid var(--border);color:var(--text-primary);font-size:15px;font-family:'DM Sans',sans-serif;outline:none}
#cmd-input::placeholder{color:var(--text-muted)}
#cmd-results{max-height:320px;overflow-y:auto;padding:4px}
.cmd-item{padding:8px 14px;cursor:pointer;display:flex;align-items:center;gap:10px;border-radius:6px;transition:background .1s}
.cmd-item:hover,.cmd-item.active{background:var(--accent-dim)}
.cmd-item .cmd-label{flex:1;font-size:13px;color:var(--text-primary)}
.cmd-item .cmd-shortcut{font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-muted);background:var(--bg-depth-3);padding:2px 6px;border-radius:3px}
.cmd-item .cmd-cat{font-size:10px;color:var(--text-muted);min-width:42px;text-align:right}

/* === CONTEXT MENU === */
#context-menu{position:fixed;z-index:30000;background:var(--bg-depth-1);border:1px solid var(--border);border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,.45);min-width:180px;padding:4px;display:none;backdrop-filter:blur(6px)}
#context-menu.visible{display:block}
.ctx-item{padding:6px 14px;font-size:12px;color:var(--text-primary);cursor:pointer;border-radius:4px;display:flex;align-items:center;gap:8px;transition:background .1s}
.ctx-item:hover{background:var(--accent-dim)}
.ctx-sep{height:1px;background:var(--border);margin:3px 8px}
.ctx-item .ctx-shortcut{margin-left:auto;font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-muted)}

/* === MINIMAP / NAVIGATOR === */
.minimap-wrap{position:relative;width:100%;aspect-ratio:16/9;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;overflow:hidden;cursor:pointer}
.minimap-wrap canvas{width:100%;height:100%;display:block}
.minimap-viewport{position:absolute;border:1.5px solid var(--accent);pointer-events:none;border-radius:1px}

/* === DROPZONE === */
#dropzone-overlay{position:fixed;inset:0;z-index:32000;background:rgba(18,22,36,.9);display:none;align-items:center;justify-content:center;flex-direction:column;gap:16px;pointer-events:none;backdrop-filter:blur(6px)}
#dropzone-overlay.visible{display:flex}
.dropzone-ring{width:140px;height:140px;border:3px dashed var(--accent);border-radius:50%;display:flex;align-items:center;justify-content:center;animation:dropPulse 1.5s ease-in-out infinite}
@keyframes dropPulse{0%,100%{transform:scale(1);opacity:.7}50%{transform:scale(1.08);opacity:1}}
.dropzone-ring svg{width:48px;height:48px;color:var(--accent)}
.dropzone-text{font-size:16px;color:var(--text-primary);font-weight:500}
.dropzone-sub{font-size:12px;color:var(--text-muted)}

/* === ANNOTATION / STICKY NOTES === */
.sticky-note{position:absolute;min-width:120px;min-height:80px;padding:8px;border-radius:6px;font-size:11px;color:#1a1a2e;box-shadow:0 2px 8px rgba(0,0,0,.25);cursor:move;z-index:100;resize:both;overflow:auto;font-family:'DM Sans',sans-serif;line-height:1.4}
.sticky-note .sticky-close{position:absolute;top:2px;right:5px;cursor:pointer;font-size:14px;opacity:.5;transition:opacity .15s}
.sticky-note .sticky-close:hover{opacity:1}
.sticky-note textarea{width:100%;height:calc(100% - 14px);border:none;background:transparent;color:inherit;font:inherit;resize:none;outline:none}

/* === SMART GUIDES === */
.smart-guide{position:absolute;z-index:95;pointer-events:none}
.smart-guide.horizontal{height:1px;background:rgba(255,80,120,.7);left:0;right:0}
.smart-guide.vertical{width:1px;background:rgba(255,80,120,.7);top:0;bottom:0}

/* === SHORTCUTS PANEL === */
.shortcut-grid{display:grid;grid-template-columns:auto 1fr;gap:3px 12px;max-height:300px;overflow-y:auto}
.shortcut-grid dt{font-family:'JetBrains Mono',monospace;font-size:11px;color:var(--accent);text-align:right;padding:2px 0}
.shortcut-grid dd{font-size:11px;color:var(--text-secondary);padding:2px 0}

/* === PALETTE PANEL === */
.palette-row{display:flex;flex-wrap:wrap;gap:3px;margin-bottom:6px}
.palette-swatch{width:18px;height:18px;border-radius:3px;border:1px solid rgba(255,255,255,.1);cursor:pointer;transition:transform .1s}
.palette-swatch:hover{transform:scale(1.2);z-index:2}
.palette-name{font-size:10px;color:var(--text-muted);margin-bottom:3px}
.palette-actions{display:flex;gap:4px;margin-top:4px}

/* === THEME VARIANTS === */
:root.theme-midnight{--bg-depth-0:#0a0e1a;--bg-depth-1:#0f1424;--bg-depth-2:#141a2e;--bg-depth-3:#1a2038;--bg-depth-4:#202842;--accent:#7c9cff;--accent-dim:rgba(124,156,255,.12);--border:rgba(124,156,255,.12)}
:root.theme-oled{--bg-depth-0:#000;--bg-depth-1:#0a0a0a;--bg-depth-2:#111;--bg-depth-3:#1a1a1a;--bg-depth-4:#222;--accent:#6c8cff;--accent-dim:rgba(108,140,255,.1);--border:rgba(255,255,255,.08)}

/* === PIXEL GRID === */
.pixel-grid-canvas{position:absolute;inset:0;pointer-events:none;z-index:3;image-rendering:pixelated}

/* === LIQUIFY OVERLAY === */
#liquify-overlay{position:fixed;inset:0;z-index:29000;background:var(--bg-depth-0);display:none;flex-direction:column}
#liquify-overlay.visible{display:flex}
#liquify-topbar{height:40px;background:var(--bg-depth-1);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 12px;gap:10px}
#liquify-topbar label{font-size:11px;color:var(--text-muted)}
#liquify-topbar input[type="range"]{width:80px}
#liquify-topbar .btn{padding:3px 12px;font-size:11px}
#liquify-canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden}

/* === TIMELINE / ANIMATION === */
#timeline-panel{position:fixed;bottom:24px;left:220px;right:240px;height:140px;background:var(--bg-depth-1);border-top:1px solid var(--border);border-radius:8px 8px 0 0;z-index:20000;display:none;flex-direction:column;box-shadow:0 -4px 16px rgba(0,0,0,.3)}
#timeline-panel.visible{display:flex}
#timeline-header{height:32px;display:flex;align-items:center;padding:0 10px;gap:6px;border-bottom:1px solid var(--border);flex-shrink:0}
#timeline-header .btn{padding:2px 8px;font-size:11px}
#timeline-header span{font-size:11px;color:var(--text-secondary)}
.timeline-transport{display:flex;gap:2px;align-items:center}
.timeline-transport button{width:26px;height:26px;border:none;background:var(--bg-depth-3);color:var(--text-primary);border-radius:4px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:background .15s}
.timeline-transport button:hover{background:var(--accent-dim)}
.timeline-transport button.active{background:var(--accent);color:#fff}
#timeline-frames{flex:1;display:flex;gap:4px;padding:8px;overflow-x:auto;align-items:flex-start}
.frame-thumb{width:80px;min-width:80px;border:2px solid var(--border);border-radius:6px;cursor:pointer;position:relative;transition:border-color .15s,transform .15s;overflow:hidden;background:var(--bg-depth-3)}
.frame-thumb.active{border-color:var(--accent);transform:scale(1.05)}
.frame-thumb canvas{width:100%;display:block;border-radius:4px}
.frame-thumb .frame-num{position:absolute;bottom:2px;left:4px;font-size:9px;font-family:'JetBrains Mono',monospace;color:var(--text-primary);background:rgba(0,0,0,.6);padding:1px 4px;border-radius:2px}
.frame-thumb .frame-del{position:absolute;top:2px;right:3px;font-size:11px;color:var(--text-muted);cursor:pointer;opacity:0;transition:opacity .15s}
.frame-thumb:hover .frame-del{opacity:1}

/* === ACTION / MACRO PANEL === */
#macro-panel{position:fixed;right:240px;bottom:170px;width:260px;background:var(--bg-depth-1);border:1px solid var(--border);border-radius:8px;z-index:20001;display:none;box-shadow:0 4px 20px rgba(0,0,0,.4)}
#macro-panel.visible{display:block}
#macro-header{height:30px;display:flex;align-items:center;padding:0 10px;gap:6px;border-bottom:1px solid var(--border)}
#macro-header span{font-size:11px;color:var(--text-secondary);flex:1}
.macro-list{max-height:200px;overflow-y:auto;padding:4px}
.macro-step{padding:4px 8px;font-size:10px;color:var(--text-primary);font-family:'JetBrains Mono',monospace;border-bottom:1px solid var(--border)}
.macro-step:last-child{border:none}
.macro-controls{display:flex;gap:4px;padding:6px;border-top:1px solid var(--border)}
.macro-controls .btn{flex:1;padding:3px 0;font-size:10px}
.recording-indicator{width:8px;height:8px;border-radius:50%;background:#ff4444;animation:recBlink 1s infinite}
@keyframes recBlink{0%,100%{opacity:1}50%{opacity:.3}}

/* === CURVED TEXT === */
.curved-text-preview{width:100%;height:120px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:6px;display:flex;align-items:center;justify-content:center;margin-bottom:8px;overflow:hidden}
.curved-text-preview canvas{max-width:100%;max-height:100%}
</style>
</head>
<body>

<!-- ===== TOP MENU ===== -->
<div id="topbar">
    <div class="logo">OpenShop<span>v0.18.0</span></div>
    <div class="menu-item">File
        <div class="menu-dropdown">
            <div class="dd-item" onclick="OS.newImage()">New</div>
            <div class="dd-item" onclick="OS.openFile()">Open Image</div>
            <div class="dd-item" onclick="OS.openPSD()">Open PSD</div>
            <div class="dd-sep"></div>
            <div class="dd-sub dd-item">Export As
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.saveFile('png')">PNG</div>
                    <div class="dd-item" onclick="OS.saveFile('jpeg')">JPEG</div>
                    <div class="dd-item" onclick="OS.saveFile('webp')">WebP</div>
                    <div class="dd-item" onclick="OS.saveFile('svg')">SVG</div>
                    <div class="dd-item" onclick="OS.exportPDF()">PDF</div>
                </div>
            </div>
            <div class="dd-item" onclick="OS.batchExport()">Batch Export...</div>
            <div class="dd-item" onclick="OS.showExportSettings()">Export Settings...</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.showTemplates()">Templates...</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.saveProject()">Save Project (JSON)</div>
            <div class="dd-item" onclick="OS.openProject()">Open Project</div>
        </div>
    </div>
    <div class="menu-item">Edit
        <div class="menu-dropdown">
            <div class="dd-item" onclick="OS.undo()">Undo</div>
            <div class="dd-item" onclick="OS.redo()">Redo</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.copyObj()">Copy</div>
            <div class="dd-item" onclick="OS.pasteObj()">Paste</div>
            <div class="dd-item" onclick="OS.duplicateSelected()">Duplicate</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.deleteSelected()">Delete</div>
            <div class="dd-sep"></div>
            <div class="dd-sub dd-item">Transform
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.showFreeTransform()">Free Transform...</div>
                    <div class="dd-item" onclick="OS.skewObject()">Skew...</div>
                    <div class="dd-item" onclick="OS.showPerspective()">Perspective...</div>
                    <div class="dd-item" onclick="OS.showLiquify()">Liquify...</div>
                    <div class="dd-item" onclick="OS.showCurvedText()">Curved Text...</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.showPreferences()">Preferences...</div>
        </div>
    </div>
    <div class="menu-item">Select
        <div class="menu-dropdown">
            <div class="dd-item" onclick="OS.selectAll()">All<span style="float:right;color:var(--text-muted);font-size:10px">Ctrl+A</span></div>
            <div class="dd-item" onclick="OS.deselectAll()">Deselect<span style="float:right;color:var(--text-muted);font-size:10px">Ctrl+D</span></div>
            <div class="dd-item" onclick="OS.reselectSelection()">Reselect<span style="float:right;color:var(--text-muted);font-size:10px">Ctrl+Shift+D</span></div>
            <div class="dd-item" onclick="OS.invertSelection()">Inverse<span style="float:right;color:var(--text-muted);font-size:10px">Ctrl+Shift+I</span></div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.showColorRange()">Color Range...</div>
            <div class="dd-sep"></div>
            <div class="dd-sub dd-item">Modify
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.modifySelection('expand')">Expand...</div>
                    <div class="dd-item" onclick="OS.modifySelection('contract')">Contract...</div>
                    <div class="dd-item" onclick="OS.modifySelection('feather')">Feather...</div>
                    <div class="dd-item" onclick="OS.modifySelection('border')">Border...</div>
                    <div class="dd-item" onclick="OS.modifySelection('smooth')">Smooth</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.growSelection()">Grow</div>
            <div class="dd-item" onclick="OS.similarSelection()">Similar</div>
        </div>
    </div>
    <div class="menu-item">Image
        <div class="menu-dropdown">
            <div class="dd-item" onclick="OS.showResize()">Resize Canvas</div>
            <div class="dd-sep"></div>
            <div class="dd-sub dd-item">Image Rotation
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.flipH()">Flip Horizontal</div>
                    <div class="dd-item" onclick="OS.flipV()">Flip Vertical</div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="OS.rotateObj(90)">Rotate 90&deg; CW</div>
                    <div class="dd-item" onclick="OS.rotateObj(-90)">Rotate 90&deg; CCW</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Canvas Rotation
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.canvasRotate(90)">Rotate 90&deg; CW</div>
                    <div class="dd-item" onclick="OS.canvasRotate(-90)">Rotate 90&deg; CCW</div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="OS.canvasFlip('h')">Flip Horizontal</div>
                    <div class="dd-item" onclick="OS.canvasFlip('v')">Flip Vertical</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.flattenImage()">Flatten Image</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.addWatermark()">Add Watermark...</div>
            <div class="dd-item" onclick="OS.showImageInfo()">Image Info...</div>
            <div class="dd-item" onclick="OS.showBeforeAfter()">Before / After Compare</div>
        </div>
    </div>
    <div class="menu-item">Filter
        <div class="menu-dropdown">
            <div class="dd-sub dd-item">Blur
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.showFilterDialog('Blur')">Blur...</div>
                    <div class="dd-item" onclick="OS.applyFilterDirect('Sharpen')">Sharpen</div>
                    <div class="dd-item" onclick="OS.filterUnsharpMask()">Unsharp Mask...</div>
                    <div class="dd-item" onclick="OS.filterTiltShift()">Tilt Shift...</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Distort
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.showFilterDialog('Pixelate')">Pixelate...</div>
                    <div class="dd-item" onclick="OS.filterChromaticAberration()">Chromatic Aberration...</div>
                    <div class="dd-item" onclick="OS.adjLensCorrection()">Lens Correction...</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Noise
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.showFilterDialog('Noise')">Add Noise...</div>
                    <div class="dd-item" onclick="OS.filterNoiseGen()">Generate Noise...</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Stylize
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.applyFilterDirect('Emboss')">Emboss</div>
                    <div class="dd-item" onclick="OS.filterEdgeDetect()">Edge Detect</div>
                    <div class="dd-item" onclick="OS.filterSolarize()">Solarize</div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="OS.filterOilPaint()">Oil Paint...</div>
                    <div class="dd-item" onclick="OS.filterHalftone()">Halftone...</div>
                    <div class="dd-item" onclick="OS.filterDuotone()">Duotone...</div>
                    <div class="dd-item" onclick="OS.filterVignette()">Vignette...</div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="OS.filterPosterize()">Posterize...</div>
                    <div class="dd-item" onclick="OS.filterThreshold()">Threshold...</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-sub dd-item">Adjustments
                <div class="menu-dropdown">
                    <div class="dd-sub dd-item">Tone
                        <div class="menu-dropdown">
                            <div class="dd-item" onclick="OS.showFilterDialog('Brightness')">Brightness...</div>
                            <div class="dd-item" onclick="OS.showFilterDialog('Contrast')">Contrast...</div>
                            <div class="dd-item" onclick="OS.showFilterDialog('Gamma')">Gamma...</div>
                            <div class="dd-sep"></div>
                            <div class="dd-item" onclick="OS.adjExposure()">Exposure...</div>
                            <div class="dd-item" onclick="OS.adjShadowsHighlights()">Shadows / Highlights...</div>
                            <div class="dd-sep"></div>
                            <div class="dd-item" onclick="OS.showCurvesDialog()">Curves...</div>
                            <div class="dd-item" onclick="OS.showLevelsDialog()">Levels...</div>
                        </div>
                    </div>
                    <div class="dd-sub dd-item">Color
                        <div class="menu-dropdown">
                            <div class="dd-item" onclick="OS.showFilterDialog('Saturation')">Saturation...</div>
                            <div class="dd-item" onclick="OS.showFilterDialog('HueRotation')">Hue Rotation...</div>
                            <div class="dd-item" onclick="OS.adjVibrance()">Vibrance...</div>
                            <div class="dd-sep"></div>
                            <div class="dd-item" onclick="OS.showColorBalanceDialog()">Color Balance...</div>
                            <div class="dd-item" onclick="OS.showChannelMixer()">Channel Mixer...</div>
                            <div class="dd-item" onclick="OS.showGradientMap()">Gradient Map...</div>
                            <div class="dd-sep"></div>
                            <div class="dd-item" onclick="OS.adjPhotoFilter()">Photo Filter...</div>
                            <div class="dd-item" onclick="OS.adjSelectiveColor()">Selective Color...</div>
                            <div class="dd-item" onclick="OS.adjReplaceColor()">Replace Color...</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="dd-sub dd-item">Color Mode
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.applyFilterDirect('Grayscale')">Grayscale</div>
                    <div class="dd-item" onclick="OS.applyFilterDirect('Invert')">Invert</div>
                    <div class="dd-item" onclick="OS.applyFilterDirect('Sepia')">Sepia</div>
                    <div class="dd-item" onclick="OS.applyFilterDirect('BlackWhite')">Black & White</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.autoLevels()">Auto Levels</div>
            <div class="dd-item" onclick="OS.autoContrast()">Auto Contrast</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.aiRemoveBackground()">Remove Background (AI)</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.clearFilters()">Clear All Filters</div>
        </div>
    </div>
    <div class="menu-item">AI
        <div class="menu-dropdown">
            <div class="dd-item" onclick="OS.aiRemoveBackground()">Background Remove</div>
            <div class="dd-item" onclick="OS.aiDepthMap()">Depth Map</div>
            <div class="dd-item" onclick="OS.aiObjectDetect()">Detect Objects</div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.aiUpscale(2)">Smart Upscale 2x</div>
            <div class="dd-item" onclick="OS.aiUpscale(4)">Smart Upscale 4x</div>
            <div class="dd-sep"></div>
            <div class="dd-item" style="color:var(--text-muted);font-size:10px;pointer-events:none">Models load on first use</div>
            <div class="dd-item" style="color:var(--text-muted);font-size:10px;pointer-events:none">No API keys required</div>
        </div>
    </div>
    <div class="menu-item">View
        <div class="menu-dropdown">
            <div class="dd-sub dd-item">Zoom
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.zoomIn()">Zoom In</div>
                    <div class="dd-item" onclick="OS.zoomOut()">Zoom Out</div>
                    <div class="dd-item" onclick="OS.zoomFit()">Fit to Screen</div>
                    <div class="dd-item" onclick="OS.zoomReset()">100%</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Show
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.toggleGrid()">Toggle Grid</div>
                    <div class="dd-item" onclick="OS.toggleRulers()">Toggle Rulers</div>
                    <div class="dd-item" onclick="OS.toggleSnap()">Toggle Snap to Grid</div>
                    <div class="dd-item" onclick="OS.togglePixelGrid()">Pixel Grid</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Guides
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.addGuide('horizontal')">Add Horizontal Guide</div>
                    <div class="dd-item" onclick="OS.addGuide('vertical')">Add Vertical Guide</div>
                    <div class="dd-sep"></div>
                    <div class="dd-item" onclick="OS.clearGuides()">Clear All Guides</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-sub dd-item">Panels
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.toggleTimeline()">Animation Timeline</div>
                    <div class="dd-item" onclick="OS.toggleMacroPanel()">Actions / Macros</div>
                </div>
            </div>
            <div class="dd-sub dd-item">Theme
                <div class="menu-dropdown">
                    <div class="dd-item" onclick="OS.setTheme('default')">Dark (Default)</div>
                    <div class="dd-item" onclick="OS.setTheme('midnight')">Midnight</div>
                    <div class="dd-item" onclick="OS.setTheme('oled')">OLED Black</div>
                </div>
            </div>
            <div class="dd-sep"></div>
            <div class="dd-item" onclick="OS.toggleFullscreen()">Fullscreen Mode</div>
            <div class="dd-item" onclick="OS.showShortcuts()">Keyboard Shortcuts...</div>
        </div>
    </div>
</div>

<!-- ===== LEFT TOOLBAR ===== -->
<div id="toolbar">
    <button class="tool-btn active" data-tool="select" data-tip="Move / Select (V)" onclick="OS.setTool('select')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg></button>
    <div class="tool-sep"></div>
    <div class="tool-group" data-group="selection">
        <button class="tool-btn" data-tool="marquee-rect" data-tip="Rect Marquee (M)" onclick="OS.setTool('marquee-rect')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="3 2"><rect x="3" y="3" width="18" height="18" rx="1"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="marquee-rect" data-tip="Rect Marquee" onclick="OS.flyoutSelect(this,'selection')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="3 2"><rect x="3" y="3" width="18" height="18" rx="1"/></svg></button>
            <button class="tool-btn" data-tool="marquee-ellipse" data-tip="Ellipse Marquee" onclick="OS.flyoutSelect(this,'selection')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="3 2"><ellipse cx="12" cy="12" rx="10" ry="7"/></svg></button>
            <button class="tool-btn" data-tool="lasso" data-tip="Lasso" onclick="OS.flyoutSelect(this,'selection')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12c0 4.97 4.03 9 9 9s9-4.03 9-9-4.03-9-9-9c-3.04 0-5.73 1.51-7.36 3.82"/><circle cx="7" cy="20" r="2" fill="currentColor"/></svg></button>
            <button class="tool-btn" data-tool="magic-wand" data-tip="Magic Wand (W)" onclick="OS.flyoutSelect(this,'selection')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 4V2m0 14v-2M8 9H6m14 0h-2m-2.8-3.8L14 4m-4.2 9.8L8.6 15m9.8-1.2L19.6 15M9.8 5.2L8.6 4"/><path d="M2 22l10-10"/><circle cx="15" cy="9" r="1" fill="currentColor"/></svg></button>
        </div>
    </div>
    <div class="tool-group" data-group="crop">
        <button class="tool-btn" data-tool="crop" data-tip="Crop (C)" onclick="OS.setTool('crop')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"/><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="crop" data-tip="Crop" onclick="OS.flyoutSelect(this,'crop')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"/><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"/></svg></button>
            <button class="tool-btn" data-tool="measure" data-tip="Measure" onclick="OS.flyoutSelect(this,'crop')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 20L20 2"/><path d="M6 16l2-2"/><path d="M10 12l2-2"/><path d="M14 8l2-2"/><circle cx="2" cy="20" r="1.5" fill="currentColor"/><circle cx="20" cy="2" r="1.5" fill="currentColor"/></svg></button>
        </div>
    </div>
    <div class="tool-sep"></div>
    <div class="tool-group" data-group="brush">
        <button class="tool-btn" data-tool="brush" data-tip="Brush (B)" onclick="OS.setTool('brush')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="brush" data-tip="Brush" onclick="OS.flyoutSelect(this,'brush')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
            <button class="tool-btn" data-tool="pencil" data-tip="Pencil" onclick="OS.flyoutSelect(this,'brush')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg></button>
            <button class="tool-btn" data-tool="spray" data-tip="Spray / Airbrush" onclick="OS.flyoutSelect(this,'brush')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="12" width="10" height="10" rx="2"/><path d="M11 12V8"/><circle cx="7" cy="4" r="1" fill="currentColor"/><circle cx="11" cy="3" r="1" fill="currentColor"/><circle cx="15" cy="4" r="1" fill="currentColor"/></svg></button>
        </div>
    </div>
    <button class="tool-btn" data-tool="eraser" data-tip="Eraser (E)" onclick="OS.setTool('eraser')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16l9-9 8 8-4 4z"/><path d="M6 11l8 8"/></svg></button>
    <div class="tool-group" data-group="stamp">
        <button class="tool-btn" data-tool="clone" data-tip="Clone Stamp (S)" onclick="OS.setTool('clone')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4m-10-10h4m12 0h4"/><circle cx="12" cy="12" r="9" stroke-dasharray="2 3"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="clone" data-tip="Clone Stamp" onclick="OS.flyoutSelect(this,'stamp')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4m-10-10h4m12 0h4"/><circle cx="12" cy="12" r="9" stroke-dasharray="2 3"/></svg></button>
            <button class="tool-btn" data-tool="healing" data-tip="Healing Brush" onclick="OS.flyoutSelect(this,'stamp')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 2l4 4-12 12H6v-4L18 2z"/><path d="M14 6l4 4"/><line x1="2" y1="22" x2="22" y2="22"/></svg></button>
        </div>
    </div>
    <div class="tool-group" data-group="retouch">
        <button class="tool-btn" data-tool="dodge" data-tip="Dodge" onclick="OS.setTool('dodge')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><path d="M12 3v18"/><path d="M3 12h9" fill="currentColor" stroke="none" opacity=".3"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="dodge" data-tip="Dodge (Lighten)" onclick="OS.flyoutSelect(this,'retouch')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><path d="M12 3v18"/><path d="M3 12h9" fill="currentColor" stroke="none" opacity=".3"/></svg></button>
            <button class="tool-btn" data-tool="burn" data-tip="Burn (Darken)" onclick="OS.flyoutSelect(this,'retouch')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><path d="M12 3v18"/><path d="M12 12h9" fill="currentColor" stroke="none" opacity=".5"/></svg></button>
            <button class="tool-btn" data-tool="sponge" data-tip="Sponge" onclick="OS.flyoutSelect(this,'retouch')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="8" width="16" height="12" rx="2"/><path d="M8 8V6a4 4 0 0 1 8 0v2"/><line x1="8" y1="12" x2="16" y2="12"/></svg></button>
            <button class="tool-btn" data-tool="smudge" data-tip="Smudge" onclick="OS.flyoutSelect(this,'retouch')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 4l-4 4c-2 2-5 2-8 5s-1 6 2 7 5-1 7-4 3-6 5-8l4-4z"/></svg></button>
        </div>
    </div>
    <div class="tool-sep"></div>
    <div class="tool-group" data-group="shape">
        <button class="tool-btn" data-tool="rect" data-tip="Rectangle (R)" onclick="OS.setTool('rect')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="rect" data-tip="Rectangle" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/></svg></button>
            <button class="tool-btn" data-tool="circle" data-tip="Ellipse" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg></button>
            <button class="tool-btn" data-tool="triangle" data-tip="Triangle" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3L2 21h20L12 3z"/></svg></button>
            <button class="tool-btn" data-tool="line" data-tip="Line (L)" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg></button>
            <button class="tool-btn" data-tool="arrow" data-tip="Arrow" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="10 5 19 5 19 14"/></svg></button>
            <button class="tool-btn" data-tool="polygon" data-tip="Polygon" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l8.5 6.2-3.2 10H6.7L3.5 8.2z"/></svg></button>
            <button class="tool-btn" data-tool="star" data-tip="Star" onclick="OS.flyoutSelect(this,'shape')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01z"/></svg></button>
        </div>
    </div>
    <button class="tool-btn" data-tool="pen" data-tip="Pen (P)" onclick="OS.setTool('pen')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg></button>
    <button class="tool-btn" data-tool="text" data-tip="Text (T)" onclick="OS.setTool('text')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9.5" y1="20" x2="14.5" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg></button>
    <div class="tool-sep"></div>
    <div class="tool-group" data-group="fillgrp">
        <button class="tool-btn" data-tool="gradient" data-tip="Gradient (G)" onclick="OS.setTool('gradient')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="21" x2="21" y2="3" stroke-width="1" opacity=".4"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="gradient" data-tip="Gradient" onclick="OS.flyoutSelect(this,'fillgrp')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="21" x2="21" y2="3" stroke-width="1" opacity=".4"/></svg></button>
            <button class="tool-btn" data-tool="fill" data-tip="Fill Bucket" onclick="OS.flyoutSelect(this,'fillgrp')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 21v-3l9-9 3 3-9 9H3z"/><path d="M14 6l3-3 3 3"/><path d="M20 12.5a1.5 1.5 0 0 0 3 0c0-1.5-3-4-3-4s-3 2.5-3 4a1.5 1.5 0 0 0 3 0z"/></svg></button>
            <button class="tool-btn" data-tool="pattern" data-tip="Pattern Fill" onclick="OS.flyoutSelect(this,'fillgrp')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg></button>
        </div>
    </div>
    <button class="tool-btn" data-tool="eyedropper" data-tip="Eyedropper (I)" onclick="OS.setTool('eyedropper')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 21v-3l9-9 3 3-9 9H3z"/><path d="M14.5 6.5l3-3a2.12 2.12 0 0 1 3 3l-3 3"/></svg></button>
    <button class="tool-btn" data-tool="note" data-tip="Sticky Note" onclick="OS.setTool('note')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15.5 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3z"/><polyline points="14 3 14 8 21 8"/></svg></button>
    <div class="tool-sep"></div>
    <div class="tool-group" data-group="nav">
        <button class="tool-btn" data-tool="pan" data-tip="Pan (H)" onclick="OS.setTool('pan')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 11V6a2 2 0 0 0-4 0v5"/><path d="M14 10V4a2 2 0 0 0-4 0v6"/><path d="M10 10.5V6a2 2 0 0 0-4 0v8"/><path d="M18 8a2 2 0 0 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg></button>
        <div class="tool-flyout">
            <button class="tool-btn" data-tool="pan" data-tip="Pan" onclick="OS.flyoutSelect(this,'nav')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 11V6a2 2 0 0 0-4 0v5"/><path d="M14 10V4a2 2 0 0 0-4 0v6"/><path d="M10 10.5V6a2 2 0 0 0-4 0v8"/><path d="M18 8a2 2 0 0 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg></button>
            <button class="tool-btn" data-tool="zoom" data-tip="Zoom (Z)" onclick="OS.flyoutSelect(this,'nav')"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
        </div>
    </div>
</div>

<!-- ===== TOOL OPTIONS BAR ===== -->
<div id="tool-options">
    <div class="opt-group" id="opt-brush" style="display:none">
        <label>Preset</label>
        <select id="brush-preset" onchange="OS.setBrushPreset(this.value)">
            <option value="round">Round</option><option value="soft">Soft Round</option><option value="flat">Flat/Calligraphy</option>
            <option value="scatter">Scatter</option><option value="pixel">Pixel</option>
        </select>
        <label>Size</label>
        <input type="range" id="brush-size" min="1" max="150" value="8" oninput="OS.setBrushSize(this.value)">
        <span class="opt-val" id="brush-size-val">8</span>
        <label>Opacity</label>
        <input type="range" id="brush-opacity" min="1" max="100" value="100" oninput="OS.setBrushOpacity(this.value)">
        <span class="opt-val" id="brush-opacity-val">100</span>
    </div>
    <div class="opt-group" id="opt-spray" style="display:none">
        <label>Density</label>
        <input type="range" id="spray-density" min="5" max="100" value="30" oninput="OS.state.sprayDensity=+this.value">
        <label>Width</label>
        <input type="range" id="spray-width" min="5" max="150" value="30" oninput="OS.state.sprayWidth=+this.value">
    </div>
    <div class="opt-group" id="opt-shape" style="display:none">
        <label>Fill</label><input type="color" id="shape-fill" value="#6c8cff" onchange="OS.state.shapeFill=this.value">
        <label>Stroke</label><input type="color" id="shape-stroke" value="#ffffff" onchange="OS.state.shapeStroke=this.value">
        <label>Width</label><input type="number" id="shape-stroke-w" value="2" min="0" max="50" onchange="OS.state.shapeStrokeWidth=+this.value">
        <label><input type="checkbox" id="shape-filled" checked onchange="OS.state.shapeFilled=this.checked"> Filled</label>
        <label>Dash</label><select id="shape-dash" onchange="OS.state.shapeDash=this.value" style="font-size:11px">
            <option value="">Solid</option><option value="8,4">Dashed</option><option value="2,4">Dotted</option><option value="12,4,2,4">Dash-Dot</option><option value="16,8">Long Dash</option>
        </select>
    </div>
    <div class="opt-group" id="opt-text" style="display:none">
        <label>Font</label>
        <select id="text-font" onchange="OS.state.textFont=this.value">
            <option>DM Sans</option><option>Arial</option><option>Georgia</option><option>Courier New</option>
            <option>Verdana</option><option>Times New Roman</option><option>JetBrains Mono</option><option>Impact</option>
        </select>
        <label>Size</label><input type="number" id="text-size" value="24" min="8" max="200" onchange="OS.state.textSize=+this.value">
        <label>Color</label><input type="color" id="text-color" value="#ffffff" onchange="OS.state.textColor=this.value">
        <label><input type="checkbox" id="text-bold" onchange="OS.state.textBold=this.checked"> B</label>
        <label><input type="checkbox" id="text-italic" onchange="OS.state.textItalic=this.checked"> I</label>
    </div>
    <div class="opt-group" id="opt-gradient" style="display:none">
        <label>From</label><input type="color" id="grad-from" value="#6c8cff" onchange="OS.state.gradFrom=this.value">
        <label>To</label><input type="color" id="grad-to" value="#000000" onchange="OS.state.gradTo=this.value">
        <label>Type</label>
        <select id="grad-type" onchange="OS.state.gradType=this.value"><option value="linear">Linear</option><option value="radial">Radial</option></select>
    </div>
    <div class="opt-group" id="opt-pattern" style="display:none">
        <label>Pattern</label>
        <select id="pattern-type" onchange="OS.state.patternType=this.value">
            <option value="checkerboard">Checkerboard</option><option value="stripes">Stripes</option><option value="dots">Dots</option>
            <option value="grid">Grid</option><option value="diagonal">Diagonal</option><option value="crosshatch">Crosshatch</option>
        </select>
        <label>Scale</label><input type="range" id="pattern-scale" min="5" max="80" value="20" oninput="OS.state.patternScale=+this.value">
        <label>Color</label><input type="color" id="pattern-color" value="#6c8cff" onchange="OS.state.patternColor=this.value">
    </div>
    <div class="opt-group" id="opt-clone" style="display:none">
        <label>Size</label>
        <input type="range" id="clone-size" min="5" max="100" value="20" oninput="OS.state.cloneSize=+this.value;document.getElementById('clone-size-val').textContent=this.value">
        <span class="opt-val" id="clone-size-val">20</span>
        <span style="color:var(--text-muted);font-size:11px;margin-left:8px">Alt+Click source</span>
    </div>
    <div class="opt-group" id="opt-wand" style="display:none">
        <label>Tolerance</label>
        <input type="range" id="wand-tolerance" min="0" max="100" value="32" oninput="OS.state.wandTolerance=+this.value;document.getElementById('wand-tol-val').textContent=this.value">
        <span class="opt-val" id="wand-tol-val">32</span>
        <label><input type="checkbox" id="wand-contiguous" checked onchange="OS.state.wandContiguous=this.checked"> Contiguous</label>
    </div>
    <div class="opt-group" id="opt-crop" style="display:none">
        <label>Ratio</label>
        <select id="crop-ratio" onchange="OS.setCropRatio(this.value)" style="font-size:11px">
            <option value="free">Freeform</option>
            <option value="original">Original Ratio</option>
            <option value="1:1">1:1 (Square)</option>
            <option value="4:3">4:3</option>
            <option value="3:2">3:2</option>
            <option value="16:9">16:9</option>
            <option value="9:16">9:16 (Portrait)</option>
            <option value="5:4">5:4</option>
            <option value="2:3">2:3</option>
            <option value="custom">Custom...</option>
        </select>
        <label>W</label><input id="crop-w" type="number" style="width:52px;height:22px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:3px;color:var(--text-primary);font-size:11px;text-align:center" onchange="OS.setCropSize()">
        <label>x</label>
        <label>H</label><input id="crop-h" type="number" style="width:52px;height:22px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:3px;color:var(--text-primary);font-size:11px;text-align:center" onchange="OS.setCropSize()">
        <button class="btn" style="padding:3px 8px;font-size:11px" onclick="OS.swapCropRatio()" title="Swap W/H">&#8646;</button>
        <span style="flex:1"></span>
        <button class="btn btn-primary" style="padding:3px 14px;font-size:11px" onclick="OS.applyCrop()">Apply</button>
        <button class="btn" style="padding:3px 10px;font-size:11px" onclick="OS.cancelCrop()">Cancel</button>
    </div>
    <div class="opt-group" id="opt-marquee" style="display:none"><span style="color:var(--text-muted);font-size:11px">Drag to create selection.</span></div>
    <div class="opt-group" id="opt-lasso" style="display:none"><span style="color:var(--text-muted);font-size:11px">Click to add points. Double-click to close selection.</span></div>
    <div class="opt-group" id="opt-pen" style="display:none">
        <span style="color:var(--text-muted);font-size:11px">Click to add anchor points. Double-click to finish path.</span>
        <label>Stroke</label><input type="color" id="pen-stroke" value="#ffffff" onchange="OS.state.penStroke=this.value">
        <label>Width</label><input type="number" id="pen-width" value="2" min="1" max="20" style="width:45px" onchange="OS.state.penWidth=+this.value">
        <label><input type="checkbox" id="pen-filled" onchange="OS.state.penFilled=this.checked"> Fill</label>
    </div>
    <div class="opt-group" id="opt-polygon" style="display:none">
        <label>Sides</label><input type="number" id="poly-sides" value="5" min="3" max="20" style="width:45px" onchange="OS.state.polySides=+this.value">
        <label>Fill</label><input type="color" id="poly-fill" value="#6c8cff" onchange="OS.state.shapeFill=this.value">
        <label>Stroke</label><input type="color" id="poly-stroke" value="#ffffff" onchange="OS.state.shapeStroke=this.value">
        <label><input type="checkbox" id="poly-filled" checked onchange="OS.state.shapeFilled=this.checked"> Filled</label>
    </div>
    <div class="opt-group" id="opt-star" style="display:none">
        <label>Points</label><input type="number" id="star-points" value="5" min="3" max="20" style="width:45px" onchange="OS.state.starPoints=+this.value">
        <label>Inner R</label><input type="range" id="star-inner" min="10" max="90" value="40" oninput="OS.state.starInner=+this.value">
        <label>Fill</label><input type="color" id="star-fill" value="#6c8cff" onchange="OS.state.shapeFill=this.value">
        <label><input type="checkbox" id="star-filled" checked onchange="OS.state.shapeFilled=this.checked"> Filled</label>
    </div>
    <div class="opt-group" id="opt-healing" style="display:none">
        <label>Size</label>
        <input type="range" id="healing-size" min="5" max="80" value="15" oninput="OS.state.healingSize=+this.value;document.getElementById('heal-size-val').textContent=this.value">
        <span class="opt-val" id="heal-size-val">15</span>
        <span style="color:var(--text-muted);font-size:11px;margin-left:8px">Click to heal blemish</span>
    </div>
    <div class="opt-group" id="opt-dodge" style="display:none">
        <label>Size</label><input type="range" id="dodge-size" min="5" max="100" value="20" oninput="OS.state.dodgeSize=+this.value">
        <label>Exposure</label><input type="range" id="dodge-exp" min="5" max="100" value="30" oninput="OS.state.dodgeExposure=+this.value">
        <label>Range</label><select id="dodge-range" onchange="OS.state.dodgeRange=this.value" style="font-size:11px"><option value="midtones">Midtones</option><option value="shadows">Shadows</option><option value="highlights">Highlights</option></select>
    </div>
    <div class="opt-group" id="opt-burn" style="display:none">
        <label>Size</label><input type="range" id="burn-size" min="5" max="100" value="20" oninput="OS.state.burnSize=+this.value">
        <label>Exposure</label><input type="range" id="burn-exp" min="5" max="100" value="30" oninput="OS.state.burnExposure=+this.value">
        <label>Range</label><select id="burn-range" onchange="OS.state.burnRange=this.value" style="font-size:11px"><option value="midtones">Midtones</option><option value="shadows">Shadows</option><option value="highlights">Highlights</option></select>
    </div>
    <div class="opt-group" id="opt-sponge" style="display:none">
        <label>Size</label><input type="range" id="sponge-size" min="5" max="100" value="20" oninput="OS.state.spongeSize=+this.value">
        <label>Flow</label><input type="range" id="sponge-flow" min="5" max="100" value="50" oninput="OS.state.spongeFlow=+this.value">
        <label>Mode</label><select id="sponge-mode" onchange="OS.state.spongeMode=this.value" style="font-size:11px"><option value="saturate">Saturate</option><option value="desaturate">Desaturate</option></select>
    </div>
    <div class="opt-group" id="opt-smudge" style="display:none">
        <label>Size</label><input type="range" id="smudge-size" min="3" max="80" value="15" oninput="OS.state.smudgeSize=+this.value">
        <label>Strength</label><input type="range" id="smudge-str" min="10" max="100" value="60" oninput="OS.state.smudgeStrength=+this.value">
    </div>
    <div class="opt-group" id="opt-measure" style="display:none"><span style="color:var(--text-muted);font-size:11px">Click two points to measure distance.</span><span id="measure-result" style="color:var(--accent);font-family:'JetBrains Mono',monospace;font-size:11px;margin-left:8px"></span></div>
    <div class="opt-group" id="opt-select" style="display:none"><span style="color:var(--text-muted);font-size:11px">Click to select. Drag to move. Handles to resize/rotate.</span></div>
</div>

<!-- ===== RULERS ===== -->
<div class="ruler-h" id="ruler-h"><canvas id="ruler-h-canvas" height="20"></canvas></div>
<div class="ruler-v" id="ruler-v"><canvas id="ruler-v-canvas" width="20"></canvas></div>

<!-- ===== CANVAS ===== -->
<div id="canvas-area">
    <canvas id="editor-canvas"></canvas>
    <canvas class="canvas-grid" id="grid-overlay"></canvas>
    <div id="guides-container"></div>
    <div id="lasso-overlay" class="lasso-overlay" style="display:none"><svg><polygon class="lasso-path" points=""/></svg></div>
    <div id="pen-overlay" class="pen-overlay" style="display:none"><svg><path class="pen-path-preview" d=""/></svg></div>
    <div id="measure-overlay" style="position:absolute;inset:0;pointer-events:none;z-index:98;display:none"></div>
    <div id="selection-overlay" class="selection-rect" style="display:none"></div>
    <div id="crop-container" class="crop-overlay" style="display:none"></div>
</div>

<!-- ===== WELCOME SCREEN ===== -->
<div id="welcome-overlay">
    <div class="welcome-inner">
        <h1>OpenShop</h1>
        <p>A free, browser-based image editor. No uploads. No accounts. 100% client-side.</p>
        <div class="welcome-actions">
            <button class="btn btn-primary" onclick="OS.dismissWelcome();OS.newImage()">New Canvas</button>
            <button class="btn" onclick="OS.dismissWelcome();OS.openFile()">Open Image</button>
            <button class="btn" onclick="OS.dismissWelcome();OS.openPSD()">Open PSD</button>
        </div>
        <div class="template-section">
            <h3>Start from Template</h3>
            <div class="template-grid" id="template-grid"></div>
        </div>
        <div class="recent-files" id="recent-files-area"></div>
    </div>
</div>

<!-- ===== RIGHT PANELS ===== -->
<div id="panels">
    <!-- ===== TAB GROUP 1: Layers / Properties / Align ===== -->
    <div class="panel-tab-group ptg-flex">
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="OS.switchTab(this,'ptg1','ptg1-layers')">Layers</button>
            <button class="panel-tab" onclick="OS.switchTab(this,'ptg1','ptg1-props')">Properties</button>
            <button class="panel-tab" onclick="OS.switchTab(this,'ptg1','ptg1-align')">Align</button>
        </div>
        <!-- Layers Tab -->
        <div class="panel-tab-content active" id="ptg1-layers" data-group="ptg1">
            <div class="ptc-inner">
                <div class="panel-actions" style="display:flex;gap:2px;margin-bottom:6px;justify-content:flex-end">
                    <button class="panel-action" title="New Layer" onclick="OS.addLayer()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg></button>
                    <button class="panel-action" title="Duplicate" onclick="OS.duplicateLayer()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg></button>
                    <button class="panel-action" title="Merge Down" onclick="OS.mergeDown()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 18L12 22L16 18"/><path d="M12 2V22"/></svg></button>
                    <button class="panel-action" title="Delete" onclick="OS.deleteLayer()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
                    <button class="panel-action" title="Mask" onclick="OS.canvas.getActiveObject()&&OS.canvas.getActiveObject()._hasMask?OS.removeLayerMask():OS.addLayerMask()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="12" cy="12" r="5"/></svg></button>
                </div>
                <div class="blend-row">
                    <select id="layer-blend" onchange="OS.setLayerBlend(this.value)">
                        <option value="source-over">Normal</option><option value="multiply">Multiply</option><option value="screen">Screen</option>
                        <option value="overlay">Overlay</option><option value="darken">Darken</option><option value="lighten">Lighten</option>
                        <option value="color-dodge">Color Dodge</option><option value="color-burn">Color Burn</option>
                        <option value="hard-light">Hard Light</option><option value="soft-light">Soft Light</option>
                        <option value="difference">Difference</option><option value="exclusion">Exclusion</option>
                        <option value="hue">Hue</option><option value="saturation">Saturation</option>
                        <option value="color">Color</option><option value="luminosity">Luminosity</option>
                    </select>
                </div>
                <div class="opt-group" style="margin-bottom:6px">
                    <label>Opacity</label>
                    <input type="range" id="layer-opacity" min="0" max="100" value="100" oninput="OS.setLayerOpacity(this.value)">
                    <span class="opt-val" id="layer-opacity-val">100</span>
                </div>
                <div id="layers-list"></div>
                <div id="layers-empty">No layers. Click + to add one.</div>
            </div>
        </div>
        <!-- Properties Tab (Adjustments + Text FX + Layer Styles) -->
        <div class="panel-tab-content" id="ptg1-props" data-group="ptg1">
            <div class="ptc-inner">
                <div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.4px;font-weight:600;margin-bottom:6px">Adjustments</div>
                <div class="adj-row"><label>Brightness</label><input type="range" id="adj-bright" min="-100" max="100" value="0" oninput="OS.liveAdjust()"><span class="adj-val" id="adj-bright-val">0</span></div>
                <div class="adj-row"><label>Contrast</label><input type="range" id="adj-contrast" min="-100" max="100" value="0" oninput="OS.liveAdjust()"><span class="adj-val" id="adj-contrast-val">0</span></div>
                <div class="adj-row"><label>Saturation</label><input type="range" id="adj-sat" min="-100" max="100" value="0" oninput="OS.liveAdjust()"><span class="adj-val" id="adj-sat-val">0</span></div>
                <div class="adj-row"><label>Hue</label><input type="range" id="adj-hue" min="-180" max="180" value="0" oninput="OS.liveAdjust()"><span class="adj-val" id="adj-hue-val">0</span></div>
                <div class="adj-row"><label>Blur</label><input type="range" id="adj-blur" min="0" max="100" value="0" oninput="OS.liveAdjust()"><span class="adj-val" id="adj-blur-val">0</span></div>
                <div class="adj-btns">
                    <button class="btn btn-primary" onclick="OS.applyAdjustments()">Apply</button>
                    <button class="btn" onclick="OS.resetAdjustments()">Reset</button>
                </div>
                <div style="height:1px;background:var(--border);margin:10px 0"></div>
                <div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.4px;font-weight:600;margin-bottom:6px">Text Effects</div>
                <div class="text-fx-row"><label>Shadow X</label><input type="range" id="tfx-sx" min="-20" max="20" value="2" oninput="OS.applyTextFx()"></div>
                <div class="text-fx-row"><label>Shadow Y</label><input type="range" id="tfx-sy" min="-20" max="20" value="2" oninput="OS.applyTextFx()"></div>
                <div class="text-fx-row"><label>Blur</label><input type="range" id="tfx-blur" min="0" max="30" value="4" oninput="OS.applyTextFx()"></div>
                <div class="text-fx-row"><label>Color</label><input type="color" id="tfx-color" value="#000000" onchange="OS.applyTextFx()"></div>
                <div class="text-fx-row"><label>Outline W</label><input type="range" id="tfx-stroke" min="0" max="10" value="0" oninput="OS.applyTextFx()"></div>
                <div class="text-fx-row"><label>Outline C</label><input type="color" id="tfx-stroke-color" value="#000000" onchange="OS.applyTextFx()"></div>
                <div class="adj-btns">
                    <button class="btn btn-primary" onclick="OS.applyTextFx()" style="padding:3px 10px;font-size:11px">Apply</button>
                    <button class="btn" onclick="OS.clearTextFx()" style="padding:3px 10px;font-size:11px">Clear</button>
                </div>
                <div style="height:1px;background:var(--border);margin:10px 0"></div>
                <div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.4px;font-weight:600;margin-bottom:6px">Layer Styles</div>
                <details class="style-section" open>
                    <summary>Drop Shadow</summary>
                    <div class="layer-style-row"><label>Offset X</label><input type="range" id="ls-ds-x" min="-30" max="30" value="3" oninput="OS.previewLayerStyle()"></div>
                    <div class="layer-style-row"><label>Offset Y</label><input type="range" id="ls-ds-y" min="-30" max="30" value="3" oninput="OS.previewLayerStyle()"></div>
                    <div class="layer-style-row"><label>Blur</label><input type="range" id="ls-ds-blur" min="0" max="40" value="6" oninput="OS.previewLayerStyle()"></div>
                    <div class="layer-style-row"><label>Color</label><input type="color" id="ls-ds-color" value="#000000" onchange="OS.previewLayerStyle()"></div>
                </details>
                <details class="style-section">
                    <summary>Outer Glow</summary>
                    <div class="layer-style-row"><label>Size</label><input type="range" id="ls-og-size" min="0" max="40" value="0" oninput="OS.previewLayerStyle()"></div>
                    <div class="layer-style-row"><label>Color</label><input type="color" id="ls-og-color" value="#6c8cff" onchange="OS.previewLayerStyle()"></div>
                </details>
                <details class="style-section">
                    <summary>Stroke</summary>
                    <div class="layer-style-row"><label>Width</label><input type="range" id="ls-st-w" min="0" max="20" value="0" oninput="OS.previewLayerStyle()"></div>
                    <div class="layer-style-row"><label>Color</label><input type="color" id="ls-st-color" value="#ffffff" onchange="OS.previewLayerStyle()"></div>
                </details>
                <div class="adj-btns">
                    <button class="btn btn-primary" onclick="OS.applyLayerStyle()" style="padding:3px 10px;font-size:11px">Apply</button>
                    <button class="btn" onclick="OS.clearLayerStyle()" style="padding:3px 10px;font-size:11px">Clear</button>
                </div>
            </div>
        </div>
        <!-- Align Tab -->
        <div class="panel-tab-content" id="ptg1-align" data-group="ptg1">
            <div class="ptc-inner">
                <div class="align-grid">
                    <button onclick="OS.alignObjects('left')" title="Align Left"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="4" y1="2" x2="4" y2="22"/><rect x="8" y="4" width="12" height="6" rx="1"/><rect x="8" y="14" width="8" height="6" rx="1"/></svg></button>
                    <button onclick="OS.alignObjects('centerH')" title="Align Center"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="2" x2="12" y2="22"/><rect x="4" y="4" width="16" height="6" rx="1"/><rect x="6" y="14" width="12" height="6" rx="1"/></svg></button>
                    <button onclick="OS.alignObjects('right')" title="Align Right"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="20" y1="2" x2="20" y2="22"/><rect x="4" y="4" width="12" height="6" rx="1"/><rect x="8" y="14" width="8" height="6" rx="1"/></svg></button>
                    <button onclick="OS.alignObjects('top')" title="Align Top"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="2" y1="4" x2="22" y2="4"/><rect x="4" y="8" width="6" height="12" rx="1"/><rect x="14" y="8" width="6" height="8" rx="1"/></svg></button>
                    <button onclick="OS.alignObjects('centerV')" title="Align Middle"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="2" y1="12" x2="22" y2="12"/><rect x="4" y="4" width="6" height="16" rx="1"/><rect x="14" y="6" width="6" height="12" rx="1"/></svg></button>
                    <button onclick="OS.alignObjects('bottom')" title="Align Bottom"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="2" y1="20" x2="22" y2="20"/><rect x="4" y="4" width="6" height="12" rx="1"/><rect x="14" y="8" width="6" height="8" rx="1"/></svg></button>
                </div>
                <div class="distribute-row">
                    <button onclick="OS.distributeObjects('horizontal')">Distribute H</button>
                    <button onclick="OS.distributeObjects('vertical')">Distribute V</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== TAB GROUP 2: Color / Palettes ===== -->
    <div class="panel-tab-group">
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="OS.switchTab(this,'ptg2','ptg2-color')">Color</button>
            <button class="panel-tab" onclick="OS.switchTab(this,'ptg2','ptg2-palettes')">Swatches</button>
        </div>
        <div class="panel-tab-content active" id="ptg2-color" data-group="ptg2">
            <div class="ptc-inner" style="display:flex;flex-direction:column;gap:8px">
                <div class="color-wheel-wrap">
                    <canvas class="color-wheel-canvas" id="color-wheel" width="120" height="120"></canvas>
                    <div class="color-wheel-cursor" id="cw-cursor" style="left:60px;top:60px"></div>
                </div>
                <div class="hsb-sliders">
                    <div class="hsb-row"><label>H</label><input type="range" id="hsb-h" min="0" max="360" value="0" oninput="OS._hsbToFg()"><span class="hsb-val" id="hsb-h-val">0</span></div>
                    <div class="hsb-row"><label>S</label><input type="range" id="hsb-s" min="0" max="100" value="0" oninput="OS._hsbToFg()"><span class="hsb-val" id="hsb-s-val">0</span></div>
                    <div class="hsb-row"><label>B</label><input type="range" id="hsb-b" min="0" max="100" value="100" oninput="OS._hsbToFg()"><span class="hsb-val" id="hsb-b-val">100</span></div>
                </div>
                <div class="fg-bg-container">
                    <div class="fg-bg-box">
                        <div class="color-box fg" id="fg-color" style="background:#fff" onclick="document.getElementById('fg-picker').click()"></div>
                        <div class="color-box bg" id="bg-color" style="background:#000" onclick="document.getElementById('bg-picker').click()"></div>
                        <button class="color-swap" onclick="OS.swapColors()">&#8644;</button>
                        <input type="color" id="fg-picker" value="#ffffff" style="display:none" onchange="OS.setFgColor(this.value)">
                        <input type="color" id="bg-picker" value="#000000" style="display:none" onchange="OS.setBgColor(this.value)">
                    </div>
                    <div style="flex:1">
                        <div style="font-size:10px;color:var(--text-muted);margin-bottom:4px">FG / BG</div>
                        <div style="font-family:'JetBrains Mono',monospace;font-size:11px"><span id="fg-hex">#FFFFFF</span> / <span id="bg-hex">#000000</span></div>
                    </div>
                </div>
                <div class="color-swatches" id="color-swatches"></div>
            </div>
        </div>
        <div class="panel-tab-content" id="ptg2-palettes" data-group="ptg2">
            <div class="ptc-inner">
                <div class="palette-name">Default</div>
                <div class="palette-row" id="palette-default"></div>
                <div class="palette-name">Saved</div>
                <div class="palette-row" id="palette-saved"></div>
                <div class="palette-actions">
                    <button class="btn" onclick="OS.savePaletteColor()" style="padding:2px 8px;font-size:10px">+ Add FG</button>
                    <button class="btn" onclick="OS.clearPalette()" style="padding:2px 8px;font-size:10px">Clear</button>
                    <button class="btn" onclick="OS.exportPalette()" style="padding:2px 8px;font-size:10px">Export</button>
                    <button class="btn" onclick="OS.importPalette()" style="padding:2px 8px;font-size:10px">Import</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== TAB GROUP 3: History / Navigator / Info ===== -->
    <div class="panel-tab-group">
        <div class="panel-tabs">
            <button class="panel-tab active" onclick="OS.switchTab(this,'ptg3','ptg3-history')">History</button>
            <button class="panel-tab" onclick="OS.switchTab(this,'ptg3','ptg3-nav')">Navigator</button>
            <button class="panel-tab" onclick="OS.switchTab(this,'ptg3','ptg3-info')">Info</button>
        </div>
        <div class="panel-tab-content active" id="ptg3-history" data-group="ptg3">
            <div class="ptc-inner">
                <div id="history-list"></div>
            </div>
        </div>
        <div class="panel-tab-content" id="ptg3-nav" data-group="ptg3">
            <div class="ptc-inner">
                <div class="minimap-wrap" id="minimap-wrap" onclick="OS._minimapClick(event)">
                    <canvas id="minimap-canvas"></canvas>
                    <div class="minimap-viewport" id="minimap-vp"></div>
                </div>
                <div style="height:1px;background:var(--border);margin:10px 0"></div>
                <div style="font-size:10px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.4px;font-weight:600;margin-bottom:6px">Histogram</div>
                <div class="histogram-channel-btns">
                    <button class="active" onclick="OS._histChannel='luminance';OS.updateHistogram();this.parentElement.querySelectorAll('button').forEach(b=>b.classList.remove('active'));this.classList.add('active')">L</button>
                    <button onclick="OS._histChannel='red';OS.updateHistogram();this.parentElement.querySelectorAll('button').forEach(b=>b.classList.remove('active'));this.classList.add('active')">R</button>
                    <button onclick="OS._histChannel='green';OS.updateHistogram();this.parentElement.querySelectorAll('button').forEach(b=>b.classList.remove('active'));this.classList.add('active')">G</button>
                    <button onclick="OS._histChannel='blue';OS.updateHistogram();this.parentElement.querySelectorAll('button').forEach(b=>b.classList.remove('active'));this.classList.add('active')">B</button>
                </div>
                <canvas class="histogram-canvas" id="histogram-canvas" width="240" height="80"></canvas>
                <div class="histogram-stats"><span id="hist-min">Min: 0</span><span id="hist-mean">Mean: 128</span><span id="hist-max">Max: 255</span></div>
            </div>
        </div>
        <div class="panel-tab-content" id="ptg3-info" data-group="ptg3">
            <div class="ptc-inner">
                <dl class="info-grid" id="info-grid">
                    <dt>Canvas</dt><dd id="info-dims">1920 x 1080</dd>
                    <dt>Layers</dt><dd id="info-layers">1</dd>
                    <dt>Objects</dt><dd id="info-objects">0</dd>
                    <dt>Zoom</dt><dd id="info-zoom">100%</dd>
                    <dt>Color Mode</dt><dd>RGB 8bit</dd>
                    <dt>Cursor</dt><dd id="info-cursor">0, 0</dd>
                </dl>
            </div>
        </div>
    </div>
</div>

<!-- ===== STATUS BAR ===== -->
<div id="statusbar">
    <span id="canvas-dims">1920 x 1080</span><span class="sep"></span>
    <span id="zoom-display" onclick="OS.zoomFit()">100%</span><span class="sep"></span>
    <span id="cursor-pos">X: 0 Y: 0</span><span class="sep"></span>
    <span id="tool-display">Select</span><span style="flex:1"></span>
    <span id="object-count">0 objects</span>
</div>
<div id="ai-progress">
    <div class="ai-box">
        <div class="ai-title" id="ai-title"><span class="ai-spinner"></span>Loading AI Model...</div>
        <div class="ai-msg" id="ai-msg">Downloading model weights (cached after first use)</div>
        <div class="ai-bar-wrap"><div class="ai-bar" id="ai-bar"></div></div>
        <div class="ai-pct" id="ai-pct">0%</div>
    </div>
</div>
<div id="toast-container"></div>
<!-- ===== COMMAND PALETTE ===== -->
<div id="cmd-palette" onclick="if(event.target===this)OS.closeCmdPalette()">
    <div id="cmd-box">
        <input id="cmd-input" type="text" placeholder="Type a command... (Ctrl+K)" oninput="OS.filterCommands(this.value)" onkeydown="OS.cmdKeyDown(event)">
        <div id="cmd-results"></div>
    </div>
</div>
<!-- ===== CONTEXT MENU ===== -->
<div id="context-menu"></div>
<!-- ===== DROPZONE ===== -->
<div id="dropzone-overlay">
    <div class="dropzone-ring"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></div>
    <div class="dropzone-text">Drop files here</div>
    <div class="dropzone-sub">PNG, JPEG, WebP, PSD, SVG</div>
</div>
<!-- ===== ANNOTATION CONTAINER ===== -->
<div id="sticky-container" style="position:absolute;inset:0;pointer-events:none;z-index:99"></div>
<!-- ===== LIQUIFY ===== -->
<div id="liquify-overlay">
    <div id="liquify-topbar">
        <label>Tool</label>
        <select id="liq-tool"><option value="push">Forward Warp</option><option value="bloat">Bloat</option><option value="pucker">Pucker</option><option value="twirl-cw">Twirl CW</option><option value="twirl-ccw">Twirl CCW</option></select>
        <label>Size</label><input type="range" id="liq-size" min="10" max="200" value="60">
        <label>Pressure</label><input type="range" id="liq-pressure" min="10" max="100" value="50">
        <label>Density</label><input type="range" id="liq-density" min="10" max="100" value="50">
        <span style="flex:1"></span>
        <button class="btn" onclick="OS._liquifyReset()">Reset</button>
        <button class="btn" onclick="OS.closeLiquify()">Cancel</button>
        <button class="btn btn-primary" onclick="OS._liquifyApply()">Apply</button>
    </div>
    <div id="liquify-canvas-wrap"><canvas id="liquify-canvas"></canvas></div>
</div>
<!-- ===== TIMELINE ===== -->
<div id="timeline-panel">
    <div id="timeline-header">
        <span>Animation</span>
        <span style="flex:1"></span>
        <div class="timeline-transport">
            <button onclick="OS.prevFrame()" title="Previous"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h2v12H6zM9.5 12l8.5 6V6z"/></svg></button>
            <button id="tl-play" onclick="OS.togglePlay()" title="Play/Pause"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg></button>
            <button onclick="OS.nextFrame()" title="Next"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M16 6h2v12h-2zM6 18l8.5-6L6 6z"/></svg></button>
        </div>
        <button class="btn" onclick="OS.addFrame()">+ Frame</button>
        <button class="btn" onclick="OS.dupFrame()">Dup</button>
        <label style="font-size:10px;color:var(--text-muted)">FPS</label>
        <input type="number" id="tl-fps" value="12" min="1" max="60" style="width:40px;height:22px;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:3px;color:var(--text-primary);font-size:11px;text-align:center">
        <button class="btn btn-primary" onclick="OS.exportGIF()">Export GIF</button>
        <button class="btn" onclick="OS.toggleTimeline()" style="padding:2px 6px">X</button>
    </div>
    <div id="timeline-frames"></div>
</div>
<!-- ===== MACRO PANEL ===== -->
<div id="macro-panel">
    <div id="macro-header">
        <span>Actions</span>
        <div id="macro-rec-indicator" style="display:none"><div class="recording-indicator"></div></div>
    </div>
    <div class="macro-list" id="macro-list"></div>
    <div class="macro-controls">
        <button class="btn" id="macro-rec-btn" onclick="OS.toggleMacroRec()">Record</button>
        <button class="btn" onclick="OS.playMacro()">Play</button>
        <button class="btn" onclick="OS.clearMacro()">Clear</button>
        <button class="btn" onclick="OS.saveMacro()">Save</button>
        <button class="btn" onclick="OS.loadMacro()">Load</button>
    </div>
</div>
<!-- ===== BEFORE/AFTER COMPARE ===== -->
<div id="ba-overlay">
    <div id="ba-topbar">
        <span>Before / After Compare</span>
        <button class="btn" onclick="OS.closeBeforeAfter()">Close</button>
    </div>
    <div id="ba-container">
        <canvas id="ba-before"></canvas>
        <canvas id="ba-after"></canvas>
        <div id="ba-divider" style="left:50%"></div>
        <div class="ba-label before">Before</div>
        <div class="ba-label after">After</div>
    </div>
</div>
<input type="file" id="file-input" accept="image/*" style="display:none" onchange="OS.handleFileOpen(event)">
<input type="file" id="psd-input" accept=".psd" style="display:none" onchange="OS.handlePSDOpen(event)">
<input type="file" id="project-input" accept=".json" style="display:none" onchange="OS.handleProjectOpen(event)">

<script>
// ================================================================
//  OpenShop v0.18.0 — Core Engine (Phase 10: Pro Toolbar)
// ================================================================
const OS = {
    canvas: null, layers: [], activeLayerIdx: 0,
    history: [], historyIdx: -1, maxHistory: 60,
    zoom: 1, canvasW: 1920, canvasH: 1080,
    _shapeStart: null, _tempShape: null,
    _marqueeStart: null, _cloneSource: null, _cloneOffset: null,
    _adjDebounce: null,
    _cropRegion: null,
    plugins: [],
    guides: [],
    _lassoPoints: [],
    _measureStart: null,
    _penPoints: [],
    _histChannel: 'luminance',
    _baSnapshot: null,
    _cmdIdx: 0,
    _savedPalette: [],
    _stickyNotes: [],
    _rulerUnit: 'px',
    _currentTheme: 'default',
    _pixelGridVisible: false,
    _animFrames: [], _animIdx: 0, _animPlaying: false, _animTimer: null,
    _macroRecording: false, _macroSteps: [],
    _liquifyData: null,
    _prefs: { gridSize: 20, historyStates: 60, defaultW: 1920, defaultH: 1080, theme: 'dark', snapTolerance: 5 },
    gridVisible: false, rulersVisible: false, snapEnabled: false, gridSize: 20,
    templates: [
        { name:'HD 1080p', w:1920, h:1080, icon:'16:9', cat:'Video' },
        { name:'4K UHD', w:3840, h:2160, icon:'4K', cat:'Video' },
        { name:'Instagram Post', w:1080, h:1080, icon:'IG', cat:'Social' },
        { name:'Instagram Story', w:1080, h:1920, icon:'IS', cat:'Social' },
        { name:'Facebook Cover', w:820, h:312, icon:'FB', cat:'Social' },
        { name:'Twitter Header', w:1500, h:500, icon:'X', cat:'Social' },
        { name:'YouTube Thumb', w:1280, h:720, icon:'YT', cat:'Social' },
        { name:'LinkedIn Banner', w:1584, h:396, icon:'LI', cat:'Social' },
        { name:'A4 Portrait', w:2480, h:3508, icon:'A4', cat:'Print' },
        { name:'A4 Landscape', w:3508, h:2480, icon:'A4L', cat:'Print' },
        { name:'Letter', w:2550, h:3300, icon:'LTR', cat:'Print' },
        { name:'Business Card', w:1050, h:600, icon:'BC', cat:'Print' },
        { name:'Web Banner', w:728, h:90, icon:'AD', cat:'Web' },
        { name:'Favicon', w:512, h:512, icon:'ICO', cat:'Web' },
        { name:'Open Graph', w:1200, h:630, icon:'OG', cat:'Web' },
        { name:'Wallpaper QHD', w:2560, h:1440, icon:'QHD', cat:'Display' },
    ],
    state: {
        tool: 'select', fgColor: '#ffffff', bgColor: '#000000',
        brushSize: 8, brushOpacity: 100, brushPreset: 'round',
        shapeFill: '#6c8cff', shapeStroke: '#ffffff', shapeStrokeWidth: 2, shapeFilled: true,
        textFont: 'DM Sans', textSize: 24, textColor: '#ffffff', textBold: false, textItalic: false,
        gradFrom: '#6c8cff', gradTo: '#000000', gradType: 'linear',
        patternType: 'checkerboard', patternScale: 20, patternColor: '#6c8cff',
        cloneSize: 20, sprayDensity: 30, sprayWidth: 30, healingSize: 15,
        wandTolerance: 32, wandContiguous: true,
        penStroke: '#ffffff', penWidth: 2, penFilled: false,
        polySides: 5, starPoints: 5, starInner: 40, shapeDash: '',
        dodgeSize: 20, dodgeExposure: 30, dodgeRange: 'midtones',
        burnSize: 20, burnExposure: 30, burnRange: 'midtones',
        spongeSize: 20, spongeFlow: 50, spongeMode: 'saturate',
        smudgeSize: 15, smudgeStrength: 60,
        isDrawing: false, isPanning: false, panStart: null,
    },

    // ====================== INIT ======================
    init() {
        const area = document.getElementById('canvas-area');
        this.canvas = new fabric.Canvas('editor-canvas', {
            width: area.clientWidth, height: area.clientHeight,
            backgroundColor: '#1a1a1a', selection: true,
            preserveObjectStacking: true, enableRetinaScaling: true,
            stopContextMenu: true, fireRightClick: true,
        });
        this.createNewDocument(this.canvasW, this.canvasH);
        this.canvas.on('mouse:move', e => this.onMouseMove(e));
        this.canvas.on('mouse:down', e => this.onMouseDown(e));
        this.canvas.on('mouse:up', e => this.onMouseUp(e));
        this.canvas.on('object:modified', () => { this.saveHistory('Object Modified'); this.drawRulers(); });
        this.canvas.on('selection:created', () => this.updateStatus());
        this.canvas.on('selection:cleared', () => this.updateStatus());
        this.canvas.on('mouse:wheel', opt => this.onMouseWheel(opt));
        this.canvas.on('path:created', e => {
            // Eraser paths should erase to transparency, not draw white
            if (this.state.tool === 'eraser') {
                e.path.globalCompositeOperation = 'destination-out';
                e.path.stroke = 'rgba(0,0,0,1)';
            }
            this.layers[this.activeLayerIdx].objects.push(e.path);
            this.saveHistory('Draw'); this.updateLayersPanel();
        });
        window.addEventListener('resize', () => { this.resizeCanvas(); this.drawGrid(); this.drawRulers(); });
        window.addEventListener('beforeunload', e => {
            if (this.historyIdx > 0) { e.preventDefault(); e.returnValue = ''; }
        });
        this.initSwatches();
        this.setTool('select');
        this.updateLayersPanel(); this.updateStatus();
        const ca = document.getElementById('canvas-area');
        ca.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); });
        ca.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); this.handleDrop(e); });
        // Snap to grid
        this.canvas.on('object:moving', opt => {
            if (!this.snapEnabled) return;
            const g = this.gridSize, obj = opt.target;
            obj.set({ left: Math.round(obj.left / g) * g, top: Math.round(obj.top / g) * g });
        });
        // Welcome screen
        this.populateTemplates();
        this.populateRecentFiles();
        // PWA manifest
        this.initPWA();
        // Phase 6
        this.initColorWheel();
        this.updateHistogram();
        // Pen double-click to close
        ca.addEventListener('dblclick', e => {
            if (this.state.tool === 'lasso') this._lassoDoubleClick();
            if (this.state.tool === 'pen') this._penFinish();
        });
    },

    // ====================== DOCUMENT ======================
    createNewDocument(w, h) {
        this.canvasW = w; this.canvasH = h; this.layers = []; this.canvas.clear();
        this.canvas.setBackgroundColor(null, this.canvas.renderAll.bind(this.canvas));
        const boundary = this._createCheckerBoundary(w, h);
        this.canvas.add(boundary);
        this.layers.push({ name:'Background', visible:true, locked:true, opacity:100, blend:'source-over', objects:[boundary] });
        this.addLayer(); this.zoomFit();
        this.history=[]; this.historyIdx=-1; this.saveHistory('New Document'); this.updateLayersPanel();
        document.getElementById('canvas-dims').textContent = `${w} x ${h}`;
        this._captureBA();
    },
    _createCheckerBoundary(w, h) {
        const patSize = 16, half = patSize / 2;
        const pc = document.createElement('canvas'); pc.width = patSize; pc.height = patSize;
        const pctx = pc.getContext('2d');
        pctx.fillStyle = '#cdcdcd'; pctx.fillRect(0, 0, patSize, patSize);
        pctx.fillStyle = '#a0a0a0'; pctx.fillRect(0, 0, half, half); pctx.fillRect(half, half, half, half);
        const pat = new fabric.Pattern({ source: pc, repeat: 'repeat' });
        return new fabric.Rect({ left:0, top:0, width:w, height:h, fill:pat, selectable:false, evented:false, name:'__boundary__' });
    },
    newImage() {
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>New Image</h3>
            <div class="preset-grid">
                <div class="preset-btn" onclick="this.closest('.modal').querySelector('#ni-w').value=1920;this.closest('.modal').querySelector('#ni-h').value=1080">1920x1080</div>
                <div class="preset-btn" onclick="this.closest('.modal').querySelector('#ni-w').value=1280;this.closest('.modal').querySelector('#ni-h').value=720">1280x720</div>
                <div class="preset-btn" onclick="this.closest('.modal').querySelector('#ni-w').value=1080;this.closest('.modal').querySelector('#ni-h').value=1080">1080x1080</div>
                <div class="preset-btn" onclick="this.closest('.modal').querySelector('#ni-w').value=800;this.closest('.modal').querySelector('#ni-h').value=600">800x600</div>
                <div class="preset-btn" onclick="this.closest('.modal').querySelector('#ni-w').value=3840;this.closest('.modal').querySelector('#ni-h').value=2160">4K</div>
                <div class="preset-btn" onclick="this.closest('.modal').querySelector('#ni-w').value=2480;this.closest('.modal').querySelector('#ni-h').value=3508">A4 300dpi</div>
            </div>
            <div class="modal-row"><label>Width</label><input id="ni-w" type="number" value="1920" min="1" max="8000"></div>
            <div class="modal-row"><label>Height</label><input id="ni-h" type="number" value="1080" min="1" max="8000"></div>
            <div class="modal-row"><label>Background</label><input id="ni-bg" type="color" value="#ffffff"></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS.doNewImage(this.closest('.modal-overlay'))">Create</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    doNewImage(o) { const w=+o.querySelector('#ni-w').value||1920, h=+o.querySelector('#ni-h').value||1080; this.createNewDocument(w,h); o.remove(); this.toast(`New ${w}x${h}`, 'success'); },

    // ====================== FILE I/O ======================
    openFile() { document.getElementById('file-input').click(); },
    handleFileOpen(e) {
        const file = e.target.files[0]; if (!file) return;
        this._docName = file.name.replace(/\.[^.]+$/, '');
        const r = new FileReader(); r.onload = ev => {
            fabric.Image.fromURL(ev.target.result, img => {
                this.createNewDocument(img.width, img.height);
                img.set({ left:0, top:0, selectable:true, name:file.name });
                this.canvas.add(img); this.layers[this.activeLayerIdx].objects.push(img);
                this.zoomFit(); this.saveHistory('Open Image'); this.updateLayersPanel();
                this.toast(`Opened: ${file.name}`, 'success');
            });
        }; r.readAsDataURL(file); e.target.value='';
    },
    handleDrop(e) {
        const file = e.dataTransfer.files[0];
        if (!file) return;
        if (file.name.toLowerCase().endsWith('.psd')) { this._loadPSDFile(file); return; }
        if (!file.type.startsWith('image/')) return;
        const r = new FileReader(); r.onload = ev => {
            fabric.Image.fromURL(ev.target.result, img => {
                if (img.width > this.canvasW) img.scaleToWidth(this.canvasW * 0.8);
                img.set({ left:50, top:50, selectable:true, name:file.name });
                this.canvas.add(img); this.layers[this.activeLayerIdx].objects.push(img);
                this.canvas.setActiveObject(img); this.saveHistory('Drop Image'); this.updateLayersPanel();
                this.toast(`Added: ${file.name}`, 'success');
            });
        }; r.readAsDataURL(file);
    },
    saveFile(fmt) {
        if (fmt === 'svg') { this._exportSVG(); return; }
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0];
        const boundary = this.canvas.getObjects().find(o => o.name === '__boundary__');
        if (fmt === 'jpeg' && boundary) {
            // JPEG needs solid white background (no transparency)
            const origFill = boundary.fill;
            boundary.set('fill', '#ffffff');
            this.canvas.renderAll();
            const url = this.canvas.toDataURL({ format:fmt, quality:0.92, left:0, top:0, width:this.canvasW, height:this.canvasH });
            boundary.set('fill', origFill);
            this.canvas.viewportTransform = vpt; this.canvas.renderAll();
            const docName = (this._docName || 'openshop-export').replace(/[^a-zA-Z0-9_-]/g, '_');
            const a = document.createElement('a'); a.download = `${docName}.jpg`; a.href = url; a.click();
        } else {
            // PNG/WebP: hide boundary for transparency
            if (boundary) boundary.set('opacity', 0);
            this.canvas.renderAll();
            const url = this.canvas.toDataURL({ format:fmt, quality:1, left:0, top:0, width:this.canvasW, height:this.canvasH });
            if (boundary) boundary.set('opacity', 1);
            this.canvas.viewportTransform = vpt; this.canvas.renderAll();
            const docName = (this._docName || 'openshop-export').replace(/[^a-zA-Z0-9_-]/g, '_');
            const a = document.createElement('a'); a.download = `${docName}.${fmt}`; a.href = url; a.click();
        }
        this.toast(`Exported as ${fmt.toUpperCase()}`, 'success');
    },
    _exportSVG() {
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
        const svg = this.canvas.toSVG({ viewBox: { x:0, y:0, width:this.canvasW, height:this.canvasH }, width:this.canvasW, height:this.canvasH });
        this.canvas.viewportTransform = vpt; this.canvas.renderAll();
        const blob = new Blob([svg], { type:'image/svg+xml' });
        const a = document.createElement('a'); a.download='openshop-export.svg'; a.href=URL.createObjectURL(blob); a.click();
        this.toast('Exported as SVG', 'success');
    },
    batchExport() {
        const fmts = ['png','jpeg','webp','svg','pdf'];
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>Batch Export</h3>
            <p style="font-size:12px;color:var(--text-secondary);margin-bottom:12px">Export canvas to multiple formats at once.</p>
            ${fmts.map(f => `<div class="modal-row"><label style="width:60px">${f.toUpperCase()}</label><label><input type="checkbox" id="batch-${f}" checked> Export</label></div>`).join('')}
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS.doBatchExport(this.closest('.modal-overlay'))">Export All</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    doBatchExport(o) {
        ['png','jpeg','webp','svg','pdf'].forEach(f => { if (o.querySelector('#batch-'+f).checked) { if(f==='pdf') this.exportPDF(); else this.saveFile(f); } });
        o.remove(); this.toast('Batch export complete', 'success');
    },
    saveProject() {
        const json = this.canvas.toJSON(['name','excludeFromExport','globalCompositeOperation']);
        json._openShop = { version:'0.16.0', w:this.canvasW, h:this.canvasH, layers:this.layers.map(l=>({name:l.name,visible:l.visible,opacity:l.opacity,blend:l.blend})) };
        const blob = new Blob([JSON.stringify(json)],{type:'application/json'});
        const a = document.createElement('a'); a.download='openshop-project.json'; a.href=URL.createObjectURL(blob); a.click();
        this.toast('Project saved','success');
    },
    openProject() { document.getElementById('project-input').click(); },
    handleProjectOpen(e) {
        const file = e.target.files[0]; if (!file) return;
        const r = new FileReader(); r.onload = ev => {
            try {
                const json = JSON.parse(ev.target.result);
                if (json._openShop) { this.canvasW=json._openShop.w; this.canvasH=json._openShop.h; }
                this.canvas.loadFromJSON(json, () => {
                    this.canvas.renderAll(); this.rebuildLayersFromCanvas();
                    this.zoomFit(); this.saveHistory('Open Project'); this.toast('Project loaded','success');
                });
            } catch(err) { this.toast('Invalid project','error'); }
        }; r.readAsText(file); e.target.value='';
    },

    // ====================== PSD IMPORT ======================
    openPSD() { document.getElementById('psd-input').click(); },
    handlePSDOpen(e) { const file = e.target.files[0]; if (file) this._loadPSDFile(file); e.target.value=''; },
    _loadPSDFile(file) {
        this.toast('Parsing PSD...', 'info');
        const reader = new FileReader();
        reader.onload = async (ev) => {
            try {
                if (typeof agPsd === 'undefined' && typeof window.agPsd === 'undefined') {
                    this.toast('PSD library not loaded', 'error'); return;
                }
                const lib = window.agPsd || agPsd;
                const buffer = ev.target.result;
                const psd = lib.readPsd(new Uint8Array(buffer));
                this.createNewDocument(psd.width, psd.height);
                // Add composite image as base
                if (psd.canvas) {
                    const dataUrl = psd.canvas.toDataURL();
                    await new Promise(resolve => {
                        fabric.Image.fromURL(dataUrl, img => {
                            img.set({ left:0, top:0, selectable:true, name:'PSD Composite' });
                            this.canvas.add(img); this.layers[this.activeLayerIdx].objects.push(img);
                            resolve();
                        });
                    });
                }
                // Import individual layers
                if (psd.children && psd.children.length) {
                    for (const child of psd.children) {
                        if (child.canvas) {
                            const layerDataUrl = child.canvas.toDataURL();
                            this.addLayer();
                            this.layers[this.activeLayerIdx].name = child.name || 'PSD Layer';
                            if (typeof child.opacity === 'number') this.layers[this.activeLayerIdx].opacity = Math.round(child.opacity * 100 / 255);
                            this.layers[this.activeLayerIdx].visible = !child.hidden;
                            await new Promise(resolve => {
                                fabric.Image.fromURL(layerDataUrl, img => {
                                    img.set({ left: child.left||0, top: child.top||0, selectable:true, name: child.name||'Layer', visible: !child.hidden });
                                    if (typeof child.opacity === 'number') img.opacity = child.opacity / 255;
                                    this.canvas.add(img); this.layers[this.activeLayerIdx].objects.push(img);
                                    resolve();
                                });
                            });
                        }
                    }
                }
                this.zoomFit(); this.saveHistory('Import PSD'); this.updateLayersPanel();
                this.toast(`PSD imported: ${psd.children?psd.children.length:0} layers`, 'success');
            } catch(err) {
                console.error('PSD parse error:', err);
                this.toast('PSD import failed: ' + err.message, 'error');
            }
        };
        reader.readAsArrayBuffer(file);
    },

    // ====================== LAYERS ======================
    addLayer() {
        const idx = this.layers.length;
        this.layers.push({ name:`Layer ${idx}`, visible:true, opacity:100, blend:'source-over', objects:[] });
        this.activeLayerIdx = idx; this.updateLayersPanel(); this.saveHistory('New Layer');
    },
    deleteLayer() {
        if (this.layers.length === 0) return;
        const layer = this.layers[this.activeLayerIdx];
        if (layer.locked) { this.toast('Unlock layer first', 'error'); return; }
        layer.objects.forEach(o => this.canvas.remove(o));
        this.layers.splice(this.activeLayerIdx, 1);
        if (this.layers.length === 0) {
            this.activeLayerIdx = 0;
        } else {
            this.activeLayerIdx = Math.min(this.activeLayerIdx, this.layers.length-1);
        }
        this.canvas.renderAll(); this.updateLayersPanel(); this.saveHistory('Delete Layer');
    },
    duplicateLayer() {
        const src = this.layers[this.activeLayerIdx];
        const nl = { name:src.name+' Copy', visible:true, opacity:src.opacity, blend:src.blend, objects:[] };
        src.objects.forEach(o => {
            if (o.name === '__boundary__') return;
            o.clone(c => { c.set({left:o.left+10,top:o.top+10}); this.canvas.add(c); nl.objects.push(c); });
        });
        this.layers.splice(this.activeLayerIdx+1, 0, nl); this.activeLayerIdx++;
        this.canvas.renderAll(); this.updateLayersPanel(); this.saveHistory('Duplicate Layer');
    },
    mergeDown() {
        if (this.activeLayerIdx === 0) { this.toast('No layer below','error'); return; }
        const upper = this.layers[this.activeLayerIdx], lower = this.layers[this.activeLayerIdx-1];
        upper.objects.forEach(o => lower.objects.push(o));
        this.layers.splice(this.activeLayerIdx, 1); this.activeLayerIdx--;
        this.canvas.renderAll(); this.updateLayersPanel(); this.saveHistory('Merge Down');
    },
    selectLayer(idx) { this.activeLayerIdx = idx; this.canvas.discardActiveObject(); this.canvas.renderAll(); this.updateLayersPanel(); },
    toggleLayerVisibility(idx) {
        const l = this.layers[idx]; l.visible = !l.visible;
        l.objects.forEach(o => o.visible = l.visible);
        this.canvas.renderAll(); this.updateLayersPanel();
    },
    setLayerOpacity(val) {
        const l = this.layers[this.activeLayerIdx]; l.opacity = +val;
        l.objects.forEach(o => { if (o.name !== '__boundary__') o.opacity = val/100; });
        document.getElementById('layer-opacity-val').textContent = val; this.canvas.renderAll();
    },
    setLayerBlend(mode) {
        const l = this.layers[this.activeLayerIdx]; l.blend = mode;
        l.objects.forEach(o => { if (o.name !== '__boundary__') o.globalCompositeOperation = mode; });
        this.canvas.renderAll(); this.saveHistory('Blend: '+mode);
    },
    renameLayer(idx, newName) { this.layers[idx].name = newName; this.updateLayersPanel(); },
    flattenImage() {
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0];
        const boundary = this.canvas.getObjects().find(o => o.name === '__boundary__');
        if (boundary) boundary.set('opacity', 0);
        this.canvas.renderAll();
        const dataUrl = this.canvas.toDataURL({ left:0, top:0, width:this.canvasW, height:this.canvasH });
        if (boundary) boundary.set('opacity', 1);
        this.canvas.viewportTransform = vpt;
        this.createNewDocument(this.canvasW, this.canvasH);
        fabric.Image.fromURL(dataUrl, img => {
            img.set({ left:0, top:0, selectable:true, name:'Flattened' });
            this.canvas.add(img); this.layers[this.activeLayerIdx].objects.push(img);
            this.canvas.renderAll(); this.saveHistory('Flatten'); this.updateLayersPanel();
            this.toast('Image flattened', 'success');
        });
    },
    updateLayersPanel() {
        const list = document.getElementById('layers-list'); list.innerHTML = '';
        for (let i = this.layers.length-1; i >= 0; i--) {
            const l = this.layers[i], d = document.createElement('div');
            d.className = 'layer-item'+(i===this.activeLayerIdx?' active':'');
            const eyeSvg = l.visible
                ? '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
                : '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/>';
            const lockSvg = l.locked
                ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>'
                : '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>';
            const hasMask = l.objects.some(o => o._hasMask);
            const isBg = l.objects.some(o => o.name === '__boundary__');
            const thumbStyle = isBg ? 'layer-thumb-checker' : '';
            d.innerHTML = `<div class="layer-drag-handle" title="Drag to reorder">&#9776;</div>
                <button class="layer-vis ${l.visible?'':'hidden'}" onclick="event.stopPropagation();OS.toggleLayerVisibility(${i})"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${eyeSvg}</svg></button>
                <button class="layer-lock ${l.locked?'locked':''}" onclick="event.stopPropagation();OS.toggleLayerLock(${i})" title="${l.locked?'Unlock layer':'Lock layer'}">${lockSvg}</button>
                <div class="layer-thumb"><div class="${thumbStyle}" style="width:32px;height:32px;${isBg?'':'background:var(--bg-depth-4);'}border-radius:2px"></div></div>
                <div class="layer-info"><div class="layer-name" ondblclick="OS.startRenameLayer(this,${i})">${l.name}</div><div class="layer-type">${l.locked?'Locked &middot; ':''}${l.blend!=='source-over'?l.blend+' &middot; ':''}${l.objects.filter(o=>o.name!=='__boundary__').length} obj${hasMask?' &middot; M':''}</div></div>`;
            d.addEventListener('click', () => this.selectLayer(i));
            this.initLayerDrag(d, i);
            list.appendChild(d);
        }
        const al = this.layers[this.activeLayerIdx];
        if (al) {
            document.getElementById('layer-opacity').value = al.opacity;
            document.getElementById('layer-opacity-val').textContent = al.opacity;
            document.getElementById('layer-blend').value = al.blend;
        }
        this.updateInfoPanel();
    },
    toggleLayerLock(idx) {
        this.layers[idx].locked = !this.layers[idx].locked;
        const l = this.layers[idx];
        l.objects.forEach(o => {
            if (o.name === '__boundary__') return;
            o.selectable = !l.locked; o.evented = !l.locked;
        });
        this.canvas.renderAll(); this.updateLayersPanel();
        this.toast(l.locked ? 'Layer locked' : 'Layer unlocked', 'info');
    },
    startRenameLayer(el, idx) {
        const inp = document.createElement('input'); inp.className = 'layer-name-input';
        inp.value = this.layers[idx].name;
        el.replaceWith(inp); inp.focus(); inp.select();
        const finish = () => { this.renameLayer(idx, inp.value || this.layers[idx].name); };
        inp.addEventListener('blur', finish);
        inp.addEventListener('keydown', e => { if (e.key==='Enter') inp.blur(); });
    },
    rebuildLayersFromCanvas() {
        this.layers = [{ name:'Layer 0', visible:true, opacity:100, blend:'source-over', objects:[] }];
        this.canvas.getObjects().forEach(o => this.layers[0].objects.push(o));
        this.activeLayerIdx = 0; this.updateLayersPanel();
    },

    // ====================== TOOLS ======================
    // ====================== TOOL GROUP FLYOUTS ======================
    initToolGroups() {
        // Portal all flyouts to body so toolbar overflow doesn't clip them
        const flyoutHost = document.createElement('div');
        flyoutHost.id = 'flyout-host';
        flyoutHost.style.cssText = 'position:fixed;top:0;left:0;width:0;height:0;z-index:9999;pointer-events:none';
        document.body.appendChild(flyoutHost);
        document.querySelectorAll('.tool-group').forEach(grp => {
            const face = grp.querySelector(':scope > .tool-btn');
            const flyout = grp.querySelector('.tool-flyout');
            if (!face || !flyout) return;
            // Move flyout to body-level host
            flyoutHost.appendChild(flyout);
            flyout.style.pointerEvents = 'auto';
            flyout._parentGroup = grp;
            // Click toggles flyout
            face.addEventListener('click', e => {
                e.preventDefault(); e.stopPropagation();
                const wasOpen = flyout.classList.contains('show');
                this._closeAllFlyouts();
                if (!wasOpen) {
                    const rect = face.getBoundingClientRect();
                    flyout.style.position = 'fixed';
                    flyout.style.left = (rect.right + 4) + 'px';
                    flyout.style.top = rect.top + 'px';
                    flyout.classList.add('show');
                } else {
                    const tool = face.dataset.tool;
                    if (tool) this.setTool(tool);
                }
            });
            face.addEventListener('contextmenu', e => {
                e.preventDefault();
                this._closeAllFlyouts();
                const rect = face.getBoundingClientRect();
                flyout.style.position = 'fixed';
                flyout.style.left = (rect.right + 4) + 'px';
                flyout.style.top = rect.top + 'px';
                flyout.classList.add('show');
            });
            face.removeAttribute('onclick');
        });
        document.addEventListener('mousedown', e => {
            if (!e.target.closest('.tool-flyout') && !e.target.closest('.tool-group > .tool-btn')) {
                this._closeAllFlyouts();
            }
        });
    },
    switchTab(tabBtn, groupId, contentId) {
        // Deactivate all tabs in this group
        tabBtn.parentElement.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
        tabBtn.classList.add('active');
        // Show target content, hide siblings
        document.querySelectorAll('.panel-tab-content[data-group="' + groupId + '"]').forEach(c => c.classList.remove('active'));
        document.getElementById(contentId).classList.add('active');
    },
    _closeAllFlyouts() {
        document.querySelectorAll('.tool-flyout.show').forEach(f => f.classList.remove('show'));
    },
    flyoutSelect(btn, groupName) {
        const grp = document.querySelector(`.tool-group[data-group="${groupName}"]`);
        if (!grp) return;
        const face = grp.querySelector(':scope > .tool-btn');
        const tool = btn.dataset.tool;
        // Swap the face button icon + data
        face.innerHTML = btn.innerHTML;
        face.dataset.tool = tool;
        face.dataset.tip = btn.dataset.tip;
        // Close all flyouts and activate tool
        this._closeAllFlyouts();
        this.setTool(tool);
    },


    setTool(tool) {
        const prevTool = this.state.tool;
        this.state.tool = tool;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.toggle('active', b.dataset.tool===tool));
        document.querySelectorAll('#tool-options .opt-group').forEach(g => g.style.display='none');
        const c = this.canvas; c.isDrawingMode = false; c.selection = false;
        c.defaultCursor = 'crosshair'; c.hoverCursor = 'crosshair';
        c.forEachObject(o => { o.selectable=false; o.evented=false; });
        // NOTE: Pixel selections (marquee/wand/lasso) are intentionally
        // PRESERVED across tool switches, just like Photoshop.
        // They only clear on: Esc, Ctrl+D, Edit>Deselect, or new selection.
        // Only hide the lasso drawing overlay (not the marching-ants result):
        if (prevTool === 'lasso' && tool !== 'lasso') {
            // Lasso was active — if no selection was finalized, clear its points
            if (!this._selectionBounds) {
                document.getElementById('lasso-overlay').style.display='none';
                this._lassoPoints = [];
                document.querySelector('#lasso-overlay svg polygon').setAttribute('points', '');
            }
        }
        document.getElementById('pen-overlay').style.display='none';
        document.getElementById('measure-overlay').style.display='none';
        // Lasso cleanup handled above in selection persistence block
        this._penPoints = [];
        this.cancelCrop();
        switch(tool) {
            case 'select':
                c.selection=true; c.defaultCursor='default'; c.hoverCursor='move';
                c.forEachObject(o => { if(o.name!=='__boundary__'){o.selectable=true;o.evented=true;} });
                document.getElementById('opt-select').style.display='flex'; break;
            case 'brush': case 'pencil':
                c.isDrawingMode=true; c.freeDrawingBrush = new fabric.PencilBrush(c);
                c.freeDrawingBrush.color = this.state.fgColor;
                c.freeDrawingBrush.width = tool==='pencil'?1:this.state.brushSize;
                this.setBrushPreset(this.state.brushPreset);
                document.getElementById('opt-brush').style.display='flex'; break;
            case 'eraser':
                c.isDrawingMode=true; c.freeDrawingBrush = new fabric.PencilBrush(c);
                c.freeDrawingBrush.color = 'rgba(0,0,0,1)'; c.freeDrawingBrush.width = this.state.brushSize;
                document.getElementById('opt-brush').style.display='flex'; break;
            case 'spray':
                c.isDrawingMode=true; c.freeDrawingBrush = new fabric.SprayBrush(c);
                c.freeDrawingBrush.color = this.state.fgColor;
                c.freeDrawingBrush.density = this.state.sprayDensity;
                c.freeDrawingBrush.width = this.state.sprayWidth;
                document.getElementById('opt-spray').style.display='flex'; break;
            case 'clone': c.defaultCursor='crosshair'; document.getElementById('opt-clone').style.display='flex'; break;
            case 'healing': c.defaultCursor='crosshair'; document.getElementById('opt-healing').style.display='flex'; break;
            case 'dodge': c.defaultCursor='crosshair'; document.getElementById('opt-dodge').style.display='flex'; break;
            case 'burn': c.defaultCursor='crosshair'; document.getElementById('opt-burn').style.display='flex'; break;
            case 'sponge': c.defaultCursor='crosshair'; document.getElementById('opt-sponge').style.display='flex'; break;
            case 'smudge': c.defaultCursor='crosshair'; document.getElementById('opt-smudge').style.display='flex'; break;
            case 'line': case 'rect': case 'circle': case 'triangle': case 'arrow':
                document.getElementById('opt-shape').style.display='flex'; break;
            case 'polygon': document.getElementById('opt-polygon').style.display='flex'; break;
            case 'star': document.getElementById('opt-star').style.display='flex'; break;
            case 'pen': document.getElementById('opt-pen').style.display='flex'; document.getElementById('pen-overlay').style.display='block'; c.defaultCursor='crosshair'; break;
            case 'text': c.defaultCursor='text'; document.getElementById('opt-text').style.display='flex'; break;
            case 'gradient': document.getElementById('opt-gradient').style.display='flex'; break;
            case 'pattern': document.getElementById('opt-pattern').style.display='flex'; break;
            case 'fill': c.forEachObject(o => { if(o.name!=='__boundary__'){o.selectable=false;o.evented=true;} }); break;
            case 'eyedropper': c.defaultCursor='crosshair'; c.hoverCursor='crosshair';
                c.forEachObject(o => { if(o.name!=='__boundary__'){o.selectable=false;o.evented=true;} }); break;
            case 'pan': c.defaultCursor='grab'; break;
            case 'zoom': c.defaultCursor='zoom-in'; break;
            case 'marquee-rect': case 'marquee-ellipse': document.getElementById('opt-marquee').style.display='flex'; break;
            case 'magic-wand': document.getElementById('opt-wand').style.display='flex'; break;
            case 'lasso':
                document.getElementById('opt-lasso').style.display='flex';
                document.getElementById('lasso-overlay').style.display='block';
                // If there's no existing lasso selection, reset points for new lasso
                if (!this._selectionBounds) {
                    this._lassoPoints=[];
                    document.querySelector('#lasso-overlay svg polygon').setAttribute('points','');
                }
                break;
            case 'measure': document.getElementById('opt-measure').style.display='flex'; document.getElementById('measure-overlay').style.display='block'; break;
            case 'note': c.defaultCursor='crosshair'; c.hoverCursor='crosshair'; break;
            case 'crop': document.getElementById('opt-crop').style.display='flex'; this._initCrop(); break;
        }
        const toolNames = {'marquee-rect':'Rect Marquee','marquee-ellipse':'Ellipse Marquee','magic-wand':'Magic Wand'};
        document.getElementById('tool-display').textContent = toolNames[tool] || tool.charAt(0).toUpperCase()+tool.replace(/-/g,' ').slice(1);
    },
    setBrushSize(v) { this.state.brushSize=+v; document.getElementById('brush-size-val').textContent=v; if(this.canvas.freeDrawingBrush) this.canvas.freeDrawingBrush.width=+v; },
    setBrushOpacity(v) {
        this.state.brushOpacity=+v; document.getElementById('brush-opacity-val').textContent=v;
        this._applyBrushColor();
    },
    _hexToRgba(hex, opacity) {
        const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16);
        return 'rgba('+r+','+g+','+b+','+(opacity/100)+')';
    },
    _applyBrushColor() {
        if(!this.canvas.freeDrawingBrush) return;
        const hex=this.state.tool==='eraser'?'#000000':this.state.fgColor;
        this.canvas.freeDrawingBrush.color=this.state.brushOpacity<100?this._hexToRgba(hex,this.state.brushOpacity):hex;
    },
    setBrushPreset(preset) {
        this.state.brushPreset = preset;
        const c = this.canvas; if (!c.isDrawingMode) return;
        switch(preset) {
            case 'round': c.freeDrawingBrush = new fabric.PencilBrush(c); break;
            case 'soft':
                c.freeDrawingBrush = new fabric.PencilBrush(c);
                c.freeDrawingBrush.shadow = new fabric.Shadow({ blur:8, color:this.state.fgColor, affectStroke:true });
                break;
            case 'flat':
                c.freeDrawingBrush = new fabric.PencilBrush(c);
                c.freeDrawingBrush.strokeLineCap = 'butt';
                break;
            case 'scatter':
                c.freeDrawingBrush = new fabric.SprayBrush(c);
                c.freeDrawingBrush.density = 15; c.freeDrawingBrush.dotWidth = 2;
                break;
            case 'pixel':
                c.freeDrawingBrush = new fabric.PencilBrush(c);
                c.freeDrawingBrush.strokeLineCap = 'square';
                break;
        }
        c.freeDrawingBrush.color=this.state.tool==='eraser'?'rgba(0,0,0,1)':(this.state.brushOpacity<100?this._hexToRgba(this.state.fgColor,this.state.brushOpacity):this.state.fgColor);
        c.freeDrawingBrush.width = this.state.brushSize;
    },

    // ====================== MOUSE ======================
    onMouseDown(opt) {
        const ptr = this.canvas.getPointer(opt.e), tool = this.state.tool;
        if (tool==='pan' || this._tempPanning) { this.state.isPanning=true; this.state.panStart={x:opt.e.clientX,y:opt.e.clientY}; this.canvas.defaultCursor='grabbing'; return; }
        if (tool==='zoom') { opt.e.altKey?this.zoomOut():this.zoomIn(); return; }
        if (tool==='marquee-rect'||tool==='marquee-ellipse') {
            // Clear any previous selection (wand overlay, old bounds)
            this.canvas.getObjects().filter(o=>o._wandOverlay).forEach(o=>this.canvas.remove(o));
            this._selectionMask=null; this._selectionBounds=null;
            this._marqueeStart={x:opt.e.offsetX,y:opt.e.offsetY};
            const el=document.getElementById('selection-overlay');
            el.style.display='block'; el.style.left=opt.e.offsetX+'px'; el.style.top=opt.e.offsetY+'px'; el.style.width='0'; el.style.height='0';
            el.style.borderRadius = tool==='marquee-ellipse'?'50%':'0';
            this.state.isDrawing=true; return;
        }
        if (tool==='magic-wand') {
            // Clear previous marquee overlay when making new wand selection
            document.getElementById('selection-overlay').style.display='none';
            this._doMagicWand(ptr); return;
        }
        if (tool==='lasso') { this._lassoClick(opt.e); return; }
        if (tool==='pen') { this._penClick(ptr, opt.e); return; }
        if (tool==='note') { this.addStickyNote(opt.e); return; }
        if (['dodge','burn','sponge','smudge'].includes(tool)) { this._retouchStart(tool, ptr, opt.e); return; }
        if (tool==='healing') { this._healStart(ptr, opt.e); return; }
        if (tool==='measure') { this._measureClick(ptr, opt.e); return; }
        if (tool==='clone'&&opt.e.altKey) { this._cloneSource={x:ptr.x,y:ptr.y}; this._cloneOffset=null; this.toast('Clone source set','info'); return; }
        if (tool==='clone'&&this._cloneSource) { this._cloneStart(ptr, opt.e); return; }
        if (tool==='text') {
            const text = new fabric.IText('Type here', { left:ptr.x, top:ptr.y, fontFamily:this.state.textFont, fontSize:this.state.textSize, fill:this.state.textColor, editable:true, fontWeight:this.state.textBold?'bold':'normal', fontStyle:this.state.textItalic?'italic':'normal' });
            this.canvas.add(text); this.layers[this.activeLayerIdx].objects.push(text);
            this.canvas.setActiveObject(text); text.enterEditing(); this.saveHistory('Add Text'); this.updateLayersPanel(); return;
        }
        if (tool==='fill') {
            const t=opt.target;
            if(t&&t.type==='image') { this._floodFillImage(t,ptr); }
            else if(t&&t.name!=='__boundary__') { t.set('fill',this.state.fgColor); this.canvas.renderAll(); this.saveHistory('Fill'); }
            else { const rect=new fabric.Rect({left:0,top:0,width:this.canvasW,height:this.canvasH,fill:this.state.fgColor,selectable:true,name:'Fill'});
                this.canvas.add(rect);this.layers[this.activeLayerIdx].objects.push(rect);this.saveHistory('Fill Canvas');this.updateLayersPanel(); }
            return;
        }
        if (tool==='eyedropper') {
            const ctx=this.canvas.getContext('2d'), vpt=this.canvas.viewportTransform;
            const sx=ptr.x*vpt[0]+vpt[4], sy=ptr.y*vpt[3]+vpt[5];
            const px=ctx.getImageData(sx,sy,1,1).data;
            const hex='#'+[px[0],px[1],px[2]].map(c=>c.toString(16).padStart(2,'0')).join('');
            this.setFgColor(hex); this.toast(`Picked: ${hex}`,'info'); return;
        }
        if (tool==='gradient'||tool==='pattern') { this.state.isDrawing=true; this._shapeStart={x:ptr.x,y:ptr.y}; return; }
        if (['line','rect','circle','triangle','arrow','polygon','star'].includes(tool)) {
            this.state.isDrawing=true; this._shapeStart={x:ptr.x,y:ptr.y};
            const fill=this.state.shapeFilled?this.state.shapeFill:'transparent', sk=this.state.shapeStroke, sw=this.state.shapeStrokeWidth;
            const dashArr = this.state.shapeDash ? this.state.shapeDash.split(',').map(Number) : null;
            const dashOpts = dashArr ? {strokeDashArray: dashArr} : {};
            switch(tool) {
                case 'rect': this._tempShape=new fabric.Rect({left:ptr.x,top:ptr.y,width:0,height:0,fill,stroke:sk,strokeWidth:sw,selectable:false,...dashOpts}); break;
                case 'circle': this._tempShape=new fabric.Ellipse({left:ptr.x,top:ptr.y,rx:0,ry:0,fill,stroke:sk,strokeWidth:sw,selectable:false,...dashOpts}); break;
                case 'line': this._tempShape=new fabric.Line([ptr.x,ptr.y,ptr.x,ptr.y],{stroke:sk,strokeWidth:sw,selectable:false,...dashOpts}); break;
                case 'triangle': this._tempShape=new fabric.Triangle({left:ptr.x,top:ptr.y,width:0,height:0,fill,stroke:sk,strokeWidth:sw,selectable:false,...dashOpts}); break;
                case 'arrow': this._tempShape=new fabric.Line([ptr.x,ptr.y,ptr.x,ptr.y],{stroke:sk,strokeWidth:sw,selectable:false,_isArrow:true,...dashOpts}); break;
                case 'polygon': {
                    const sides=this.state.polySides||5;
                    this._tempShape=new fabric.Circle({left:ptr.x,top:ptr.y,radius:0,fill:'transparent',stroke:'transparent',selectable:false,_polyPlaceholder:true,_polySides:sides});
                    break;
                }
                case 'star': {
                    this._tempShape=new fabric.Circle({left:ptr.x,top:ptr.y,radius:0,fill:'transparent',stroke:'transparent',selectable:false,_starPlaceholder:true});
                    break;
                }
            }
            if(this._tempShape) this.canvas.add(this._tempShape);
        }
    },
    onMouseMove(opt) {
        const ptr=this.canvas.getPointer(opt.e);
        document.getElementById('cursor-pos').textContent=`X: ${Math.round(ptr.x)} Y: ${Math.round(ptr.y)}`;
        const ic=document.getElementById('info-cursor'); if(ic) ic.textContent=`${Math.round(ptr.x)}, ${Math.round(ptr.y)}`;
        if(this.state.isPanning&&this.state.panStart) {
            const dx=opt.e.clientX-this.state.panStart.x, dy=opt.e.clientY-this.state.panStart.y;
            const vpt=this.canvas.viewportTransform.slice(); vpt[4]+=dx; vpt[5]+=dy;
            this.canvas.setViewportTransform(vpt); this.state.panStart={x:opt.e.clientX,y:opt.e.clientY}; this.drawGrid(); this.drawRulers(); return;
        }
        if(this.state.isDrawing&&this._marqueeStart) {
            const el=document.getElementById('selection-overlay'), sx=this._marqueeStart.x, sy=this._marqueeStart.y, cx=opt.e.offsetX, cy=opt.e.offsetY;
            el.style.left=Math.min(sx,cx)+'px'; el.style.top=Math.min(sy,cy)+'px'; el.style.width=Math.abs(cx-sx)+'px'; el.style.height=Math.abs(cy-sy)+'px'; return;
        }
        if(this.state.tool==='clone'&&this._cloneOC&&(opt.e.buttons&1)) { this._cloneStroke(ptr); }
        if(['dodge','burn','sponge','smudge'].includes(this.state.tool)&&(opt.e.buttons&1)) { this._retouchStroke(this.state.tool, ptr); }
        if(this.state.tool==='healing'&&this._healOC&&(opt.e.buttons&1)) { this._healStroke(ptr); }
        if(this.state.isDrawing&&this._tempShape&&this._shapeStart) {
            const s=this._shapeStart, w=ptr.x-s.x, h=ptr.y-s.y;
            switch(this.state.tool) {
                case 'rect': this._tempShape.set({left:w<0?ptr.x:s.x,top:h<0?ptr.y:s.y,width:Math.abs(w),height:Math.abs(h)}); break;
                case 'circle': this._tempShape.set({left:w<0?ptr.x:s.x,top:h<0?ptr.y:s.y,rx:Math.abs(w)/2,ry:Math.abs(h)/2}); break;
                case 'line': case 'arrow': this._tempShape.set({x2:ptr.x,y2:ptr.y}); break;
                case 'triangle': this._tempShape.set({left:w<0?ptr.x:s.x,top:h<0?ptr.y:s.y,width:Math.abs(w),height:Math.abs(h)}); break;
                case 'polygon': case 'star': this._tempShape.set({radius:Math.sqrt(w*w+h*h)}); break;
            }
            this.canvas.renderAll();
        }
    },
    onMouseUp(opt) {
        if(this.state.isPanning){
            this.state.isPanning=false;
            if (this._tempPanning) { this.canvas.defaultCursor='grab'; }
            else if (this.state.tool==='pan') { this.canvas.defaultCursor='grab'; }
            else if (this.state.tool==='select') { this.canvas.defaultCursor='default'; }
            else { this.canvas.defaultCursor='crosshair'; }
            return;
        }
        if(this._marqueeStart){
            const el=document.getElementById('selection-overlay');
            const sw=parseFloat(el.style.width)||0,sh=parseFloat(el.style.height)||0;
            const vpt=this.canvas.viewportTransform;
            if(sw>2&&sh>2){
                this._selectionBounds={x:parseFloat(el.style.left)||0,y:parseFloat(el.style.top)||0,w:sw,h:sh};
                this._selectionMask=null;
                this.toast('Selection: '+Math.round(sw/vpt[0])+' x '+Math.round(sh/vpt[3])+' px','info');
            } else { el.style.display='none'; this._selectionBounds=null; }
            this._marqueeStart=null;this.state.isDrawing=false; return;
        }
        if(this.state.isDrawing&&this.state.tool==='gradient'&&this._shapeStart) {
            const ptr=this.canvas.getPointer(opt.e); this.drawGradient(this._shapeStart,ptr); this._shapeStart=null; this.state.isDrawing=false; return;
        }
        if(this.state.isDrawing&&this.state.tool==='pattern'&&this._shapeStart) {
            const ptr=this.canvas.getPointer(opt.e); this.drawPattern(this._shapeStart,ptr); this._shapeStart=null; this.state.isDrawing=false; return;
        }
        if(this.state.isDrawing&&this._tempShape) {
            // Replace placeholders with final shapes
            if (this._tempShape._isArrow) {
                const l = this._tempShape;
                const x1=l.x1,y1=l.y1,x2=l.x2,y2=l.y2;
                const angle=Math.atan2(y2-y1,x2-x1);
                const hl=12, ha=Math.PI/6;
                const head = new fabric.Polygon([
                    {x:x2,y:y2},
                    {x:x2-hl*Math.cos(angle-ha),y:y2-hl*Math.sin(angle-ha)},
                    {x:x2-hl*Math.cos(angle+ha),y:y2-hl*Math.sin(angle+ha)}
                ],{fill:l.stroke,stroke:l.stroke,strokeWidth:1,selectable:false});
                const grp = new fabric.Group([l, head],{selectable:true});
                this.canvas.remove(this._tempShape);
                this.canvas.add(grp);
                this.layers[this.activeLayerIdx].objects.push(grp);
            } else if (this._tempShape._polyPlaceholder) {
                const cx=this._tempShape.left, cy=this._tempShape.top, r=this._tempShape.radius||50;
                const sides=this._tempShape._polySides||5;
                const fill=this.state.shapeFilled?this.state.shapeFill:'transparent', sk=this.state.shapeStroke, sw=this.state.shapeStrokeWidth;
                const pts=[]; for(let i=0;i<sides;i++){const a=2*Math.PI*i/sides-Math.PI/2;pts.push({x:cx+r*Math.cos(a),y:cy+r*Math.sin(a)});}
                this.canvas.remove(this._tempShape);
                const poly=new fabric.Polygon(pts,{fill,stroke:sk,strokeWidth:sw,selectable:true});
                this.canvas.add(poly);
                this.layers[this.activeLayerIdx].objects.push(poly);
            } else if (this._tempShape._starPlaceholder) {
                const cx=this._tempShape.left, cy=this._tempShape.top, r=this._tempShape.radius||50;
                const pts_count=this.state.starPoints||5, innerR=r*(this.state.starInner||40)/100;
                const fill=this.state.shapeFilled?this.state.shapeFill:'transparent', sk=this.state.shapeStroke, sw=this.state.shapeStrokeWidth;
                const pts=[]; for(let i=0;i<pts_count*2;i++){const a=Math.PI*i/pts_count-Math.PI/2;const rad=i%2===0?r:innerR;pts.push({x:cx+rad*Math.cos(a),y:cy+rad*Math.sin(a)});}
                this.canvas.remove(this._tempShape);
                const star=new fabric.Polygon(pts,{fill,stroke:sk,strokeWidth:sw,selectable:true});
                this.canvas.add(star);
                this.layers[this.activeLayerIdx].objects.push(star);
            } else {
                this._tempShape.setCoords(); this._tempShape.selectable=true;
                this.layers[this.activeLayerIdx].objects.push(this._tempShape);
            }
            this.saveHistory('Draw '+this.state.tool); this.updateLayersPanel();
            this.updateHistogram();
            this._tempShape=null; this._shapeStart=null; this.state.isDrawing=false;
        }
    },
    onMouseWheel(opt) {
        opt.e.preventDefault(); let z=this.zoom*(0.999**opt.e.deltaY);
        z=Math.min(Math.max(0.05,z),20);
        this.canvas.zoomToPoint({x:opt.e.offsetX,y:opt.e.offsetY},z);
        this.zoom=z; document.getElementById('zoom-display').textContent=Math.round(z*100)+'%'; this.drawGrid(); this.drawRulers(); this._drawPixelGrid();
    },

    // ====================== CLONE STAMP ======================
    _cloneOC: null, _cloneSrcOC: null, _cloneTarget: null,
    _cloneStart(ptr, evt) {
        if (!this._cloneSource) { this.toast('Alt+click to set source first', 'info'); return; }
        if (!this._cloneOffset) this._cloneOffset = { x: ptr.x - this._cloneSource.x, y: ptr.y - this._cloneSource.y };
        let target = this.canvas.getActiveObject();
        if (!target || target.type !== 'image') {
            const objs = this.canvas.getObjects().filter(o => o.type === 'image' && o.containsPoint(ptr));
            target = objs.length ? objs[objs.length - 1] : null;
        }
        if (!target || target.type !== 'image') { this.toast('Click on an image to clone', 'info'); return; }
        const el = target.getElement();
        const oc = document.createElement('canvas');
        oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        oc.getContext('2d').drawImage(el, 0, 0);
        const srcOC = document.createElement('canvas');
        srcOC.width = oc.width; srcOC.height = oc.height;
        srcOC.getContext('2d').drawImage(el, 0, 0);
        this._cloneOC = oc; this._cloneSrcOC = srcOC; this._cloneTarget = target;
        this._cloneStroke(ptr);
        const commitFn = () => {
            document.removeEventListener('mouseup', commitFn);
            if (this._cloneOC && this._cloneTarget) {
                this._replaceActiveImage(this._cloneTarget, this._cloneOC.toDataURL(), 'Clone Stamp');
                this._cloneOC = null; this._cloneSrcOC = null; this._cloneTarget = null;
            }
        };
        document.addEventListener('mouseup', commitFn);
    },
    _cloneStroke(ptr) {
        if (!this._cloneOC || !this._cloneSrcOC || !this._cloneTarget) return;
        const oc = this._cloneOC, srcOC = this._cloneSrcOC, ctx = oc.getContext('2d'), srcCtx = srcOC.getContext('2d');
        const target = this._cloneTarget;
        const matrix = target.calcTransformMatrix();
        const inv = fabric.util.invertTransform(matrix);
        const localDst = fabric.util.transformPoint(ptr, inv);
        const dx = localDst.x + oc.width / 2, dy = localDst.y + oc.height / 2;
        const srcPt = { x: ptr.x - this._cloneOffset.x, y: ptr.y - this._cloneOffset.y };
        const localSrc = fabric.util.transformPoint(srcPt, inv);
        const sx = localSrc.x + oc.width / 2, sy = localSrc.y + oc.height / 2;
        const size = this.state.cloneSize, r = Math.ceil(size / 2);
        try {
            const x0s = Math.max(0, Math.floor(sx - r)), y0s = Math.max(0, Math.floor(sy - r));
            const x0d = Math.max(0, Math.floor(dx - r)), y0d = Math.max(0, Math.floor(dy - r));
            const rr = r * 2;
            const srcData = srcCtx.getImageData(x0s, y0s, rr, rr);
            const dstData = ctx.getImageData(x0d, y0d, rr, rr);
            const sd = srcData.data, dd = dstData.data, w = Math.min(srcData.width, dstData.width);
            const h = Math.min(srcData.height, dstData.height);
            for (let py = 0; py < h; py++) {
                for (let px = 0; px < w; px++) {
                    const dist = Math.sqrt((px - r) ** 2 + (py - r) ** 2);
                    if (dist > r) continue;
                    const blend = 1 - (dist / r);
                    const i = (py * srcData.width + px) * 4;
                    const j = (py * dstData.width + px) * 4;
                    if (i + 3 < sd.length && j + 3 < dd.length) {
                        for (let c = 0; c < 4; c++) dd[j+c] = Math.round(dd[j+c] * (1 - blend) + sd[i+c] * blend);
                    }
                }
            }
            ctx.putImageData(dstData, x0d, y0d);
            // Live preview
            const vpt = this.canvas.viewportTransform, canvasCtx = this.canvas.getContext('2d');
            const screenX = ptr.x * vpt[0] + vpt[4], screenY = ptr.y * vpt[3] + vpt[5];
            try { canvasCtx.putImageData(dstData, screenX - r, screenY - r); } catch(e2) {}
        } catch(e) {}
    },

    // ====================== MAGIC WAND ======================
    _selectionMask: null, _selectionBounds: null,
    _doMagicWand(ptr) {
        const vpt=this.canvas.viewportTransform, ctx=this.canvas.getContext('2d');
        const sx=Math.round(ptr.x*vpt[0]+vpt[4]), sy=Math.round(ptr.y*vpt[3]+vpt[5]);
        const cw=this.canvas.width, ch=this.canvas.height;
        const snap=ctx.getImageData(0,0,cw,ch); const data=snap.data;
        const idx=(sy*cw+sx)*4;
        if(idx<0||idx+3>=data.length) return;
        const tr=data[idx],tg=data[idx+1],tb=data[idx+2],tol=this.state.wandTolerance;
        const mask=new Uint8Array(cw*ch);
        let count=0,minX=cw,minY=ch,maxX=0,maxY=0;
        if(this.state.wandContiguous){
            const stack=[[sx,sy]];
            while(stack.length&&count<1000000){
                const[x,y]=stack.pop(); if(x<0||y<0||x>=cw||y>=ch)continue;
                const pi=y*cw+x; if(mask[pi])continue; const ii=pi*4;
                if(Math.abs(data[ii]-tr)<=tol&&Math.abs(data[ii+1]-tg)<=tol&&Math.abs(data[ii+2]-tb)<=tol){
                    mask[pi]=1;count++; if(x<minX)minX=x;if(x>maxX)maxX=x;if(y<minY)minY=y;if(y>maxY)maxY=y;
                    stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
                }
            }
        } else {
            for(let y=0;y<ch;y++) for(let x=0;x<cw;x++){
                const i=(y*cw+x)*4;
                if(Math.abs(data[i]-tr)<=tol&&Math.abs(data[i+1]-tg)<=tol&&Math.abs(data[i+2]-tb)<=tol){
                    mask[y*cw+x]=1;count++; if(x<minX)minX=x;if(x>maxX)maxX=x;if(y<minY)minY=y;if(y>maxY)maxY=y;
                }
            }
        }
        this._selectionMask={mask,w:cw,h:ch};
        this._selectionBounds=count>0?{x:minX,y:minY,w:maxX-minX+1,h:maxY-minY+1}:null;
        // Non-destructive overlay: paint tint on a SEPARATE overlay canvas
        const ov=document.createElement('canvas'); ov.width=cw; ov.height=ch;
        const ovCtx=ov.getContext('2d');
        const ovData=ovCtx.createImageData(cw,ch); const od=ovData.data;
        for(let i=0;i<mask.length;i++){ if(mask[i]){ od[i*4]=80;od[i*4+1]=140;od[i*4+2]=255;od[i*4+3]=60; }}
        ovCtx.putImageData(ovData,0,0);
        // Draw overlay as fabric image (removable, doesn't affect source)
        this.canvas.getObjects().filter(o=>o._wandOverlay).forEach(o=>this.canvas.remove(o));
        fabric.Image.fromURL(ov.toDataURL(),img=>{
            img.set({left:(0-vpt[4])/vpt[0],top:(0-vpt[5])/vpt[3],scaleX:1/vpt[0],scaleY:1/vpt[3],
                selectable:false,evented:false,_wandOverlay:true,excludeFromExport:true});
            this.canvas.add(img); this.canvas.renderAll();
        });
        // Marching ants on bounding box
        const el=document.getElementById('selection-overlay');
        if(count>0){el.style.display='block';el.style.left=minX+'px';el.style.top=minY+'px';
            el.style.width=(maxX-minX+1)+'px';el.style.height=(maxY-minY+1)+'px';el.style.borderRadius='0';}
        else el.style.display='none';
        this.toast('Selected '+count.toLocaleString()+' px','info');
    },
    clearSelection(){
        this._storeLastSelection();
        this._selectionMask=null; this._selectionBounds=null;
        const selOv = document.getElementById('selection-overlay');
        if (selOv) selOv.style.display='none';
        const lassoOv = document.getElementById('lasso-overlay');
        if (lassoOv) { lassoOv.style.display='none'; }
        this._lassoPoints = [];
        const lassoPoly = document.querySelector('#lasso-overlay svg polygon');
        if (lassoPoly) lassoPoly.setAttribute('points', '');
        this.canvas.getObjects().filter(o=>o._wandOverlay).forEach(o=>this.canvas.remove(o));
        this.canvas.renderAll();
    },

    // ====================== SELECTION OPERATIONS ======================
    _lastSelection: null, // For Reselect

    // Store current selection before clearing (for Reselect)
    _storeLastSelection() {
        if (this._selectionMask || this._selectionBounds) {
            this._lastSelection = {
                mask: this._selectionMask ? { mask: new Uint8Array(this._selectionMask.mask), w: this._selectionMask.w, h: this._selectionMask.h } : null,
                bounds: this._selectionBounds ? { ...this._selectionBounds } : null
            };
        }
    },

    // Reselect: restore last cleared selection
    reselectSelection() {
        if (!this._lastSelection) { this.toast('No previous selection to restore', 'info'); return; }
        this._selectionMask = this._lastSelection.mask;
        this._selectionBounds = this._lastSelection.bounds;
        if (this._selectionBounds) {
            const el = document.getElementById('selection-overlay');
            el.style.display = 'block';
            el.style.left = this._selectionBounds.x + 'px';
            el.style.top = this._selectionBounds.y + 'px';
            el.style.width = this._selectionBounds.w + 'px';
            el.style.height = this._selectionBounds.h + 'px';
            el.style.borderRadius = '0';
        }
        if (this._selectionMask) this._showMaskOverlay(this._selectionMask);
        this.toast('Selection restored', 'info');
    },

    // Inverse selection: flip the mask
    invertSelection() {
        if (!this._selectionMask) {
            // If we have a marquee but no mask, create mask from canvas bounds
            const vpt = this.canvas.viewportTransform;
            const cw = this.canvas.width, ch = this.canvas.height;
            const mask = new Uint8Array(cw * ch);
            if (this._selectionBounds) {
                const b = this._selectionBounds;
                for (let y = 0; y < ch; y++) for (let x = 0; x < cw; x++) {
                    if (x >= b.x && x < b.x + b.w && y >= b.y && y < b.y + b.h) mask[y * cw + x] = 1;
                }
                this._selectionMask = { mask, w: cw, h: ch };
            } else {
                this.toast('No selection to invert', 'info');
                return;
            }
        }
        const m = this._selectionMask;
        let minX = m.w, minY = m.h, maxX = 0, maxY = 0, count = 0;
        for (let i = 0; i < m.mask.length; i++) {
            m.mask[i] = m.mask[i] ? 0 : 1;
            if (m.mask[i]) {
                const x = i % m.w, y = Math.floor(i / m.w);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
                count++;
            }
        }
        this._selectionBounds = count > 0 ? { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 } : null;
        const el = document.getElementById('selection-overlay');
        if (this._selectionBounds) {
            el.style.display = 'block';
            el.style.left = minX + 'px'; el.style.top = minY + 'px';
            el.style.width = (maxX - minX + 1) + 'px'; el.style.height = (maxY - minY + 1) + 'px';
        } else { el.style.display = 'none'; }
        this._showMaskOverlay(this._selectionMask);
        this.toast('Selection inverted: ' + count.toLocaleString() + ' px', 'info');
    },

    // Grow: expand selection to include adjacent similar pixels
    growSelection() {
        if (!this._selectionMask) { this.toast('No pixel selection to grow', 'info'); return; }
        const m = this._selectionMask;
        const ctx = this.canvas.getContext('2d');
        const snap = ctx.getImageData(0, 0, m.w, m.h);
        const data = snap.data;
        const tol = this.state.wandTolerance || 32;
        const newMask = new Uint8Array(m.mask);
        // Find edge pixels and try to expand
        for (let y = 0; y < m.h; y++) for (let x = 0; x < m.w; x++) {
            if (!m.mask[y * m.w + x]) continue;
            // Check 4-neighbors
            const neighbors = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
            const ci = (y * m.w + x) * 4;
            for (const [nx, ny] of neighbors) {
                if (nx < 0 || ny < 0 || nx >= m.w || ny >= m.h) continue;
                if (newMask[ny * m.w + nx]) continue;
                const ni = (ny * m.w + nx) * 4;
                if (Math.abs(data[ni] - data[ci]) <= tol &&
                    Math.abs(data[ni+1] - data[ci+1]) <= tol &&
                    Math.abs(data[ni+2] - data[ci+2]) <= tol) {
                    newMask[ny * m.w + nx] = 1;
                }
            }
        }
        m.mask = newMask;
        this._recalcSelectionBounds(m);
        this._showMaskOverlay(m);
        this.toast('Selection grown', 'info');
    },

    // Similar: select all pixels with similar color to current selection
    similarSelection() {
        if (!this._selectionMask) { this.toast('No pixel selection', 'info'); return; }
        const m = this._selectionMask;
        const ctx = this.canvas.getContext('2d');
        const snap = ctx.getImageData(0, 0, m.w, m.h);
        const data = snap.data;
        const tol = this.state.wandTolerance || 32;
        // Collect average color of selected pixels
        let tr = 0, tg = 0, tb = 0, cnt = 0;
        for (let i = 0; i < m.mask.length; i++) {
            if (m.mask[i]) { tr += data[i*4]; tg += data[i*4+1]; tb += data[i*4+2]; cnt++; }
        }
        if (cnt === 0) return;
        tr = Math.round(tr / cnt); tg = Math.round(tg / cnt); tb = Math.round(tb / cnt);
        // Select all pixels matching average color
        let count = 0;
        for (let i = 0; i < m.mask.length; i++) {
            if (Math.abs(data[i*4] - tr) <= tol && Math.abs(data[i*4+1] - tg) <= tol && Math.abs(data[i*4+2] - tb) <= tol) {
                m.mask[i] = 1; count++;
            }
        }
        this._recalcSelectionBounds(m);
        this._showMaskOverlay(m);
        this.toast('Selected similar: ' + count.toLocaleString() + ' px', 'info');
    },

    // Modify selection (expand, contract, feather, border, smooth)
    modifySelection(type) {
        if (!this._selectionMask && !this._selectionBounds) { this.toast('No selection to modify', 'info'); return; }
        if (type === 'smooth') {
            this._doModifySelection('smooth', 1);
            return;
        }
        const labels = { expand: 'Expand', contract: 'Contract', feather: 'Feather', border: 'Border' };
        const defaults = { expand: 2, contract: 2, feather: 3, border: 2 };
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>${labels[type]} Selection</h3>
            <div class="modal-row"><label>Pixels</label><input id="mod-sel-px" type="number" value="${defaults[type]}" min="1" max="100"></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS._doModifySelection('${type}',+document.getElementById('mod-sel-px').value);this.closest('.modal-overlay').remove()">OK</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    _doModifySelection(type, px) {
        // Ensure we have a pixel mask
        if (!this._selectionMask && this._selectionBounds) {
            const cw = this.canvas.width, ch = this.canvas.height;
            const mask = new Uint8Array(cw * ch);
            const b = this._selectionBounds;
            for (let y = 0; y < ch; y++) for (let x = 0; x < cw; x++) {
                if (x >= b.x && x < b.x + b.w && y >= b.y && y < b.y + b.h) mask[y * cw + x] = 1;
            }
            this._selectionMask = { mask, w: cw, h: ch };
        }
        if (!this._selectionMask) return;
        const m = this._selectionMask;
        const w = m.w, h = m.h;
        const newMask = new Uint8Array(w * h);
        switch (type) {
            case 'expand':
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (m.mask[y * w + x]) {
                        for (let dy = -px; dy <= px; dy++) for (let dx = -px; dx <= px; dx++) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && ny >= 0 && nx < w && ny < h && dx*dx + dy*dy <= px*px) newMask[ny * w + nx] = 1;
                        }
                    }
                }
                break;
            case 'contract':
                // A pixel stays selected only if all neighbors within px are selected
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (!m.mask[y * w + x]) continue;
                    let keep = true;
                    for (let dy = -px; dy <= px && keep; dy++) for (let dx = -px; dx <= px && keep; dx++) {
                        if (dx*dx + dy*dy > px*px) continue;
                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || ny < 0 || nx >= w || ny >= h || !m.mask[ny * w + nx]) keep = false;
                    }
                    if (keep) newMask[y * w + x] = 1;
                }
                break;
            case 'feather':
                // Copy original then we'll use soft edges (gaussian-ish blur on mask)
                newMask.set(m.mask);
                // Simple box blur approach on binary mask → creates gradient edges
                // Apply multiple passes for smoother feather
                const passes = Math.min(px, 10);
                const tempA = new Float32Array(w * h);
                const tempB = new Float32Array(w * h);
                for (let i = 0; i < w * h; i++) tempA[i] = m.mask[i];
                for (let p = 0; p < passes; p++) {
                    for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                        let sum = 0, cnt = 0;
                        for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && ny >= 0 && nx < w && ny < h) { sum += tempA[ny * w + nx]; cnt++; }
                        }
                        tempB[y * w + x] = sum / cnt;
                    }
                    tempA.set(tempB);
                }
                for (let i = 0; i < w * h; i++) newMask[i] = tempA[i] > 0.01 ? 1 : 0;
                break;
            case 'border':
                // Select only the border pixels (edge of current selection)
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (!m.mask[y * w + x]) continue;
                    let isEdge = false;
                    for (let dy = -px; dy <= px && !isEdge; dy++) for (let dx = -px; dx <= px && !isEdge; dx++) {
                        if (dx*dx + dy*dy > px*px) continue;
                        const nx = x + dx, ny = y + dy;
                        if (nx < 0 || ny < 0 || nx >= w || ny >= h || !m.mask[ny * w + nx]) isEdge = true;
                    }
                    if (isEdge) newMask[y * w + x] = 1;
                }
                break;
            case 'smooth':
                // 3x3 majority vote smoothing
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    let sum = 0;
                    for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && ny >= 0 && nx < w && ny < h) sum += m.mask[ny * w + nx];
                    }
                    newMask[y * w + x] = sum >= 5 ? 1 : 0;
                }
                break;
        }
        m.mask = newMask;
        this._recalcSelectionBounds(m);
        this._showMaskOverlay(m);
        this.toast('Selection ' + type + (type === 'smooth' ? 'ed' : 'ed by ' + px + 'px'), 'info');
    },

    // Recalculate bounding box from mask
    _recalcSelectionBounds(m) {
        let minX = m.w, minY = m.h, maxX = 0, maxY = 0, count = 0;
        for (let y = 0; y < m.h; y++) for (let x = 0; x < m.w; x++) {
            if (m.mask[y * m.w + x]) {
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
                count++;
            }
        }
        this._selectionBounds = count > 0 ? { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 } : null;
        const el = document.getElementById('selection-overlay');
        if (this._selectionBounds) {
            el.style.display = 'block';
            el.style.left = minX + 'px'; el.style.top = minY + 'px';
            el.style.width = (maxX - minX + 1) + 'px'; el.style.height = (maxY - minY + 1) + 'px';
            el.style.borderRadius = '0';
        } else { el.style.display = 'none'; }
    },

    // Show blue tint overlay for pixel mask
    _showMaskOverlay(m) {
        const vpt = this.canvas.viewportTransform;
        const ov = document.createElement('canvas'); ov.width = m.w; ov.height = m.h;
        const ovCtx = ov.getContext('2d');
        const ovData = ovCtx.createImageData(m.w, m.h); const od = ovData.data;
        for (let i = 0; i < m.mask.length; i++) {
            if (m.mask[i]) { od[i*4] = 80; od[i*4+1] = 140; od[i*4+2] = 255; od[i*4+3] = 50; }
        }
        ovCtx.putImageData(ovData, 0, 0);
        this.canvas.getObjects().filter(o => o._wandOverlay).forEach(o => this.canvas.remove(o));
        fabric.Image.fromURL(ov.toDataURL(), img => {
            img.set({ left: (0 - vpt[4]) / vpt[0], top: (0 - vpt[5]) / vpt[3], scaleX: 1 / vpt[0], scaleY: 1 / vpt[3],
                selectable: false, evented: false, _wandOverlay: true, excludeFromExport: true });
            this.canvas.add(img); this.canvas.renderAll();
        });
    },

    // ====================== COLOR RANGE ======================
    showColorRange() {
        const ctx = this.canvas.getContext('2d');
        const cw = this.canvas.width, ch = this.canvas.height;
        const snap = ctx.getImageData(0, 0, cw, ch);
        this._crSnap = snap;
        this._crSamples = []; // Array of {r,g,b}
        this._crMode = 'add'; // add, sub
        this._crFuzz = 80;
        this._crInvert = false;

        const o = document.createElement('div'); o.className = 'modal-overlay'; o.id = 'cr-overlay';
        o.innerHTML = `<div class="modal" style="min-width:auto;max-width:600px;padding:16px">
            <h3 style="margin-bottom:12px">Color Range</h3>
            <div class="cr-dialog">
                <div class="cr-left">
                    <div class="cr-select-row">
                        <label>Select:</label>
                        <select id="cr-mode-select" onchange="OS._crModeChange(this.value)">
                            <option value="sampled" selected>Sampled Colors</option>
                            <option value="reds">Reds</option>
                            <option value="yellows">Yellows</option>
                            <option value="greens">Greens</option>
                            <option value="cyans">Cyans</option>
                            <option value="blues">Blues</option>
                            <option value="magentas">Magentas</option>
                            <option value="highlights">Highlights</option>
                            <option value="midtones">Midtones</option>
                            <option value="shadows">Shadows</option>
                        </select>
                    </div>
                    <div class="cr-fuzz-row">
                        <label>Fuzziness:</label>
                        <input type="range" id="cr-fuzz" min="0" max="200" value="80" oninput="document.getElementById('cr-fuzz-num').value=this.value;OS._crUpdate()">
                        <input type="number" id="cr-fuzz-num" min="0" max="200" value="80" onchange="document.getElementById('cr-fuzz').value=this.value;OS._crUpdate()">
                    </div>
                    <div class="cr-preview" id="cr-preview-box">
                        <canvas id="cr-preview-canvas"></canvas>
                    </div>
                    <div class="cr-preview-mode">
                        <label><input type="radio" name="cr-prev" value="selection" checked onchange="OS._crUpdate()"> Selection</label>
                        <label><input type="radio" name="cr-prev" value="image" onchange="OS._crUpdate()"> Image</label>
                    </div>
                </div>
                <div class="cr-right">
                    <button class="btn btn-primary" onclick="OS._crApply()">OK</button>
                    <button class="btn" onclick="document.getElementById('cr-overlay').remove()">Cancel</button>
                    <div style="height:8px"></div>
                    <div class="cr-eyedroppers">
                        <button class="cr-eyedrop-btn active" id="cr-eye-add" onclick="OS._crMode='add';document.querySelectorAll('.cr-eyedrop-btn').forEach(b=>b.classList.remove('active'));this.classList.add('active')" title="Add to sample">+</button>
                        <button class="cr-eyedrop-btn" id="cr-eye-sub" onclick="OS._crMode='sub';document.querySelectorAll('.cr-eyedrop-btn').forEach(b=>b.classList.remove('active'));this.classList.add('active')" title="Subtract from sample">-</button>
                    </div>
                    <div style="height:4px"></div>
                    <div class="cr-invert-row">
                        <input type="checkbox" id="cr-invert" onchange="OS._crInvert=this.checked;OS._crUpdate()">
                        <label for="cr-invert">Invert</label>
                    </div>
                </div>
            </div>
        </div>`;
        document.body.appendChild(o);
        requestAnimationFrame(() => o.classList.add('show'));

        // Set up preview canvas click handler
        const previewBox = document.getElementById('cr-preview-box');
        const previewCanvas = document.getElementById('cr-preview-canvas');
        previewCanvas.width = cw; previewCanvas.height = ch;
        // Draw the image into the preview
        const pCtx = previewCanvas.getContext('2d');
        pCtx.putImageData(snap, 0, 0);

        previewBox.addEventListener('click', (e) => {
            const rect = previewCanvas.getBoundingClientRect();
            const scaleX = cw / rect.width, scaleY = ch / rect.height;
            const px = Math.round((e.clientX - rect.left) * scaleX);
            const py = Math.round((e.clientY - rect.top) * scaleY);
            if (px < 0 || py < 0 || px >= cw || py >= ch) return;
            const idx = (py * cw + px) * 4;
            const r = snap.data[idx], g = snap.data[idx+1], b = snap.data[idx+2];
            if (this._crMode === 'sub') {
                // Remove closest matching sample
                let bestIdx = -1, bestDist = Infinity;
                this._crSamples.forEach((s, i) => {
                    const d = Math.abs(s.r - r) + Math.abs(s.g - g) + Math.abs(s.b - b);
                    if (d < bestDist) { bestDist = d; bestIdx = i; }
                });
                if (bestIdx >= 0) this._crSamples.splice(bestIdx, 1);
            } else {
                this._crSamples.push({ r, g, b });
            }
            // Force to sampled mode
            document.getElementById('cr-mode-select').value = 'sampled';
            this._crUpdate();
        });

        this._crUpdate();
    },

    _crModeChange(mode) {
        if (mode !== 'sampled') {
            this._crSamples = []; // Clear manual samples for preset modes
        }
        this._crUpdate();
    },

    _crUpdate() {
        const snap = this._crSnap;
        if (!snap) return;
        const cw = snap.width, ch = snap.height, data = snap.data;
        const fuzz = +document.getElementById('cr-fuzz').value;
        this._crFuzz = fuzz;
        const mode = document.getElementById('cr-mode-select').value;
        const previewMode = document.querySelector('input[name="cr-prev"]:checked').value;
        const mask = new Uint8Array(cw * ch);

        if (mode === 'sampled') {
            if (this._crSamples.length === 0) {
                // No samples — show blank
            } else {
                for (let i = 0; i < cw * ch; i++) {
                    const r = data[i*4], g = data[i*4+1], b = data[i*4+2];
                    for (const s of this._crSamples) {
                        const dist = Math.abs(r - s.r) + Math.abs(g - s.g) + Math.abs(b - s.b);
                        if (dist <= fuzz * 3) { mask[i] = 1; break; }
                    }
                }
            }
        } else {
            // Preset color ranges
            for (let i = 0; i < cw * ch; i++) {
                const r = data[i*4], g = data[i*4+1], b = data[i*4+2];
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                let match = false;
                switch (mode) {
                    case 'reds': match = r > g + fuzz/3 && r > b + fuzz/3; break;
                    case 'yellows': match = r > fuzz && g > fuzz && b < 255 - fuzz; break;
                    case 'greens': match = g > r + fuzz/3 && g > b + fuzz/3; break;
                    case 'cyans': match = g > fuzz && b > fuzz && r < 255 - fuzz; break;
                    case 'blues': match = b > r + fuzz/3 && b > g + fuzz/3; break;
                    case 'magentas': match = r > fuzz && b > fuzz && g < 255 - fuzz; break;
                    case 'highlights': match = lum > 255 - fuzz; break;
                    case 'midtones': match = lum > fuzz && lum < 255 - fuzz; break;
                    case 'shadows': match = lum < fuzz; break;
                }
                if (match) mask[i] = 1;
            }
        }

        // Apply invert
        if (this._crInvert) {
            for (let i = 0; i < mask.length; i++) mask[i] = mask[i] ? 0 : 1;
        }

        this._crMask = mask;

        // Render preview
        const canvas = document.getElementById('cr-preview-canvas');
        const pCtx = canvas.getContext('2d');
        const out = pCtx.createImageData(cw, ch);
        const od = out.data;

        if (previewMode === 'selection') {
            // Black/white mask preview (like Photoshop)
            for (let i = 0; i < cw * ch; i++) {
                const v = mask[i] ? 255 : 0;
                od[i*4] = v; od[i*4+1] = v; od[i*4+2] = v; od[i*4+3] = 255;
            }
        } else {
            // Image with non-selected areas dimmed
            for (let i = 0; i < cw * ch; i++) {
                const mul = mask[i] ? 1 : 0.2;
                od[i*4] = data[i*4] * mul;
                od[i*4+1] = data[i*4+1] * mul;
                od[i*4+2] = data[i*4+2] * mul;
                od[i*4+3] = 255;
            }
        }
        pCtx.putImageData(out, 0, 0);
    },

    _crApply() {
        if (!this._crMask) { document.getElementById('cr-overlay').remove(); return; }
        const mask = this._crMask;
        const cw = this._crSnap.width, ch = this._crSnap.height;
        // Set as active selection
        this._selectionMask = { mask, w: cw, h: ch };
        this._recalcSelectionBounds(this._selectionMask);
        this._showMaskOverlay(this._selectionMask);

        let count = 0;
        for (let i = 0; i < mask.length; i++) if (mask[i]) count++;
        this.toast('Color Range: ' + count.toLocaleString() + ' px selected', 'success');

        document.getElementById('cr-overlay').remove();
        this._crSnap = null; this._crMask = null; this._crSamples = [];
    },
    // Convert screen-space selection bounds to canvas coordinates
    _selToCanvasCoords() {
        if (!this._selectionBounds) return null;
        const b = this._selectionBounds;
        // For magic wand, bounds are already in screen-canvas pixel space
        if (this._selectionMask) return { x: b.x, y: b.y, w: b.w, h: b.h };
        // For marquee, bounds are in canvas-area div offset space — convert via viewport
        const vpt = this.canvas.viewportTransform;
        return {
            x: (b.x - vpt[4]) / vpt[0],
            y: (b.y - vpt[5]) / vpt[3],
            w: b.w / vpt[0],
            h: b.h / vpt[3]
        };
    },

    // ====================== GRADIENT ======================
    drawGradient(from, to) {
        const w=Math.abs(to.x-from.x)||100, h=Math.abs(to.y-from.y)||100;
        const left=Math.min(from.x,to.x), top=Math.min(from.y,to.y);
        let grad;
        if(this.state.gradType==='linear') {
            grad = new fabric.Gradient({ type:'linear', coords:{x1:0,y1:0,x2:w,y2:h}, colorStops:[{offset:0,color:this.state.gradFrom},{offset:1,color:this.state.gradTo}] });
        } else {
            grad = new fabric.Gradient({ type:'radial', coords:{x1:w/2,y1:h/2,r1:0,x2:w/2,y2:h/2,r2:Math.max(w,h)/2}, colorStops:[{offset:0,color:this.state.gradFrom},{offset:1,color:this.state.gradTo}] });
        }
        const rect = new fabric.Rect({left,top,width:w,height:h,fill:grad,selectable:true,stroke:'transparent',strokeWidth:0});
        this.canvas.add(rect); this.layers[this.activeLayerIdx].objects.push(rect);
        this.saveHistory('Gradient'); this.updateLayersPanel();
    },

    // ====================== PATTERN FILL ======================
    drawPattern(from, to) {
        const w=Math.abs(to.x-from.x)||100, h=Math.abs(to.y-from.y)||100;
        const left=Math.min(from.x,to.x), top=Math.min(from.y,to.y);
        const pc=document.createElement('canvas'), s=this.state.patternScale;
        pc.width=s*2; pc.height=s*2;
        const pctx=pc.getContext('2d');
        pctx.fillStyle='#ffffff'; pctx.fillRect(0,0,s*2,s*2);
        pctx.fillStyle=this.state.patternColor;
        switch(this.state.patternType) {
            case 'checkerboard': pctx.fillRect(0,0,s,s); pctx.fillRect(s,s,s,s); break;
            case 'stripes': pctx.fillRect(0,0,s,s*2); break;
            case 'dots':
                pctx.beginPath(); pctx.arc(s/2,s/2,s/4,0,Math.PI*2); pctx.arc(s*1.5,s*1.5,s/4,0,Math.PI*2); pctx.fill(); break;
            case 'grid': pctx.fillRect(0,0,2,s*2); pctx.fillRect(0,0,s*2,2); pctx.fillRect(s,0,2,s*2); pctx.fillRect(0,s,s*2,2); break;
            case 'diagonal':
                pctx.strokeStyle=this.state.patternColor; pctx.lineWidth=2;
                pctx.beginPath(); pctx.moveTo(0,0); pctx.lineTo(s*2,s*2); pctx.moveTo(s*2,0); pctx.lineTo(0,s*2); pctx.stroke(); break;
            case 'crosshatch':
                pctx.strokeStyle=this.state.patternColor; pctx.lineWidth=1;
                for(let i=-s*2;i<s*4;i+=s/2){ pctx.beginPath(); pctx.moveTo(i,0); pctx.lineTo(i+s*2,s*2); pctx.moveTo(i,0); pctx.lineTo(i-s*2,s*2); pctx.stroke(); } break;
        }
        const pattern = new fabric.Pattern({ source:pc, repeat:'repeat' });
        const rect = new fabric.Rect({ left, top, width:w, height:h, fill:pattern, selectable:true, stroke:'transparent', strokeWidth:0 });
        this.canvas.add(rect); this.layers[this.activeLayerIdx].objects.push(rect);
        this.saveHistory('Pattern Fill'); this.updateLayersPanel();
    },

    // ====================== CROP ======================
    _cropRatio: null,
    _cropListeners: null,
    setCropRatio(val) {
        if (val === 'free') { this._cropRatio = null; }
        else if (val === 'original') { this._cropRatio = [this.canvasW, this.canvasH]; }
        else if (val === 'custom') { this._cropRatio = null; }
        else { const [w,h] = val.split(':').map(Number); this._cropRatio = [w,h]; }
        if (this._cropRegion && this._cropRatio) this._enforceCropRatio();
        this._updateCropVisuals();
    },
    swapCropRatio() {
        if (this._cropRatio) this._cropRatio = [this._cropRatio[1], this._cropRatio[0]];
        if (this._cropRegion) {
            const r = this._cropRegion, tmp = r.w; r.w = r.h; r.h = tmp;
            if (this._cropRatio) this._enforceCropRatio();
        }
        this._updateCropVisuals();
    },
    setCropSize() {
        const wVal = +document.getElementById('crop-w').value;
        const hVal = +document.getElementById('crop-h').value;
        if (!this._cropRegion || !wVal || !hVal) return;
        const vpt = this.canvas.viewportTransform;
        this._cropRegion.w = wVal * vpt[0]; this._cropRegion.h = hVal * vpt[3];
        this._updateCropVisuals();
    },
    _enforceCropRatio() {
        if (!this._cropRatio || !this._cropRegion) return;
        const r = this._cropRegion, ratio = this._cropRatio[0] / this._cropRatio[1];
        if (r.w / r.h > ratio) r.w = r.h * ratio; else r.h = r.w / ratio;
    },
    _initCrop() {
        this._cleanupCrop();
        const vpt = this.canvas.viewportTransform;
        const bx = vpt[4], by = vpt[5], bw = this.canvasW * vpt[0], bh = this.canvasH * vpt[3];
        const pad = 20;
        this._cropRegion = { x: bx + pad, y: by + pad, w: bw - pad*2, h: bh - pad*2 };
        if (this._cropRatio) this._enforceCropRatio();
        // Build DOM ONCE
        const container = document.getElementById('crop-container');
        const area = document.getElementById('canvas-area');
        container.style.display = 'block';
        container.innerHTML = `
            <div class="crop-dim" id="cdim-l"></div>
            <div class="crop-dim" id="cdim-r"></div>
            <div class="crop-dim" id="cdim-t"></div>
            <div class="crop-dim" id="cdim-b"></div>
            <div class="crop-box" id="crop-box">
                <div class="crop-grid-line h" style="top:33.33%"></div>
                <div class="crop-grid-line h" style="top:66.66%"></div>
                <div class="crop-grid-line v" style="left:33.33%"></div>
                <div class="crop-grid-line v" style="left:66.66%"></div>
                <div class="crop-handle nw" data-dir="nw"></div>
                <div class="crop-handle ne" data-dir="ne"></div>
                <div class="crop-handle sw" data-dir="sw"></div>
                <div class="crop-handle se" data-dir="se"></div>
                <div class="crop-handle n" data-dir="n"></div>
                <div class="crop-handle s" data-dir="s"></div>
                <div class="crop-handle w" data-dir="w"></div>
                <div class="crop-handle e" data-dir="e"></div>
                <div class="crop-size-label" id="crop-lbl"></div>
            </div>`;
        this._updateCropVisuals();
        // Event handling - persistent across drags
        const self = this;
        let mode = null, sx = 0, sy = 0, origR = null;
        const onDown = function(e) {
            const h = e.target.closest('.crop-handle');
            if (h) mode = h.dataset.dir;
            else if (e.target.closest('#crop-box')) mode = 'move';
            else return;
            sx = e.clientX; sy = e.clientY;
            origR = { x: self._cropRegion.x, y: self._cropRegion.y, w: self._cropRegion.w, h: self._cropRegion.h };
            e.preventDefault(); e.stopPropagation();
        };
        const onMove = function(e) {
            if (!mode || !origR) return;
            const dx = e.clientX - sx, dy = e.clientY - sy;
            const rr = self._cropRegion;
            if (mode === 'move') {
                rr.x = Math.max(0, origR.x + dx);
                rr.y = Math.max(0, origR.y + dy);
            } else {
                rr.x = origR.x; rr.y = origR.y; rr.w = origR.w; rr.h = origR.h;
                if (mode.includes('w')) { rr.x = origR.x + dx; rr.w = origR.w - dx; }
                if (mode.includes('e')) { rr.w = origR.w + dx; }
                if (mode.includes('n')) { rr.y = origR.y + dy; rr.h = origR.h - dy; }
                if (mode.includes('s')) { rr.h = origR.h + dy; }
                if (rr.w < 20) { rr.w = 20; if (mode.includes('w')) rr.x = origR.x + origR.w - 20; }
                if (rr.h < 20) { rr.h = 20; if (mode.includes('n')) rr.y = origR.y + origR.h - 20; }
                if (self._cropRatio) {
                    const ratio = self._cropRatio[0] / self._cropRatio[1];
                    if (mode === 'n' || mode === 's') rr.w = rr.h * ratio;
                    else if (mode === 'w' || mode === 'e') rr.h = rr.w / ratio;
                    else { if (Math.abs(dx) > Math.abs(dy)) rr.h = rr.w / ratio; else rr.w = rr.h * ratio; }
                }
            }
            self._updateCropVisuals();
        };
        const onUp = function() { mode = null; origR = null; };
        container.addEventListener('mousedown', onDown);
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        this._cropListeners = { down: onDown, move: onMove, up: onUp, el: container };
    },
    _updateCropVisuals() {
        const r = this._cropRegion; if (!r) return;
        const area = document.getElementById('canvas-area');
        if (!area) return;
        const ah = area.clientHeight;
        const vpt = this.canvas.viewportTransform;
        const dl = document.getElementById('cdim-l'), dr = document.getElementById('cdim-r');
        const dt = document.getElementById('cdim-t'), db = document.getElementById('cdim-b');
        const box = document.getElementById('crop-box'), lbl = document.getElementById('crop-lbl');
        if (!dl || !box) return;
        dl.style.cssText = 'top:0;left:0;width:'+r.x+'px;height:'+ah+'px';
        dr.style.cssText = 'top:0;left:'+(r.x+r.w)+'px;right:0;height:'+ah+'px';
        dt.style.cssText = 'top:0;left:'+r.x+'px;width:'+r.w+'px;height:'+r.y+'px';
        db.style.cssText = 'top:'+(r.y+r.h)+'px;left:'+r.x+'px;width:'+r.w+'px;bottom:0';
        box.style.left = r.x+'px'; box.style.top = r.y+'px'; box.style.width = r.w+'px'; box.style.height = r.h+'px';
        const cw = Math.round(r.w / vpt[0]), ch = Math.round(r.h / vpt[3]);
        if (lbl) lbl.textContent = cw+' x '+ch;
        const wEl = document.getElementById('crop-w'), hEl = document.getElementById('crop-h');
        if (wEl) wEl.value = cw; if (hEl) hEl.value = ch;
    },
    _cleanupCrop() {
        if (this._cropListeners) {
            if (this._cropListeners.el) this._cropListeners.el.removeEventListener('mousedown', this._cropListeners.down);
            document.removeEventListener('mousemove', this._cropListeners.move);
            document.removeEventListener('mouseup', this._cropListeners.up);
            this._cropListeners = null;
        }
    },
    applyCrop() {
        if(!this._cropRegion) return;
        const r=this._cropRegion, vpt=this.canvas.viewportTransform;
        const cx=(r.x-vpt[4])/vpt[0], cy=(r.y-vpt[5])/vpt[3];
        const cw=r.w/vpt[0], ch=r.h/vpt[3];
        if (cw < 1 || ch < 1) { this.toast('Crop region too small','error'); return; }
        const tempVpt=this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform=[1,0,0,1,0,0]; this.canvas.renderAll();
        const dataUrl=this.canvas.toDataURL({ left:cx, top:cy, width:cw, height:ch });
        this.canvas.viewportTransform=tempVpt;
        this.createNewDocument(Math.round(cw), Math.round(ch));
        fabric.Image.fromURL(dataUrl, img => {
            img.set({left:0,top:0,selectable:true,name:'Cropped'});
            this.canvas.add(img); this.layers[this.activeLayerIdx].objects.push(img);
            this.canvas.renderAll(); this.zoomFit(); this.saveHistory('Crop'); this.updateLayersPanel();
            this.toast('Cropped to '+Math.round(cw)+' x '+Math.round(ch), 'success');
        });
        this.cancelCrop();
    },
    cancelCrop() {
        this._cleanupCrop();
        const c = document.getElementById('crop-container');
        c.style.display='none'; c.innerHTML=''; this._cropRegion=null;
    },

    // ====================== AI BACKGROUND REMOVAL ======================
    removeBackground() { this.aiRemoveBackground(); },

    // ====================== ADJUSTMENTS ======================
    liveAdjust() {
        clearTimeout(this._adjDebounce);
        this._adjDebounce = setTimeout(() => {
            const b=+document.getElementById('adj-bright').value, c=+document.getElementById('adj-contrast').value;
            const s=+document.getElementById('adj-sat').value, h=+document.getElementById('adj-hue').value;
            const bl=+document.getElementById('adj-blur').value;
            document.getElementById('adj-bright-val').textContent=b; document.getElementById('adj-contrast-val').textContent=c;
            document.getElementById('adj-sat-val').textContent=s; document.getElementById('adj-hue-val').textContent=h;
            document.getElementById('adj-blur-val').textContent=bl;
            const active=this.canvas.getActiveObject();
            if(!active||active.type!=='image') {
                this.toast('Select an image to adjust', 'info');
                return;
            }
            active.filters=[];
            if(b!==0) active.filters.push(new fabric.Image.filters.Brightness({brightness:b/250}));
            if(c!==0) active.filters.push(new fabric.Image.filters.Contrast({contrast:c/250}));
            if(s!==0) active.filters.push(new fabric.Image.filters.Saturation({saturation:s/100}));
            if(h!==0) active.filters.push(new fabric.Image.filters.HueRotation({rotation:h/180}));
            if(bl>0) active.filters.push(new fabric.Image.filters.Blur({blur:bl/250}));
            active.applyFilters(); this.canvas.renderAll();
        }, 80);
    },
    applyAdjustments() { this.saveHistory('Adjustments Applied'); this.toast('Adjustments applied','success'); },
    resetAdjustments() {
        ['adj-bright','adj-contrast','adj-sat','adj-hue','adj-blur'].forEach(id => { document.getElementById(id).value=0; document.getElementById(id+'-val').textContent='0'; });
        const active=this.canvas.getActiveObject();
        if(active&&active.type==='image'){ active.filters=[]; active.applyFilters(); this.canvas.renderAll(); }
    },

    // ====================== FILTERS ======================
    showFilterDialog(name) {
        const active=this.canvas.getActiveObject();
        if(!active||active.type!=='image') { this.toast('Select an image first','info'); return; }
        const params = {
            Blur:[{label:'Amount',id:'fp-blur',min:0,max:100,val:0}],
            Brightness:[{label:'Brightness',id:'fp-bright',min:-100,max:100,val:0}],
            Contrast:[{label:'Contrast',id:'fp-cont',min:-100,max:100,val:0}],
            Saturation:[{label:'Saturation',id:'fp-sat',min:-100,max:100,val:0}],
            HueRotation:[{label:'Rotation',id:'fp-hue',min:-180,max:180,val:0}],
            Pixelate:[{label:'Block Size',id:'fp-pix',min:2,max:40,val:4}],
            Noise:[{label:'Noise',id:'fp-noise',min:0,max:500,val:0}],
            Gamma:[{label:'Red',id:'fp-gr',min:1,max:300,val:100},{label:'Green',id:'fp-gg',min:1,max:300,val:100},{label:'Blue',id:'fp-gb',min:1,max:300,val:100}],
        };
        const p=params[name]||[]; if(!p.length) return;
        this._filterBackup = active.filters.map(f => f.toObject ? f.toObject() : f);
        this._filterBackupRaw = active.filters.slice();
        this._filterTarget = active;
        this._filterName = name;
        const rows=p.map(r=>`<div class="modal-row"><label>${r.label}</label><input id="${r.id}" type="range" min="${r.min}" max="${r.max}" value="${r.val}" oninput="OS._filterPreview('${name}')"><span class="opt-val" style="min-width:32px">${r.val}</span></div>`).join('');
        this._openFilterPanel('filter-dialog-overlay', 'Filter: '+name, rows,
            ()=>this._filterCancel(), ()=>this._filterApply());
    },
    _openFilterPanel(id, title, bodyHTML, onCancel, onApply) {
        // Remove any existing filter panel
        const existing = document.getElementById(id);
        if (existing) existing.remove();
        const panel = document.createElement('div');
        panel.className = 'filter-panel';
        panel.id = id;
        panel.innerHTML = `<div class="filter-panel-header"><h3>${title}</h3><button class="fp-close" title="Cancel">&times;</button></div>
            <div class="filter-panel-body">${bodyHTML}</div>
            <div class="filter-panel-footer"><button class="btn" data-fp-cancel>Cancel</button><button class="btn btn-primary" data-fp-apply>Apply</button></div>`;
        document.body.appendChild(panel);
        // Position: top-right of canvas area
        const ca = document.getElementById('canvas-area');
        if (ca) {
            const r = ca.getBoundingClientRect();
            panel.style.top = (r.top + 12) + 'px';
            panel.style.right = (window.innerWidth - r.right + 12) + 'px';
        } else {
            panel.style.top = '80px'; panel.style.right = '280px';
        }
        requestAnimationFrame(() => panel.classList.add('show'));
        // Cancel/Apply
        panel.querySelector('[data-fp-cancel]').addEventListener('click', () => { if(onCancel) onCancel(); });
        panel.querySelector('.fp-close').addEventListener('click', () => { if(onCancel) onCancel(); });
        panel.querySelector('[data-fp-apply]').addEventListener('click', () => { if(onApply) onApply(); });
        // Draggable
        this._makePanelDraggable(panel);
        return panel;
    },
    _makePanelDraggable(panel) {
        const header = panel.querySelector('.filter-panel-header');
        if (!header) return;
        let dragging = false, ox = 0, oy = 0;
        header.addEventListener('mousedown', e => {
            if (e.target.closest('.fp-close')) return;
            dragging = true;
            const rect = panel.getBoundingClientRect();
            ox = e.clientX - rect.left; oy = e.clientY - rect.top;
            panel.style.right = 'auto'; // switch to left positioning for drag
            panel.style.left = rect.left + 'px';
            panel.style.top = rect.top + 'px';
            e.preventDefault();
        });
        document.addEventListener('mousemove', e => {
            if (!dragging) return;
            panel.style.left = (e.clientX - ox) + 'px';
            panel.style.top = (e.clientY - oy) + 'px';
        });
        document.addEventListener('mouseup', () => { dragging = false; });
    },
    _removeFilterPanel(id) {
        const panel = document.getElementById(id);
        if (panel) { panel.classList.remove('show'); setTimeout(() => panel.remove(), 150); }
    },
    _filterPreview(name) {
        clearTimeout(this._filterPreviewDebounce);
        this._filterPreviewDebounce = setTimeout(() => {
            const active = this._filterTarget;
            if (!active || active.type !== 'image') return;
            const panel = document.getElementById('filter-dialog-overlay');
            if (!panel) return;
            // Build filter from current slider values
            let f;
            switch(name) {
                case 'Blur': f=new fabric.Image.filters.Blur({blur:+(panel.querySelector('#fp-blur')?.value||0)/250}); break;
                case 'Brightness': f=new fabric.Image.filters.Brightness({brightness:+(panel.querySelector('#fp-bright')?.value||0)/250}); break;
                case 'Contrast': f=new fabric.Image.filters.Contrast({contrast:+(panel.querySelector('#fp-cont')?.value||0)/250}); break;
                case 'Saturation': f=new fabric.Image.filters.Saturation({saturation:+(panel.querySelector('#fp-sat')?.value||0)/100}); break;
                case 'HueRotation': f=new fabric.Image.filters.HueRotation({rotation:+(panel.querySelector('#fp-hue')?.value||0)/180}); break;
                case 'Pixelate': f=new fabric.Image.filters.Pixelate({blocksize:+(panel.querySelector('#fp-pix')?.value||4)}); break;
                case 'Noise': f=new fabric.Image.filters.Noise({noise:+(panel.querySelector('#fp-noise')?.value||0)}); break;
                case 'Gamma': { const r=+(panel.querySelector('#fp-gr')?.value||100)/100,g=+(panel.querySelector('#fp-gg')?.value||100)/100,b=+(panel.querySelector('#fp-gb')?.value||100)/100; f=new fabric.Image.filters.Gamma({gamma:[r,g,b]}); break; }
            }
            // Update value labels
            panel.querySelectorAll('input[type="range"]').forEach(inp => {
                const span = inp.nextElementSibling;
                if (span) span.textContent = inp.value;
            });
            if (f) {
                // Restore original filters + append preview filter
                active.filters = this._filterBackupRaw.slice();
                active.filters.push(f);
                active.applyFilters();
                this.canvas.renderAll();
            }
        }, 50);
    },
    _filterCancel() {
        const active = this._filterTarget;
        if (active && active.type === 'image') {
            active.filters = this._filterBackupRaw || [];
            active.applyFilters();
            this.canvas.renderAll();
        }
        this._removeFilterPanel('filter-dialog-overlay');
        this._filterBackup = null; this._filterBackupRaw = null; this._filterTarget = null;
    },
    _filterApply() {
        const name = this._filterName || 'Applied';
        this.saveHistory('Filter: ' + name);
        this.toast(`Applied ${name}`, 'success');
        this._lastFilter = name;
        this._removeFilterPanel('filter-dialog-overlay');
        this._filterBackup = null; this._filterBackupRaw = null; this._filterTarget = null;
    },
    applyFilterDirect(name) {
        const active=this.canvas.getActiveObject();
        if(!active||active.type!=='image') { this.toast('Select an image','info'); return; }
        let f;
        switch(name) {
            case 'Grayscale': f=new fabric.Image.filters.Grayscale(); break;
            case 'Invert': f=new fabric.Image.filters.Invert(); break;
            case 'Sepia': f=new fabric.Image.filters.Sepia(); break;
            case 'BlackWhite': f=new fabric.Image.filters.BlackWhite(); break;
            case 'Sharpen': f=new fabric.Image.filters.Convolute({matrix:[0,-1,0,-1,5,-1,0,-1,0]}); break;
            case 'Emboss': f=new fabric.Image.filters.Convolute({matrix:[-2,-1,0,-1,1,1,0,1,2]}); break;
        }
        if(f){ active.filters.push(f); active.applyFilters(); this.canvas.renderAll(); this.saveHistory('Filter: '+name); this.toast(`Applied ${name}`,'success'); this._lastFilter = name; }
    },
    clearFilters() {
        const active=this.canvas.getActiveObject();
        if(!active||active.type!=='image') { this.toast('Select an image','info'); return; }
        active.filters=[]; active.applyFilters(); this.canvas.renderAll(); this.saveHistory('Clear Filters'); this.toast('Filters cleared','success');
    },

    // ====================== COPY / PASTE ======================
    copyObj() { this._copySelection(); },
    pasteObj() { this._pasteSelection(); },

    // ====================== HISTORY ======================
    saveHistory(action) {
        if(this.historyIdx<this.history.length-1) this.history=this.history.slice(0,this.historyIdx+1);
        const snap=JSON.stringify(this.canvas.toJSON(['name','excludeFromExport','globalCompositeOperation']));
        this.history.push({action,snapshot:snap});
        if(this.history.length>this.maxHistory) this.history.shift();
        this.historyIdx=this.history.length-1; this.updateHistoryPanel(); this.updateStatus();
        this.recordMacroStep(action);
        this.updateHistogram();
    },
    undo() { if(this.historyIdx<=0){ this.toast('Nothing to undo','info'); return; } this.historyIdx--; this._restoreHistory(); },
    redo() { if(this.historyIdx>=this.history.length-1){ this.toast('Nothing to redo','info'); return; } this.historyIdx++; this._restoreHistory(); },
    _restoreHistory() {
        const e=this.history[this.historyIdx];
        this.canvas.loadFromJSON(JSON.parse(e.snapshot), () => {
            this.canvas.renderAll(); this.rebuildLayersFromCanvas();
            this.setTool(this.state.tool); this.updateHistoryPanel(); this.updateStatus();
        });
    },
    updateHistoryPanel() {
        const list=document.getElementById('history-list'); list.innerHTML='';
        this.history.forEach((e,i)=>{
            const d=document.createElement('div');
            d.className='history-item'+(i===this.historyIdx?' current':'')+(i>this.historyIdx?' future':'');
            d.textContent=e.action; d.addEventListener('click',()=>{this.historyIdx=i;this._restoreHistory();});
            list.appendChild(d);
        });
        list.scrollTop=list.scrollHeight;
    },

    // ====================== ZOOM ======================
    zoomIn() { this.zoom=Math.min(this.zoom*1.25,20); this.canvas.zoomToPoint({x:this.canvas.width/2,y:this.canvas.height/2},this.zoom); document.getElementById('zoom-display').textContent=Math.round(this.zoom*100)+'%'; this.drawGrid(); this.drawRulers(); },
    zoomOut() { this.zoom=Math.max(this.zoom/1.25,0.05); this.canvas.zoomToPoint({x:this.canvas.width/2,y:this.canvas.height/2},this.zoom); document.getElementById('zoom-display').textContent=Math.round(this.zoom*100)+'%'; this.drawGrid(); this.drawRulers(); },
    zoomFit() {
        const a=document.getElementById('canvas-area'), pad=40;
        this.zoom=Math.min((a.clientWidth-pad*2)/this.canvasW,(a.clientHeight-pad*2)/this.canvasH,1);
        this.canvas.setViewportTransform([1,0,0,1,0,0]); this.canvas.zoomToPoint({x:0,y:0},this.zoom);
        const vpt=this.canvas.viewportTransform;
        vpt[4]=(a.clientWidth-this.canvasW*this.zoom)/2; vpt[5]=(a.clientHeight-this.canvasH*this.zoom)/2;
        this.canvas.setViewportTransform(vpt); document.getElementById('zoom-display').textContent=Math.round(this.zoom*100)+'%'; this.drawGrid(); this.drawRulers();
    },
    zoomReset() {
        this.zoom=1; const a=document.getElementById('canvas-area');
        this.canvas.setViewportTransform([1,0,0,1,0,0]); this.canvas.zoomToPoint({x:0,y:0},1);
        const vpt=this.canvas.viewportTransform; vpt[4]=(a.clientWidth-this.canvasW)/2; vpt[5]=(a.clientHeight-this.canvasH)/2;
        this.canvas.setViewportTransform(vpt); document.getElementById('zoom-display').textContent='100%'; this.drawGrid(); this.drawRulers();
    },
    resizeCanvas() { const a=document.getElementById('canvas-area'); this.canvas.setWidth(a.clientWidth); this.canvas.setHeight(a.clientHeight); this.canvas.renderAll(); },
    zoomActual() { this.zoomReset(); },
    _layerViaCopy() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Select an object first', 'info'); return; }
        active.clone(c => {
            const idx = this.layers.length;
            this.layers.push({ name: 'Layer ' + idx + ' (copy)', visible: true, locked: false, opacity: 100, blend: 'source-over', objects: [c] });
            this.canvas.add(c); this.activeLayerIdx = idx;
            this.canvas.setActiveObject(c); this.canvas.renderAll();
            this.saveHistory('Layer Via Copy'); this.updateLayersPanel();
            this.toast('Layer via copy', 'success');
        });
    },
    _layerViaCut() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Select an object first', 'info'); return; }
        active.clone(c => {
            // Remove from current layer
            const curLayer = this.layers[this.activeLayerIdx];
            const oi = curLayer ? curLayer.objects.indexOf(active) : -1;
            if (oi >= 0) curLayer.objects.splice(oi, 1);
            this.canvas.remove(active);
            // Add to new layer
            const idx = this.layers.length;
            this.layers.push({ name: 'Layer ' + idx + ' (cut)', visible: true, locked: false, opacity: 100, blend: 'source-over', objects: [c] });
            this.canvas.add(c); this.activeLayerIdx = idx;
            this.canvas.setActiveObject(c); this.canvas.renderAll();
            this.saveHistory('Layer Via Cut'); this.updateLayersPanel();
            this.toast('Layer via cut', 'success');
        });
    },
    _lastFilter: null,
    _reapplyLastFilter() {
        if (!this._lastFilter) { this.toast('No filter to reapply', 'info'); return; }
        // Try to apply as direct filter first
        const directFilters = ['Grayscale', 'Invert', 'Sepia', 'BlackWhite', 'Sharpen', 'Emboss'];
        if (directFilters.includes(this._lastFilter)) {
            this.applyFilterDirect(this._lastFilter);
        } else {
            this.showFilterDialog(this._lastFilter);
        }
    },

    // ====================== EDIT OPS ======================
    deleteSelected() { this._deleteSelected(); },
    duplicateSelected() {
        const active=this.canvas.getActiveObject(); if(!active) return;
        active.clone(c=>{ c.set({left:active.left+15,top:active.top+15}); this.canvas.add(c); this.layers[this.activeLayerIdx].objects.push(c); this.canvas.setActiveObject(c); this.canvas.renderAll(); this.saveHistory('Duplicate'); this.updateLayersPanel(); });
    },
    flipH() { const a=this.canvas.getActiveObject(); if(a){a.set('flipX',!a.flipX);this.canvas.renderAll();this.saveHistory('Flip H');} else{this.toast('Select an object first','info');} },
    flipV() { const a=this.canvas.getActiveObject(); if(a){a.set('flipY',!a.flipY);this.canvas.renderAll();this.saveHistory('Flip V');} else{this.toast('Select an object first','info');} },
    rotateObj(deg) { const a=this.canvas.getActiveObject(); if(a){a.rotate((a.angle||0)+deg);this.canvas.renderAll();this.saveHistory('Rotate '+deg);} else{this.toast('Select an object first','info');} },
    showResize() {
        const o=document.createElement('div'); o.className='modal-overlay';
        o.innerHTML=`<div class="modal"><h3>Resize Canvas</h3><div class="modal-row"><label>Width</label><input id="rs-w" type="number" value="${this.canvasW}" min="1" max="8000"></div><div class="modal-row"><label>Height</label><input id="rs-h" type="number" value="${this.canvasH}" min="1" max="8000"></div><div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button><button class="btn btn-primary" onclick="OS.doResize(this.closest('.modal-overlay'))">Apply</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(()=>o.classList.add('show'));
    },
    doResize(o) {
        const w=+o.querySelector('#rs-w').value||this.canvasW, h=+o.querySelector('#rs-h').value||this.canvasH;
        const bd=this.canvas.getObjects().find(x=>x.name==='__boundary__'); if(bd) bd.set({width:w,height:h});
        this.canvasW=w; this.canvasH=h; this.canvas.renderAll(); this.zoomFit();
        document.getElementById('canvas-dims').textContent=`${w} x ${h}`; this.saveHistory('Resize'); o.remove(); this.toast(`Resized to ${w}x${h}`,'success');
    },

    // ====================== COLORS ======================
    setFgColor(hex) {
        this.state.fgColor=hex; document.getElementById('fg-color').style.background=hex;
        document.getElementById('fg-picker').value=hex; document.getElementById('fg-hex').textContent=hex.toUpperCase();
        if(this.canvas.freeDrawingBrush&&this.state.tool!=='eraser'){this.canvas.freeDrawingBrush.color=this.state.brushOpacity<100?this._hexToRgba(hex,this.state.brushOpacity):hex;}
    },
    setBgColor(hex) { this.state.bgColor=hex; document.getElementById('bg-color').style.background=hex; document.getElementById('bg-picker').value=hex; document.getElementById('bg-hex').textContent=hex.toUpperCase(); },
    swapColors() { const fg=this.state.fgColor,bg=this.state.bgColor; this.setFgColor(bg); this.setBgColor(fg); },
    initSwatches() {
        const colors=['#000000','#333333','#666666','#999999','#cccccc','#ffffff','#ff0000','#ff6600','#ffcc00','#33cc33','#0099ff','#6633ff','#ff3399','#cc0000','#cc6600','#999900','#009933','#006699','#330099','#cc0066','#ff9999','#ffcc99','#ffff99','#99ff99','#99ccff','#cc99ff','#ff99cc','#6c8cff'];
        const el=document.getElementById('color-swatches');
        colors.forEach(c=>{ const d=document.createElement('div'); d.className='color-swatch'; d.style.background=c; d.addEventListener('click',()=>this.setFgColor(c)); d.addEventListener('contextmenu',e=>{e.preventDefault();this.setBgColor(c);}); el.appendChild(d); });
    },

    // ====================== PDF EXPORT ======================
    exportPDF() {
        if (typeof jspdf === 'undefined' && typeof window.jspdf === 'undefined') { this.toast('jsPDF not loaded', 'error'); return; }
        const { jsPDF } = window.jspdf;
        const landscape = this.canvasW > this.canvasH;
        const pdf = new jsPDF({ orientation: landscape ? 'landscape' : 'portrait', unit: 'px', format: [this.canvasW, this.canvasH] });
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
        const dataUrl = this.canvas.toDataURL({ format: 'png', left: 0, top: 0, width: this.canvasW, height: this.canvasH });
        this.canvas.viewportTransform = vpt; this.canvas.renderAll();
        pdf.addImage(dataUrl, 'PNG', 0, 0, this.canvasW, this.canvasH);
        pdf.save('openshop-export.pdf');
        this.toast('Exported as PDF', 'success');
    },

    // ====================== WELCOME SCREEN ======================
    dismissWelcome() {
        const el = document.getElementById('welcome-overlay');
        el.classList.add('hidden');
        setTimeout(() => el.style.display = 'none', 400);
        this.toast('OpenShop v0.18.0 ready', 'info');
        // Capture initial state for before/after
        setTimeout(() => this._captureBA(), 500);
        // Phase 8
        this.initCmdPalette();
        this.initContextMenu();
        this.initToolGroups();
        this.initDropzone();
        this.initClipboardPaste();
        this.initMinimap();
        this.initDefaultPalette();
        this.loadSavedPalette();
        this._initKeyboardShortcuts();
        setInterval(() => this.updateMinimap(), 2000);
    },
    populateTemplates() {
        const grid = document.getElementById('template-grid');
        if (!grid) return;
        grid.innerHTML = '';
        this.templates.forEach(t => {
            const card = document.createElement('div');
            card.className = 'template-card';
            card.innerHTML = `<div class="tpl-preview" style="background:linear-gradient(135deg,var(--bg-depth-3),var(--bg-depth-4))">${t.icon}</div><div class="tpl-name">${t.name}</div><div class="tpl-dims">${t.w} x ${t.h}</div>`;
            card.addEventListener('click', () => {
                this.dismissWelcome();
                this.createNewDocument(t.w, t.h);
                this.toast(`Created: ${t.name}`, 'success');
            });
            grid.appendChild(card);
        });
    },
    showTemplates() {
        const o = document.createElement('div'); o.className = 'modal-overlay';
        let cats = {}; this.templates.forEach(t => { if(!cats[t.cat]) cats[t.cat]=[]; cats[t.cat].push(t); });
        let html = '<div class="modal" style="min-width:500px;max-width:620px"><h3>Templates</h3>';
        for (const [cat, tpls] of Object.entries(cats)) {
            html += `<div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;letter-spacing:.5px;margin:12px 0 6px">${cat}</div><div class="template-grid">`;
            tpls.forEach((t,i) => {
                html += `<div class="template-card" onclick="OS.createNewDocument(${t.w},${t.h});this.closest('.modal-overlay').remove();OS.toast('Created: ${t.name}','success')"><div class="tpl-preview">${t.icon}</div><div class="tpl-name">${t.name}</div><div class="tpl-dims">${t.w}x${t.h}</div></div>`;
            });
            html += '</div>';
        }
        html += '<div class="modal-btns"><button class="btn" onclick="this.closest(\'.modal-overlay\').remove()">Close</button></div></div>';
        o.innerHTML = html;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },

    // ====================== RECENT FILES ======================
    populateRecentFiles() {
        const area = document.getElementById('recent-files-area');
        if (!area) return;
        let recent = [];
        try { recent = JSON.parse(localStorage.getItem('openshop_recent') || '[]'); } catch(e){}
        if (!recent.length) { area.innerHTML = ''; return; }
        area.innerHTML = '<h3>Recent</h3>' + recent.slice(0, 5).map(r =>
            `<div class="recent-item"><span>${r.name}</span><span class="ri-date">${r.dims} &middot; ${r.date}</span></div>`
        ).join('');
    },
    trackRecentFile(name, w, h) {
        let recent = [];
        try { recent = JSON.parse(localStorage.getItem('openshop_recent') || '[]'); } catch(e){}
        recent.unshift({ name, dims: `${w}x${h}`, date: new Date().toLocaleDateString() });
        if (recent.length > 10) recent = recent.slice(0, 10);
        try { localStorage.setItem('openshop_recent', JSON.stringify(recent)); } catch(e){}
    },

    // ====================== GRID ======================
    toggleGrid() {
        this.gridVisible = !this.gridVisible;
        document.getElementById('grid-overlay').classList.toggle('visible', this.gridVisible);
        if (this.gridVisible) this.drawGrid();
        this.toast(this.gridVisible ? 'Grid on' : 'Grid off', 'info');
    },
    drawGrid() {
        if (!this.gridVisible) return;
        const area = document.getElementById('canvas-area');
        const gc = document.getElementById('grid-overlay');
        gc.width = area.clientWidth; gc.height = area.clientHeight;
        const ctx = gc.getContext('2d');
        ctx.clearRect(0, 0, gc.width, gc.height);
        const vpt = this.canvas.viewportTransform;
        const g = this.gridSize * vpt[0]; // grid size in screen pixels
        if (g < 4) return; // too dense
        const offX = vpt[4] % g, offY = vpt[5] % g;
        ctx.strokeStyle = 'rgba(108,140,255,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = offX; x < gc.width; x += g) { ctx.moveTo(x, 0); ctx.lineTo(x, gc.height); }
        for (let y = offY; y < gc.height; y += g) { ctx.moveTo(0, y); ctx.lineTo(gc.width, y); }
        ctx.stroke();
        // Major gridlines every 5
        const mg = g * 5;
        if (mg > 20) {
            const mOffX = vpt[4] % mg, mOffY = vpt[5] % mg;
            ctx.strokeStyle = 'rgba(108,140,255,0.25)';
            ctx.beginPath();
            for (let x = mOffX; x < gc.width; x += mg) { ctx.moveTo(x, 0); ctx.lineTo(x, gc.height); }
            for (let y = mOffY; y < gc.height; y += mg) { ctx.moveTo(0, y); ctx.lineTo(gc.width, y); }
            ctx.stroke();
        }
    },

    // ====================== RULERS ======================
    toggleRulers() {
        this.rulersVisible = !this.rulersVisible;
        document.getElementById('ruler-h').classList.toggle('visible', this.rulersVisible);
        document.getElementById('ruler-v').classList.toggle('visible', this.rulersVisible);
        document.body.classList.toggle('rulers-on', this.rulersVisible);
        if (this.rulersVisible) this.drawRulers();
        this.resizeCanvas();
        this.toast(this.rulersVisible ? 'Rulers on' : 'Rulers off', 'info');
    },
    drawRulers() {
        if (!this.rulersVisible) return;
        const vpt = this.canvas.viewportTransform;
        const z = vpt[0];
        // Horizontal ruler
        const hc = document.getElementById('ruler-h-canvas');
        const area = document.getElementById('canvas-area');
        hc.width = area.clientWidth + 64; hc.height = 20;
        const hctx = hc.getContext('2d');
        hctx.fillStyle = '#161b24'; hctx.fillRect(0, 0, hc.width, hc.height);
        hctx.fillStyle = '#5a6480'; hctx.font = '9px JetBrains Mono';
        hctx.strokeStyle = '#2a3142'; hctx.lineWidth = 1;
        const step = this._rulerStep(z);
        const startX = -Math.ceil(vpt[4] / (step * z)) * step;
        for (let v = startX; v < startX + hc.width / z + step; v += step) {
            const sx = v * z + vpt[4];
            if (sx < -10 || sx > hc.width + 10) continue;
            hctx.beginPath(); hctx.moveTo(sx, 14); hctx.lineTo(sx, 20); hctx.stroke();
            hctx.fillText(Math.round(v), sx + 2, 11);
        }
        // Vertical ruler
        const vc = document.getElementById('ruler-v-canvas');
        vc.width = 20; vc.height = area.clientHeight + 64;
        const vctx = vc.getContext('2d');
        vctx.fillStyle = '#161b24'; vctx.fillRect(0, 0, vc.width, vc.height);
        vctx.fillStyle = '#5a6480'; vctx.font = '9px JetBrains Mono';
        vctx.strokeStyle = '#2a3142'; vctx.lineWidth = 1;
        const startY = -Math.ceil(vpt[5] / (step * z)) * step;
        for (let v = startY; v < startY + vc.height / z + step; v += step) {
            const sy = v * z + vpt[5];
            if (sy < -10 || sy > vc.height + 10) continue;
            vctx.beginPath(); vctx.moveTo(14, sy); vctx.lineTo(20, sy); vctx.stroke();
            vctx.save(); vctx.translate(10, sy + 2); vctx.rotate(-Math.PI / 2); vctx.fillText(Math.round(v), 0, 0); vctx.restore();
        }
    },
    _rulerStep(z) {
        const steps = [1,2,5,10,20,50,100,200,500,1000,2000,5000];
        const minPx = 50;
        for (const s of steps) { if (s * z >= minPx) return s; }
        return 5000;
    },

    // ====================== SNAP ======================
    toggleSnap() {
        this.snapEnabled = !this.snapEnabled;
        this.toast(this.snapEnabled ? `Snap on (${this.gridSize}px grid)` : 'Snap off', 'info');
    },

    // ====================== FULLSCREEN ======================
    toggleFullscreen() {
        document.body.classList.toggle('fullscreen');
        const fs = document.body.classList.contains('fullscreen');
        this.resizeCanvas();
        this.toast(fs ? 'Fullscreen (click View > Fullscreen to exit)' : 'Normal view', 'info');
        if (!fs) { this.drawGrid(); this.drawRulers(); }
    },

    // ====================== PWA ======================
    initPWA() {
        // Inline manifest
        const manifest = {
            name: 'OpenShop Image Editor',
            short_name: 'OpenShop',
            description: 'Free browser-based image editor',
            start_url: './',
            display: 'standalone',
            background_color: '#0a0c10',
            theme_color: '#6c8cff',
            icons: [{
                src: 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><rect width="512" height="512" rx="80" fill="#0f1218"/><text x="256" y="320" text-anchor="middle" font-family="monospace" font-weight="bold" font-size="200" fill="#6c8cff">OS</text></svg>'),
                sizes: '512x512', type: 'image/svg+xml'
            }],
            file_handlers: [
                { action: './', accept: { 'image/png': ['.png'], 'image/jpeg': ['.jpg','.jpeg'], 'image/webp': ['.webp'] } }
            ]
        };
        const blob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
        const link = document.getElementById('pwa-manifest');
        if (link) link.href = URL.createObjectURL(blob);
        // Register SW if available
        if ('serviceWorker' in navigator) {
            // Inline SW via blob
            const swCode = `self.addEventListener('fetch', e => e.respondWith(fetch(e.request).catch(() => new Response('Offline'))));`;
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            navigator.serviceWorker.register(URL.createObjectURL(swBlob)).catch(() => {});
        }
    },

    // ====================== LASSO SELECTION ======================
    _lassoClick(evt) {
        const area = document.getElementById('canvas-area');
        const x = evt.offsetX, y = evt.offsetY;
        this._lassoPoints.push(`${x},${y}`);
        const svg = document.querySelector('#lasso-overlay svg polygon');
        svg.setAttribute('points', this._lassoPoints.join(' '));
    },
    _lassoDoubleClick() {
        if (this._lassoPoints.length < 3) return;
        // Close the polygon visually
        const svg = document.querySelector('#lasso-overlay svg polygon');
        svg.setAttribute('points', this._lassoPoints.join(' '));
        // Calculate bounding box from points
        const pts = this._lassoPoints.map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; });
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        pts.forEach(p => { if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y; if (p.x > maxX) maxX = p.x; if (p.y > maxY) maxY = p.y; });
        this._selectionBounds = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
        this._selectionMask = null; // Lasso uses bounds, not pixel mask
        // Show the selection overlay bounding box with marching ants
        const el = document.getElementById('selection-overlay');
        el.style.display = 'block';
        el.style.left = minX + 'px'; el.style.top = minY + 'px';
        el.style.width = (maxX - minX) + 'px'; el.style.height = (maxY - minY) + 'px';
        el.style.borderRadius = '0';
        this.toast('Lasso selection: ' + this._lassoPoints.length + ' points', 'info');
    },

    // ====================== HEALING BRUSH ======================
    _healOC: null, _healTarget: null,
    _healStart(ptr, evt) {
        let target = this.canvas.getActiveObject();
        if (!target || target.type !== 'image') {
            const objs = this.canvas.getObjects().filter(o => o.type === 'image' && o.containsPoint(ptr));
            target = objs.length ? objs[objs.length - 1] : null;
        }
        if (!target || target.type !== 'image') { this.toast('Click on an image to heal', 'info'); return; }
        const el = target.getElement();
        const oc = document.createElement('canvas');
        oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        oc.getContext('2d').drawImage(el, 0, 0);
        this._healOC = oc; this._healTarget = target;
        this._healStroke(ptr);
        const commitFn = () => {
            document.removeEventListener('mouseup', commitFn);
            if (this._healOC && this._healTarget) {
                this._replaceActiveImage(this._healTarget, this._healOC.toDataURL(), 'Healing Brush');
                this._healOC = null; this._healTarget = null;
            }
        };
        document.addEventListener('mouseup', commitFn);
    },
    _healStroke(ptr) {
        if (!this._healOC || !this._healTarget) return;
        const oc = this._healOC, ctx = oc.getContext('2d'), target = this._healTarget;
        const matrix = target.calcTransformMatrix();
        const inv = fabric.util.invertTransform(matrix);
        const local = fabric.util.transformPoint(ptr, inv);
        const lx = local.x + oc.width / 2, ly = local.y + oc.height / 2;
        const size = this.state.healingSize, r = Math.ceil(size / 2);
        const x0 = Math.max(0, Math.floor(lx - r)), y0 = Math.max(0, Math.floor(ly - r));
        const x1 = Math.min(oc.width, Math.ceil(lx + r)), y1 = Math.min(oc.height, Math.ceil(ly + r));
        if (x1 <= x0 || y1 <= y0) return;
        try {
            const imgData = ctx.getImageData(x0, y0, x1 - x0, y1 - y0);
            const d = imgData.data, w = imgData.width;
            let tr = 0, tg = 0, tb = 0, cnt = 0;
            for (let py = 0; py < imgData.height; py++) for (let px = 0; px < w; px++) {
                const dist = Math.sqrt((px + x0 - lx) ** 2 + (py + y0 - ly) ** 2);
                if (dist > r * 0.6 && dist < r) { const i = (py * w + px) * 4; tr += d[i]; tg += d[i+1]; tb += d[i+2]; cnt++; }
            }
            if (cnt > 0) {
                tr = Math.round(tr / cnt); tg = Math.round(tg / cnt); tb = Math.round(tb / cnt);
                for (let py = 0; py < imgData.height; py++) for (let px = 0; px < w; px++) {
                    const dist = Math.sqrt((px + x0 - lx) ** 2 + (py + y0 - ly) ** 2);
                    if (dist < r * 0.6) { const blend = dist / (r * 0.6); const i = (py * w + px) * 4;
                        d[i] = Math.round(d[i]*blend + tr*(1-blend)); d[i+1] = Math.round(d[i+1]*blend + tg*(1-blend)); d[i+2] = Math.round(d[i+2]*blend + tb*(1-blend));
                    }
                }
                ctx.putImageData(imgData, x0, y0);
                const vpt = this.canvas.viewportTransform, dCtx = this.canvas.getContext('2d');
                const sX = ptr.x*vpt[0]+vpt[4], sY = ptr.y*vpt[3]+vpt[5];
                try { dCtx.putImageData(imgData, sX-(lx-x0)*vpt[0], sY-(ly-y0)*vpt[3]); } catch(e2) {}
            }
        } catch(e) {}
    },

    // ====================== MEASURE TOOL ======================
    _measureClick(ptr, evt) {
        if (!this._measureStart) {
            this._measureStart = { x: ptr.x, y: ptr.y, sx: evt.offsetX, sy: evt.offsetY };
            this.toast('Click second point', 'info');
        } else {
            const from = this._measureStart, to = { x: ptr.x, y: ptr.y, sx: evt.offsetX, sy: evt.offsetY };
            const dx = to.x - from.x, dy = to.y - from.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            document.getElementById('measure-result').textContent = `${dist.toFixed(1)}px / ${angle.toFixed(1)}deg`;
            // Draw visual line
            const overlay = document.getElementById('measure-overlay');
            const midX = (from.sx + to.sx) / 2, midY = (from.sy + to.sy) / 2;
            const screenDist = Math.sqrt((to.sx - from.sx) ** 2 + (to.sy - from.sy) ** 2);
            const screenAngle = Math.atan2(to.sy - from.sy, to.sx - from.sx);
            overlay.innerHTML = `<div class="ml-line" style="position:absolute;left:${from.sx}px;top:${from.sy}px;width:${screenDist}px;height:2px;background:var(--warning);transform:rotate(${screenAngle}rad);transform-origin:0 50%"></div>
                <div class="measure-label" style="left:${midX}px;top:${midY - 18}px">${dist.toFixed(1)}px &middot; ${angle.toFixed(1)}&deg;</div>
                <div style="position:absolute;left:${from.sx-3}px;top:${from.sy-3}px;width:6px;height:6px;border-radius:50%;background:var(--warning)"></div>
                <div style="position:absolute;left:${to.sx-3}px;top:${to.sy-3}px;width:6px;height:6px;border-radius:50%;background:var(--warning)"></div>`;
            this._measureStart = null;
        }
    },

    // ====================== CURVES DIALOG ======================
    showCurvesDialog() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        this._curvesChannel = 'rgb';
        this._curvesPoints = { rgb: [[0,0],[64,64],[128,128],[192,192],[255,255]], r: [[0,0],[255,255]], g: [[0,0],[255,255]], b: [[0,0],[255,255]] };
        this._curvesActivePoint = -1;
        const body = `<div class="curves-channel-row">
                <button class="btn active" id="cv-ch-rgb" onclick="OS._curvesChannel='rgb';this.parentElement.querySelectorAll('.btn').forEach(b=>b.classList.remove('active'));this.classList.add('active');OS._drawCurvesGrid()">RGB</button>
                <button class="btn" id="cv-ch-r" onclick="OS._curvesChannel='r';this.parentElement.querySelectorAll('.btn').forEach(b=>b.classList.remove('active'));this.classList.add('active');OS._drawCurvesGrid()">R</button>
                <button class="btn" id="cv-ch-g" onclick="OS._curvesChannel='g';this.parentElement.querySelectorAll('.btn').forEach(b=>b.classList.remove('active'));this.classList.add('active');OS._drawCurvesGrid()">G</button>
                <button class="btn" id="cv-ch-b" onclick="OS._curvesChannel='b';this.parentElement.querySelectorAll('.btn').forEach(b=>b.classList.remove('active'));this.classList.add('active');OS._drawCurvesGrid()">B</button>
            </div>
            <canvas id="curves-canvas" class="curves-canvas" width="256" height="256"></canvas>
            <div class="curves-presets">
                <button class="btn" onclick="OS._curvesPreset('linear')">Reset</button>
                <button class="btn" onclick="OS._curvesPreset('brighten')">Brighten</button>
                <button class="btn" onclick="OS._curvesPreset('darken')">Darken</button>
                <button class="btn" onclick="OS._curvesPreset('contrast')">S-Curve</button>
                <button class="btn" onclick="OS._curvesPreset('invert')">Invert</button>
            </div>`;
        this._openFilterPanel('curves-dialog-overlay', 'Curves', body,
            ()=>this._removeFilterPanel('curves-dialog-overlay'),
            ()=>this._applyCurves());
        setTimeout(() => this._initCurvesCanvas(), 50);
    },
    _initCurvesCanvas() {
        const cv = document.getElementById('curves-canvas'); if (!cv) return;
        this._drawCurvesGrid();
        cv.addEventListener('mousedown', e => {
            const rect = cv.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const ch = this._curvesChannel;
            const pts = this._curvesPoints[ch];
            // Find closest point or add new
            let closest = -1, minD = 20;
            pts.forEach((p, i) => { const d = Math.sqrt((p[0] - x) ** 2 + (p[1] - (255 - y)) ** 2); if (d < minD) { minD = d; closest = i; } });
            if (closest >= 0) { this._curvesActivePoint = closest; }
            else { pts.push([x, 255 - y]); pts.sort((a, b) => a[0] - b[0]); this._curvesActivePoint = pts.findIndex(p => p[0] === x); }
            this._drawCurvesGrid();
        });
        cv.addEventListener('mousemove', e => {
            if (this._curvesActivePoint < 0) return;
            if (!(e.buttons & 1)) { this._curvesActivePoint = -1; return; }
            const rect = cv.getBoundingClientRect();
            const x = Math.max(0, Math.min(255, e.clientX - rect.left));
            const y = Math.max(0, Math.min(255, 255 - (e.clientY - rect.top)));
            const ch = this._curvesChannel;
            this._curvesPoints[ch][this._curvesActivePoint] = [x, y];
            this._drawCurvesGrid();
        });
        cv.addEventListener('mouseup', () => { this._curvesActivePoint = -1; });
    },
    _drawCurvesGrid() {
        const cv = document.getElementById('curves-canvas'); if (!cv) return;
        const ctx = cv.getContext('2d');
        ctx.clearRect(0, 0, 256, 256);
        ctx.fillStyle = '#1c2230'; ctx.fillRect(0, 0, 256, 256);
        ctx.strokeStyle = '#2a3142'; ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) { const p = i * 64; ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, 256); ctx.moveTo(0, p); ctx.lineTo(256, p); ctx.stroke(); }
        ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(0, 256); ctx.lineTo(256, 0); ctx.stroke();
        const ch = this._curvesChannel;
        const colors = { rgb: '#fff', r: '#ff4444', g: '#44ff44', b: '#4488ff' };
        const pts = this._curvesPoints[ch];
        ctx.strokeStyle = colors[ch]; ctx.lineWidth = 2; ctx.beginPath();
        const lut = this._buildCurveLUT(pts);
        for (let x = 0; x < 256; x++) { const y = 255 - lut[x]; x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y); }
        ctx.stroke();
        ctx.fillStyle = colors[ch];
        pts.forEach(p => { ctx.beginPath(); ctx.arc(p[0], 255 - p[1], 4, 0, Math.PI * 2); ctx.fill(); });
    },
    _buildCurveLUT(pts) {
        const lut = new Uint8Array(256);
        for (let x = 0; x < 256; x++) {
            let i = 0;
            while (i < pts.length - 1 && pts[i + 1][0] < x) i++;
            if (i >= pts.length - 1) { lut[x] = Math.max(0, Math.min(255, pts[pts.length - 1][1])); continue; }
            const [x0, y0] = pts[i], [x1, y1] = pts[i + 1];
            const t = x1 === x0 ? 0 : (x - x0) / (x1 - x0);
            lut[x] = Math.max(0, Math.min(255, Math.round(y0 + t * (y1 - y0))));
        }
        return lut;
    },
    _curvesPreset(name) {
        const ch = this._curvesChannel;
        switch (name) {
            case 'linear': this._curvesPoints[ch] = [[0, 0], [255, 255]]; break;
            case 'brighten': this._curvesPoints[ch] = [[0, 0], [64, 96], [192, 230], [255, 255]]; break;
            case 'darken': this._curvesPoints[ch] = [[0, 0], [64, 32], [192, 160], [255, 255]]; break;
            case 'contrast': this._curvesPoints[ch] = [[0, 0], [64, 32], [192, 224], [255, 255]]; break;
            case 'invert': this._curvesPoints[ch] = [[0, 255], [255, 0]]; break;
        }
        this._drawCurvesGrid();
    },
    _applyCurves() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this._removeFilterPanel('curves-dialog-overlay'); return; }
        const el = active.getElement();
        const oc = document.createElement('canvas'); oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        const octx = oc.getContext('2d'); octx.drawImage(el, 0, 0);
        const imgData = octx.getImageData(0, 0, oc.width, oc.height);
        const d = imgData.data;
        const lutR = this._buildCurveLUT(this._curvesPoints.r.length > 0 && this._curvesPoints.r[0][0] !== this._curvesPoints.r[this._curvesPoints.r.length-1][0] ? this._curvesPoints.r : this._curvesPoints.rgb);
        const lutG = this._buildCurveLUT(this._curvesPoints.g.length > 0 && this._curvesPoints.g[0][0] !== this._curvesPoints.g[this._curvesPoints.g.length-1][0] ? this._curvesPoints.g : this._curvesPoints.rgb);
        const lutB = this._buildCurveLUT(this._curvesPoints.b.length > 0 && this._curvesPoints.b[0][0] !== this._curvesPoints.b[this._curvesPoints.b.length-1][0] ? this._curvesPoints.b : this._curvesPoints.rgb);
        const lutMaster = this._buildCurveLUT(this._curvesPoints.rgb);
        for (let i = 0; i < d.length; i += 4) {
            d[i] = lutR[lutMaster[d[i]]]; d[i+1] = lutG[lutMaster[d[i+1]]]; d[i+2] = lutB[lutMaster[d[i+2]]];
        }
        octx.putImageData(imgData, 0, 0);
        this._replaceActiveImage(active, oc.toDataURL(), 'Curves');
        this._removeFilterPanel('curves-dialog-overlay'); this.toast('Curves applied', 'success');
    },

    // ====================== LEVELS DIALOG ======================
    showLevelsDialog() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        const el = active.getElement();
        const snapW = el.naturalWidth || el.width, snapH = el.naturalHeight || el.height;
        const snapOC = document.createElement('canvas'); snapOC.width = snapW; snapOC.height = snapH;
        snapOC.getContext('2d').drawImage(el, 0, 0);
        this._lvlSnap = snapOC;
        this._lvlTarget = active;
        const body = `
            <div class="modal-row"><label>Shadow</label><input id="lvl-shadow" type="range" min="0" max="255" value="0" oninput="OS._levelsPreview()"><span class="opt-val">0</span></div>
            <div class="modal-row"><label>Midtone</label><input id="lvl-mid" type="range" min="10" max="400" value="100" oninput="OS._levelsPreview()"><span class="opt-val">1.00</span></div>
            <div class="modal-row"><label>Highlight</label><input id="lvl-high" type="range" min="0" max="255" value="255" oninput="OS._levelsPreview()"><span class="opt-val">255</span></div>
            <div class="modal-row"><label>Out Black</label><input id="lvl-oblack" type="range" min="0" max="255" value="0" oninput="OS._levelsPreview()"><span class="opt-val">0</span></div>
            <div class="modal-row"><label>Out White</label><input id="lvl-owhite" type="range" min="0" max="255" value="255" oninput="OS._levelsPreview()"><span class="opt-val">255</span></div>`;
        this._openFilterPanel('levels-dialog-overlay', 'Levels', body,
            ()=>this._levelsCancel(), ()=>this._levelsApply());
    },
    _levelsPreview() {
        clearTimeout(this._lvlDebounce);
        this._lvlDebounce = setTimeout(() => {
            const panel = document.getElementById('levels-dialog-overlay');
            if (!panel || !this._lvlSnap || !this._lvlTarget) return;
            const shadow = +panel.querySelector('#lvl-shadow').value;
            const mid = +panel.querySelector('#lvl-mid').value / 100;
            const high = +panel.querySelector('#lvl-high').value;
            const oBlack = +panel.querySelector('#lvl-oblack').value;
            const oWhite = +panel.querySelector('#lvl-owhite').value;
            // Update labels
            panel.querySelector('#lvl-shadow').nextElementSibling.textContent = shadow;
            panel.querySelector('#lvl-mid').nextElementSibling.textContent = mid.toFixed(2);
            panel.querySelector('#lvl-high').nextElementSibling.textContent = high;
            panel.querySelector('#lvl-oblack').nextElementSibling.textContent = oBlack;
            panel.querySelector('#lvl-owhite').nextElementSibling.textContent = oWhite;
            // Process from snapshot
            const snap = this._lvlSnap;
            const oc = document.createElement('canvas'); oc.width = snap.width; oc.height = snap.height;
            const ctx = oc.getContext('2d'); ctx.drawImage(snap, 0, 0);
            const imgData = ctx.getImageData(0, 0, oc.width, oc.height); const d = imgData.data;
            const range = high - shadow || 1;
            for (let i = 0; i < d.length; i += 4) {
                for (let c = 0; c < 3; c++) {
                    let v = (d[i + c] - shadow) / range;
                    v = Math.max(0, Math.min(1, v));
                    v = Math.pow(v, 1 / mid);
                    d[i + c] = Math.round(oBlack + v * (oWhite - oBlack));
                }
            }
            ctx.putImageData(imgData, 0, 0);
            // Update image on canvas via element swap
            const active = this._lvlTarget;
            const img = new Image();
            img.onload = () => {
                active.setElement(img);
                active.set({ width: img.width, height: img.height });
                active.applyFilters();
                this.canvas.renderAll();
            };
            img.src = oc.toDataURL();
        }, 60);
    },
    _levelsCancel() {
        if (this._lvlSnap && this._lvlTarget) {
            const active = this._lvlTarget;
            const img = new Image();
            img.onload = () => {
                active.setElement(img);
                active.set({ width: img.width, height: img.height });
                active.applyFilters();
                this.canvas.renderAll();
            };
            img.src = this._lvlSnap.toDataURL();
        }
        this._removeFilterPanel('levels-dialog-overlay');
        this._lvlSnap = null; this._lvlTarget = null;
    },
    _levelsApply() {
        this.saveHistory('Levels');
        this.toast('Levels applied', 'success');
        this._removeFilterPanel('levels-dialog-overlay');
        this._lvlSnap = null; this._lvlTarget = null;
    },

    // ====================== COLOR BALANCE ======================
    showColorBalanceDialog() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        const el = active.getElement();
        const snapW = el.naturalWidth || el.width, snapH = el.naturalHeight || el.height;
        const snapOC = document.createElement('canvas'); snapOC.width = snapW; snapOC.height = snapH;
        snapOC.getContext('2d').drawImage(el, 0, 0);
        this._cbSnap = snapOC;
        this._cbTarget = active;
        const body = `
            <div style="font-size:11px;color:var(--text-muted);margin-bottom:6px;text-align:center">Shadows</div>
            <div class="modal-row"><label>Cyan-Red</label><input id="cb-sr" type="range" min="-100" max="100" value="0" oninput="OS._cbPreview()"><span class="opt-val">0</span></div>
            <div class="modal-row"><label>Mag-Green</label><input id="cb-sg" type="range" min="-100" max="100" value="0" oninput="OS._cbPreview()"><span class="opt-val">0</span></div>
            <div class="modal-row"><label>Yel-Blue</label><input id="cb-sb" type="range" min="-100" max="100" value="0" oninput="OS._cbPreview()"><span class="opt-val">0</span></div>
            <div style="font-size:11px;color:var(--text-muted);margin:6px 0;text-align:center">Midtones</div>
            <div class="modal-row"><label>Cyan-Red</label><input id="cb-mr" type="range" min="-100" max="100" value="0" oninput="OS._cbPreview()"><span class="opt-val">0</span></div>
            <div class="modal-row"><label>Mag-Green</label><input id="cb-mg" type="range" min="-100" max="100" value="0" oninput="OS._cbPreview()"><span class="opt-val">0</span></div>
            <div class="modal-row"><label>Yel-Blue</label><input id="cb-mb" type="range" min="-100" max="100" value="0" oninput="OS._cbPreview()"><span class="opt-val">0</span></div>`;
        this._openFilterPanel('cb-dialog-overlay', 'Color Balance', body,
            ()=>this._cbCancel(), ()=>this._cbApply());
    },
    _cbPreview() {
        clearTimeout(this._cbDebounce);
        this._cbDebounce = setTimeout(() => {
            const panel = document.getElementById('cb-dialog-overlay');
            if (!panel || !this._cbSnap || !this._cbTarget) return;
            const sr = +panel.querySelector('#cb-sr').value, sg = +panel.querySelector('#cb-sg').value, sb = +panel.querySelector('#cb-sb').value;
            const mr = +panel.querySelector('#cb-mr').value, mg = +panel.querySelector('#cb-mg').value, mb = +panel.querySelector('#cb-mb').value;
            panel.querySelectorAll('input[type="range"]').forEach(inp => {
                if (inp.nextElementSibling) inp.nextElementSibling.textContent = inp.value;
            });
            const snap = this._cbSnap;
            const oc = document.createElement('canvas'); oc.width = snap.width; oc.height = snap.height;
            const ctx = oc.getContext('2d'); ctx.drawImage(snap, 0, 0);
            const imgData = ctx.getImageData(0, 0, oc.width, oc.height); const d = imgData.data;
            for (let i = 0; i < d.length; i += 4) {
                const lum = (d[i] + d[i+1] + d[i+2]) / 3 / 255;
                const shadowW = Math.max(0, 1 - lum * 3);
                const midW = 1 - Math.abs(lum - 0.5) * 2;
                d[i] = Math.max(0, Math.min(255, d[i] + sr * shadowW / 100 * 80 + mr * midW / 100 * 80));
                d[i+1] = Math.max(0, Math.min(255, d[i+1] + sg * shadowW / 100 * 80 + mg * midW / 100 * 80));
                d[i+2] = Math.max(0, Math.min(255, d[i+2] + sb * shadowW / 100 * 80 + mb * midW / 100 * 80));
            }
            ctx.putImageData(imgData, 0, 0);
            const active = this._cbTarget;
            const img = new Image();
            img.onload = () => {
                active.setElement(img);
                active.set({ width: img.width, height: img.height });
                active.applyFilters();
                this.canvas.renderAll();
            };
            img.src = oc.toDataURL();
        }, 60);
    },
    _cbCancel() {
        if (this._cbSnap && this._cbTarget) {
            const active = this._cbTarget;
            const img = new Image();
            img.onload = () => {
                active.setElement(img);
                active.set({ width: img.width, height: img.height });
                active.applyFilters();
                this.canvas.renderAll();
            };
            img.src = this._cbSnap.toDataURL();
        }
        this._removeFilterPanel('cb-dialog-overlay');
        this._cbSnap = null; this._cbTarget = null;
    },
    _cbApply() {
        this.saveHistory('Color Balance');
        this.toast('Color balance applied', 'success');
        this._removeFilterPanel('cb-dialog-overlay');
        this._cbSnap = null; this._cbTarget = null;
    },

    // ====================== AUTO ENHANCEMENTS ======================
    autoLevels() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        const el = active.getElement();
        const oc = document.createElement('canvas'); oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        const octx = oc.getContext('2d'); octx.drawImage(el, 0, 0);
        const imgData = octx.getImageData(0, 0, oc.width, oc.height); const d = imgData.data;
        // Find min/max per channel
        let rMin = 255, rMax = 0, gMin = 255, gMax = 0, bMin = 255, bMax = 0;
        for (let i = 0; i < d.length; i += 4) {
            if (d[i] < rMin) rMin = d[i]; if (d[i] > rMax) rMax = d[i];
            if (d[i+1] < gMin) gMin = d[i+1]; if (d[i+1] > gMax) gMax = d[i+1];
            if (d[i+2] < bMin) bMin = d[i+2]; if (d[i+2] > bMax) bMax = d[i+2];
        }
        const stretch = (v, mn, mx) => mx === mn ? v : Math.round((v - mn) / (mx - mn) * 255);
        for (let i = 0; i < d.length; i += 4) {
            d[i] = stretch(d[i], rMin, rMax); d[i+1] = stretch(d[i+1], gMin, gMax); d[i+2] = stretch(d[i+2], bMin, bMax);
        }
        octx.putImageData(imgData, 0, 0);
        this._replaceActiveImage(active, oc.toDataURL(), 'Auto Levels');
        this.toast('Auto levels applied', 'success');
    },
    autoContrast() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        const el = active.getElement();
        const oc = document.createElement('canvas'); oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        const octx = oc.getContext('2d'); octx.drawImage(el, 0, 0);
        const imgData = octx.getImageData(0, 0, oc.width, oc.height); const d = imgData.data;
        let lMin = 255, lMax = 0;
        for (let i = 0; i < d.length; i += 4) {
            const l = Math.round(0.299 * d[i] + 0.587 * d[i+1] + 0.114 * d[i+2]);
            if (l < lMin) lMin = l; if (l > lMax) lMax = l;
        }
        const range = lMax - lMin || 1;
        for (let i = 0; i < d.length; i += 4) {
            for (let c = 0; c < 3; c++) d[i+c] = Math.max(0, Math.min(255, Math.round((d[i+c] - lMin) / range * 255)));
        }
        octx.putImageData(imgData, 0, 0);
        this._replaceActiveImage(active, oc.toDataURL(), 'Auto Contrast');
        this.toast('Auto contrast applied', 'success');
    },
    _replaceActiveImage(active, dataUrl, histName) {
        fabric.Image.fromURL(dataUrl, newImg => {
            newImg.set({ left: active.left, top: active.top, scaleX: active.scaleX, scaleY: active.scaleY, angle: active.angle, flipX: active.flipX, flipY: active.flipY, originX: active.originX, originY: active.originY, selectable: true, name: histName });
            const li = this.layers.findIndex(l => l.objects.includes(active));
            if (li >= 0) { const idx = this.layers[li].objects.indexOf(active); this.layers[li].objects[idx] = newImg; }
            this.canvas.remove(active); this.canvas.add(newImg); this.canvas.setActiveObject(newImg);
            this.canvas.renderAll(); this.saveHistory(histName); this.updateLayersPanel();
        });
    },
    _floodFillImage(target,ptr){
        const el=target.getElement();
        const oc=document.createElement('canvas');
        oc.width=el.naturalWidth||el.width;oc.height=el.naturalHeight||el.height;
        const ctx=oc.getContext('2d');ctx.drawImage(el,0,0);
        const matrix=target.calcTransformMatrix(),inv=fabric.util.invertTransform(matrix);
        const local=fabric.util.transformPoint(ptr,inv);
        const lx=Math.round(local.x+oc.width/2),ly=Math.round(local.y+oc.height/2);
        if(lx<0||ly<0||lx>=oc.width||ly>=oc.height)return;
        const imgData=ctx.getImageData(0,0,oc.width,oc.height),d=imgData.data,w=oc.width,h=oc.height;
        const idx=(ly*w+lx)*4,tr=d[idx],tg=d[idx+1],tb=d[idx+2];
        const fh=this.state.fgColor,fr=parseInt(fh.slice(1,3),16),fg=parseInt(fh.slice(3,5),16),fb=parseInt(fh.slice(5,7),16);
        if(tr===fr&&tg===fg&&tb===fb)return;
        const tol=32,visited=new Uint8Array(w*h),stack=[[lx,ly]];let count=0;
        while(stack.length&&count<2000000){
            const[x,y]=stack.pop();if(x<0||y<0||x>=w||y>=h)continue;
            const pi=y*w+x;if(visited[pi])continue;const ii=pi*4;
            if(Math.abs(d[ii]-tr)<=tol&&Math.abs(d[ii+1]-tg)<=tol&&Math.abs(d[ii+2]-tb)<=tol){
                visited[pi]=1;d[ii]=fr;d[ii+1]=fg;d[ii+2]=fb;d[ii+3]=255;count++;
                stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
            }
        }
        ctx.putImageData(imgData,0,0);
        this._replaceActiveImage(target,oc.toDataURL(),'Flood Fill');
        this.toast('Filled '+count.toLocaleString()+' px','success');
    },

    // ====================== ALIGN & DISTRIBUTE ======================
    alignObjects(dir) {
        const objs = this.canvas.getActiveObjects();
        if (objs.length < 2) { this.toast('Select 2+ objects', 'info'); return; }
        const bounds = objs.map(o => o.getBoundingRect());
        switch (dir) {
            case 'left': { const m = Math.min(...bounds.map(b => b.left)); objs.forEach((o, i) => o.set('left', o.left + m - bounds[i].left)); break; }
            case 'right': { const m = Math.max(...bounds.map(b => b.left + b.width)); objs.forEach((o, i) => o.set('left', o.left + m - bounds[i].left - bounds[i].width)); break; }
            case 'top': { const m = Math.min(...bounds.map(b => b.top)); objs.forEach((o, i) => o.set('top', o.top + m - bounds[i].top)); break; }
            case 'bottom': { const m = Math.max(...bounds.map(b => b.top + b.height)); objs.forEach((o, i) => o.set('top', o.top + m - bounds[i].top - bounds[i].height)); break; }
            case 'centerH': { const all = bounds.reduce((a, b) => ({ left: Math.min(a.left, b.left), right: Math.max(a.right || a.left + a.width, b.left + b.width) }), { left: Infinity, right: -Infinity }); const mid = (all.left + all.right) / 2; objs.forEach((o, i) => o.set('left', o.left + mid - bounds[i].left - bounds[i].width / 2)); break; }
            case 'centerV': { const all = bounds.reduce((a, b) => ({ top: Math.min(a.top, b.top), bottom: Math.max(a.bottom || a.top + a.height, b.top + b.height) }), { top: Infinity, bottom: -Infinity }); const mid = (all.top + all.bottom) / 2; objs.forEach((o, i) => o.set('top', o.top + mid - bounds[i].top - bounds[i].height / 2)); break; }
        }
        this.canvas.renderAll(); this.saveHistory('Align ' + dir);
    },
    distributeObjects(dir) {
        const objs = this.canvas.getActiveObjects();
        if (objs.length < 3) { this.toast('Select 3+ objects', 'info'); return; }
        const bounds = objs.map((o, i) => ({ i, ...o.getBoundingRect() }));
        if (dir === 'horizontal') {
            bounds.sort((a, b) => a.left - b.left);
            const totalW = bounds.reduce((s, b) => s + b.width, 0);
            const space = (bounds[bounds.length - 1].left + bounds[bounds.length - 1].width - bounds[0].left - totalW) / (bounds.length - 1);
            let x = bounds[0].left + bounds[0].width;
            for (let k = 1; k < bounds.length - 1; k++) {
                x += space;
                const o = objs[bounds[k].i], b = bounds[k];
                o.set('left', o.left + x - b.left);
                x += b.width;
            }
        } else {
            bounds.sort((a, b) => a.top - b.top);
            const totalH = bounds.reduce((s, b) => s + b.height, 0);
            const space = (bounds[bounds.length - 1].top + bounds[bounds.length - 1].height - bounds[0].top - totalH) / (bounds.length - 1);
            let y = bounds[0].top + bounds[0].height;
            for (let k = 1; k < bounds.length - 1; k++) {
                y += space;
                const o = objs[bounds[k].i], b = bounds[k];
                o.set('top', o.top + y - b.top);
                y += b.height;
            }
        }
        this.canvas.renderAll(); this.saveHistory('Distribute ' + dir);
    },

    // ====================== GUIDES ======================
    addGuide(orientation) {
        const area = document.getElementById('canvas-area');
        const pos = orientation === 'horizontal' ? area.clientHeight / 2 : area.clientWidth / 2;
        const guide = { orientation, pos, el: null };
        const el = document.createElement('div');
        el.className = `guide-line ${orientation}`;
        if (orientation === 'horizontal') el.style.top = pos + 'px';
        else el.style.left = pos + 'px';
        guide.el = el;
        let dragging = false, startPos;
        el.addEventListener('mousedown', e => { dragging = true; startPos = orientation === 'horizontal' ? e.clientY : e.clientX; e.stopPropagation(); });
        const onMove = e => {
            if (!dragging) return;
            const delta = (orientation === 'horizontal' ? e.clientY : e.clientX) - startPos;
            guide.pos += delta;
            if (orientation === 'horizontal') el.style.top = guide.pos + 'px';
            else el.style.left = guide.pos + 'px';
            startPos = orientation === 'horizontal' ? e.clientY : e.clientX;
        };
        const onUp = () => { dragging = false; };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
        el.addEventListener('dblclick', () => {
            el.remove(); this.guides = this.guides.filter(g => g !== guide);
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            this.toast('Guide removed', 'info');
        });
        document.getElementById('guides-container').appendChild(el);
        this.guides.push(guide);
        this.toast(`${orientation} guide added (double-click to remove)`, 'info');
    },
    clearGuides() {
        document.getElementById('guides-container').innerHTML = '';
        this.guides = [];
        this.toast('All guides cleared', 'info');
    },

    // ====================== TEXT EFFECTS ======================
    applyTextFx() {
        const active = this.canvas.getActiveObject();
        if (!active || (active.type !== 'i-text' && active.type !== 'text' && active.type !== 'textbox')) return;
        const sx = +document.getElementById('tfx-sx').value;
        const sy = +document.getElementById('tfx-sy').value;
        const blur = +document.getElementById('tfx-blur').value;
        const color = document.getElementById('tfx-color').value;
        const strokeW = +document.getElementById('tfx-stroke').value;
        const strokeC = document.getElementById('tfx-stroke-color').value;
        active.set('shadow', new fabric.Shadow({ color, offsetX: sx, offsetY: sy, blur }));
        if (strokeW > 0) { active.set({ stroke: strokeC, strokeWidth: strokeW, paintFirst: 'stroke' }); }
        else { active.set({ stroke: null, strokeWidth: 0 }); }
        this.canvas.renderAll();
    },
    clearTextFx() {
        const active = this.canvas.getActiveObject();
        if (!active) return;
        active.set({ shadow: null, stroke: null, strokeWidth: 0 });
        this.canvas.renderAll(); this.saveHistory('Clear Text FX');
    },

    // ====================== FREE TRANSFORM ======================
    showFreeTransform() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Select an object first', 'info'); return; }
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>Free Transform</h3>
            <div class="modal-row"><label>Scale X</label><input id="ft-sx" type="range" min="10" max="300" value="${Math.round((active.scaleX||1)*100)}" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">${Math.round((active.scaleX||1)*100)}%</span></div>
            <div class="modal-row"><label>Scale Y</label><input id="ft-sy" type="range" min="10" max="300" value="${Math.round((active.scaleY||1)*100)}" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">${Math.round((active.scaleY||1)*100)}%</span></div>
            <div class="modal-row"><label>Rotation</label><input id="ft-rot" type="range" min="-180" max="180" value="${Math.round(active.angle||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.angle||0)}&deg;</span></div>
            <div class="modal-row"><label>Skew X</label><input id="ft-skx" type="range" min="-60" max="60" value="${Math.round(active.skewX||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.skewX||0)}&deg;</span></div>
            <div class="modal-row"><label>Skew Y</label><input id="ft-sky" type="range" min="-60" max="60" value="${Math.round(active.skewY||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.skewY||0)}&deg;</span></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS._applyFreeTransform(this.closest('.modal-overlay'))">Apply</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    _applyFreeTransform(overlay) {
        const active = this.canvas.getActiveObject(); if (!active) { overlay.remove(); return; }
        active.set({
            scaleX: +overlay.querySelector('#ft-sx').value / 100,
            scaleY: +overlay.querySelector('#ft-sy').value / 100,
            angle: +overlay.querySelector('#ft-rot').value,
            skewX: +overlay.querySelector('#ft-skx').value,
            skewY: +overlay.querySelector('#ft-sky').value,
        });
        active.setCoords(); this.canvas.renderAll(); this.saveHistory('Free Transform');
        overlay.remove(); this.toast('Transform applied', 'success');
    },
    skewObject() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Select an object first', 'info'); return; }
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>Skew</h3>
            <div class="modal-row"><label>Skew X</label><input id="sk-x" type="range" min="-60" max="60" value="${Math.round(active.skewX||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.skewX||0)}&deg;</span></div>
            <div class="modal-row"><label>Skew Y</label><input id="sk-y" type="range" min="-60" max="60" value="${Math.round(active.skewY||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.skewY||0)}&deg;</span></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS._applySkew(this.closest('.modal-overlay'))">Apply</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    _applySkew(overlay) {
        const active = this.canvas.getActiveObject(); if (!active) { overlay.remove(); return; }
        active.set({ skewX: +overlay.querySelector('#sk-x').value, skewY: +overlay.querySelector('#sk-y').value });
        active.setCoords(); this.canvas.renderAll(); this.saveHistory('Skew');
        overlay.remove(); this.toast('Skew applied', 'success');
    },

    // ====================== LAYER MASKS (BASIC) ======================
    addLayerMask() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Select an object first', 'info'); return; }
        // Create a circular clipPath as a basic mask
        const rect = active.getBoundingRect();
        const clipRect = new fabric.Rect({
            originX: 'center', originY: 'center',
            width: rect.width / (active.scaleX || 1) * 0.8,
            height: rect.height / (active.scaleY || 1) * 0.8,
        });
        active.clipPath = clipRect;
        active._hasMask = true;
        this.canvas.renderAll(); this.saveHistory('Add Mask'); this.updateLayersPanel();
        this.toast('Layer mask added (rectangular). Select object to adjust.', 'success');
    },
    removeLayerMask() {
        const active = this.canvas.getActiveObject();
        if (!active) return;
        active.clipPath = null;
        active._hasMask = false;
        this.canvas.renderAll(); this.saveHistory('Remove Mask'); this.updateLayersPanel();
        this.toast('Mask removed', 'info');
    },

    // ====================== PEN / BEZIER TOOL ======================
    _penClick(ptr, evt) {
        const vpt = this.canvas.viewportTransform;
        const sx = ptr.x * vpt[0] + vpt[4], sy = ptr.y * vpt[3] + vpt[5];
        this._penPoints.push({ x: ptr.x, y: ptr.y, sx, sy });
        this._penUpdatePreview();
    },
    _penUpdatePreview() {
        const svg = document.querySelector('#pen-overlay svg path');
        if (!svg || this._penPoints.length < 1) return;
        let d = `M ${this._penPoints[0].sx} ${this._penPoints[0].sy}`;
        for (let i = 1; i < this._penPoints.length; i++) d += ` L ${this._penPoints[i].sx} ${this._penPoints[i].sy}`;
        svg.setAttribute('d', d);
    },
    _penFinish() {
        if (this._penPoints.length < 2) { this._penPoints = []; return; }
        const pts = this._penPoints.map(p => `${p.x} ${p.y}`).join(', ');
        const pathStr = 'M ' + this._penPoints.map(p => `${p.x} ${p.y}`).join(' L ');
        const closed = this.state.penFilled ? pathStr + ' Z' : pathStr;
        const path = new fabric.Path(closed, {
            fill: this.state.penFilled ? this.state.shapeFill : 'transparent',
            stroke: this.state.penStroke,
            strokeWidth: this.state.penWidth,
            selectable: true,
        });
        this.canvas.add(path);
        this.layers[this.activeLayerIdx].objects.push(path);
        this.saveHistory('Pen Path'); this.updateLayersPanel();
        const segCount = this._penPoints.length;
        this._penPoints = [];
        const svg = document.querySelector('#pen-overlay svg path');
        if (svg) svg.setAttribute('d', '');
        this.toast('Path created ('+segCount+' segments)', 'success');
    },

    // ====================== HISTOGRAM ======================
    updateHistogram() {
        const cv = document.getElementById('histogram-canvas');
        if (!cv) return;
        const ctx = cv.getContext('2d', { willReadFrequently: true });
        ctx.clearRect(0, 0, cv.width, cv.height);
        ctx.fillStyle = '#1c2230'; ctx.fillRect(0, 0, cv.width, cv.height);
        try {
            const vpt = this.canvas.viewportTransform.slice();
            this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
            const data = this.canvas.getContext('2d').getImageData(0, 0, Math.min(this.canvasW, 800), Math.min(this.canvasH, 800));
            this.canvas.viewportTransform = vpt; this.canvas.renderAll();
            const d = data.data;
            const bins = { r: new Uint32Array(256), g: new Uint32Array(256), b: new Uint32Array(256), l: new Uint32Array(256) };
            for (let i = 0; i < d.length; i += 4) {
                bins.r[d[i]]++; bins.g[d[i+1]]++; bins.b[d[i+2]]++;
                bins.l[Math.round(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2])]++;
            }
            const ch = this._histChannel;
            const arr = ch === 'red' ? bins.r : ch === 'green' ? bins.g : ch === 'blue' ? bins.b : bins.l;
            const max = Math.max(...arr);
            if (max === 0) return;
            const colors = { luminance: 'rgba(200,200,200,0.8)', red: 'rgba(255,80,80,0.8)', green: 'rgba(80,255,80,0.8)', blue: 'rgba(80,120,255,0.8)' };
            ctx.fillStyle = colors[ch] || colors.luminance;
            const w = cv.width / 256;
            for (let i = 0; i < 256; i++) {
                const h = (arr[i] / max) * cv.height;
                ctx.fillRect(i * w, cv.height - h, w + 0.5, h);
            }
            // Stats
            let min = 0, mx = 255, total = 0, sum = 0;
            for (let i = 0; i < 256; i++) { if (arr[i] > 0 && !total) min = i; if (arr[i] > 0) mx = i; total += arr[i]; sum += i * arr[i]; }
            const mean = total > 0 ? Math.round(sum / total) : 0;
            const minEl = document.getElementById('hist-min'), meanEl = document.getElementById('hist-mean'), maxEl = document.getElementById('hist-max');
            if (minEl) { minEl.textContent = `Min: ${min}`; meanEl.textContent = `Mean: ${mean}`; maxEl.textContent = `Max: ${mx}`; }
        } catch(e) {}
    },

    // ====================== COLOR WHEEL ======================
    initColorWheel() {
        const cv = document.getElementById('color-wheel');
        if (!cv) return;
        this._drawColorWheel();
        let dragging = false;
        cv.addEventListener('mousedown', e => { dragging = true; this._pickColorWheel(e); });
        cv.addEventListener('mousemove', e => { if (dragging) this._pickColorWheel(e); });
        cv.addEventListener('mouseup', () => { dragging = false; });
        cv.addEventListener('mouseleave', () => { dragging = false; });
    },
    _drawColorWheel() {
        const cv = document.getElementById('color-wheel');
        if (!cv) return;
        const ctx = cv.getContext('2d');
        const cx = 60, cy = 60, r = 58;
        for (let y = 0; y < 120; y++) {
            for (let x = 0; x < 120; x++) {
                const dx = x - cx, dy = y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > r) continue;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                const hue = (angle + 360) % 360;
                const sat = dist / r * 100;
                ctx.fillStyle = `hsl(${hue},${sat}%,50%)`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    },
    _pickColorWheel(e) {
        const cv = document.getElementById('color-wheel');
        const rect = cv.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const cx = 60, cy = 60, r = 58;
        const dx = x - cx, dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > r) return;
        const hue = ((Math.atan2(dy, dx) * 180 / Math.PI) + 360) % 360;
        const sat = Math.min(dist / r * 100, 100);
        const bri = +document.getElementById('hsb-b').value;
        document.getElementById('hsb-h').value = Math.round(hue);
        document.getElementById('hsb-s').value = Math.round(sat);
        document.getElementById('hsb-h-val').textContent = Math.round(hue);
        document.getElementById('hsb-s-val').textContent = Math.round(sat);
        document.getElementById('cw-cursor').style.left = x + 'px';
        document.getElementById('cw-cursor').style.top = y + 'px';
        this._hsbToFg();
    },
    _hsbToFg() {
        const h = +document.getElementById('hsb-h').value;
        const s = +document.getElementById('hsb-s').value;
        const b = +document.getElementById('hsb-b').value;
        document.getElementById('hsb-h-val').textContent = h;
        document.getElementById('hsb-s-val').textContent = s;
        document.getElementById('hsb-b-val').textContent = b;
        // HSB to RGB
        const sat = s / 100, val = b / 100;
        const c = val * sat, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = val - c;
        let r, g, bl;
        if (h < 60) { r = c; g = x; bl = 0; }
        else if (h < 120) { r = x; g = c; bl = 0; }
        else if (h < 180) { r = 0; g = c; bl = x; }
        else if (h < 240) { r = 0; g = x; bl = c; }
        else if (h < 300) { r = x; g = 0; bl = c; }
        else { r = c; g = 0; bl = x; }
        const hex = '#' + [Math.round((r+m)*255), Math.round((g+m)*255), Math.round((bl+m)*255)].map(v => v.toString(16).padStart(2,'0')).join('');
        this.setFgColor(hex);
    },

    // ====================== CHANNEL MIXER ======================
    showChannelMixer() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        const body = `
            <div style="font-size:11px;color:var(--text-muted);margin-bottom:6px;text-align:center">Red Output</div>
            <div class="modal-row"><label>R</label><input id="cm-rr" type="range" min="-200" max="200" value="100" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">100%</span></div>
            <div class="modal-row"><label>G</label><input id="cm-rg" type="range" min="-200" max="200" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>
            <div class="modal-row"><label>B</label><input id="cm-rb" type="range" min="-200" max="200" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>
            <div style="font-size:11px;color:var(--text-muted);margin:6px 0;text-align:center">Green Output</div>
            <div class="modal-row"><label>R</label><input id="cm-gr" type="range" min="-200" max="200" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>
            <div class="modal-row"><label>G</label><input id="cm-gg" type="range" min="-200" max="200" value="100" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">100%</span></div>
            <div class="modal-row"><label>B</label><input id="cm-gb" type="range" min="-200" max="200" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>
            <div style="font-size:11px;color:var(--text-muted);margin:6px 0;text-align:center">Blue Output</div>
            <div class="modal-row"><label>R</label><input id="cm-br" type="range" min="-200" max="200" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>
            <div class="modal-row"><label>G</label><input id="cm-bg" type="range" min="-200" max="200" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>
            <div class="modal-row"><label>B</label><input id="cm-bb" type="range" min="-200" max="200" value="100" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">100%</span></div>`;
        this._openFilterPanel('cm-dialog-overlay', 'Channel Mixer', body,
            ()=>this._removeFilterPanel('cm-dialog-overlay'),
            ()=>this._applyChannelMixer());
    },
    _applyChannelMixer() {
        const active = this.canvas.getActiveObject();
        const panel = document.getElementById('cm-dialog-overlay');
        if (!active || active.type !== 'image' || !panel) { this._removeFilterPanel('cm-dialog-overlay'); return; }
        const m = id => +(panel.querySelector('#'+id)?.value||0) / 100;
        const rr=m('cm-rr'),rg=m('cm-rg'),rb=m('cm-rb');
        const gr=m('cm-gr'),gg=m('cm-gg'),gb=m('cm-gb');
        const br=m('cm-br'),bg=m('cm-bg'),bb=m('cm-bb');
        const el = active.getElement();
        const oc = document.createElement('canvas'); oc.width = el.naturalWidth||el.width; oc.height = el.naturalHeight||el.height;
        const octx = oc.getContext('2d'); octx.drawImage(el, 0, 0);
        const imgData = octx.getImageData(0, 0, oc.width, oc.height); const d = imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const r=d[i], g=d[i+1], b=d[i+2];
            d[i]   = Math.max(0, Math.min(255, Math.round(r*rr + g*rg + b*rb)));
            d[i+1] = Math.max(0, Math.min(255, Math.round(r*gr + g*gg + b*gb)));
            d[i+2] = Math.max(0, Math.min(255, Math.round(r*br + g*bg + b*bb)));
        }
        octx.putImageData(imgData, 0, 0);
        this._replaceActiveImage(active, oc.toDataURL(), 'Channel Mixer');
        this._removeFilterPanel('cm-dialog-overlay'); this.toast('Channel mixer applied', 'success');
    },

    // ====================== PERSPECTIVE TRANSFORM ======================
    showPerspective() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Select an object first', 'info'); return; }
        const body = `<div class="modal-row"><label>Skew X</label><input id="persp-sx" type="range" min="-60" max="60" value="${Math.round(active.skewX||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.skewX||0)}&deg;</span></div>
            <div class="modal-row"><label>Skew Y</label><input id="persp-sy" type="range" min="-60" max="60" value="${Math.round(active.skewY||0)}" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">${Math.round(active.skewY||0)}&deg;</span></div>
            <div class="modal-row"><label>Scale X</label><input id="persp-scx" type="range" min="10" max="300" value="${Math.round((active.scaleX||1)*100)}" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">${Math.round((active.scaleX||1)*100)}%</span></div>
            <div class="modal-row"><label>Scale Y</label><input id="persp-scy" type="range" min="10" max="300" value="${Math.round((active.scaleY||1)*100)}" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">${Math.round((active.scaleY||1)*100)}%</span></div>
            <p style="font-size:10px;color:var(--text-muted);margin-top:4px">Use skew + scale to simulate perspective.</p>`;
        this._openFilterPanel('persp-overlay', 'Perspective', body,
            ()=>this._removeFilterPanel('persp-overlay'), ()=>this._applyPerspective());
    },
    _applyPerspective() {
        const panel = document.getElementById('persp-overlay');
        const active = this.canvas.getActiveObject(); if (!active) { this._removeFilterPanel('persp-overlay'); return; }
        active.set({
            skewX: +(panel.querySelector('#persp-sx')?.value||0),
            skewY: +(panel.querySelector('#persp-sy')?.value||0),
            scaleX: +(panel.querySelector('#persp-scx')?.value||100) / 100,
            scaleY: +(panel.querySelector('#persp-scy')?.value||100) / 100,
        });
        active.setCoords(); this.canvas.renderAll(); this.saveHistory('Perspective');
        this._removeFilterPanel('persp-overlay'); this.toast('Perspective applied', 'success');
    },

    // ====================== WATERMARK ======================
    addWatermark() {
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>Add Watermark</h3>
            <div class="modal-row"><label>Text</label><input id="wm-text" type="text" value="WATERMARK" style="flex:1;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);padding:4px 8px;font-size:12px"></div>
            <div class="modal-row"><label>Size</label><input id="wm-size" type="range" min="12" max="200" value="48" oninput="this.nextElementSibling.textContent=this.value+'px'"><span class="opt-val">48px</span></div>
            <div class="modal-row"><label>Opacity</label><input id="wm-opacity" type="range" min="5" max="100" value="30" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">30%</span></div>
            <div class="modal-row"><label>Color</label><input id="wm-color" type="color" value="#ffffff"></div>
            <div class="modal-row"><label>Rotation</label><input id="wm-angle" type="range" min="-90" max="90" value="-30" oninput="this.nextElementSibling.textContent=this.value+'&deg;'"><span class="opt-val">-30&deg;</span></div>
            <div class="modal-row"><label><input type="checkbox" id="wm-tiled"> Tiled / Repeat</label></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS._applyWatermark(this.closest('.modal-overlay'))">Apply</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    _applyWatermark(overlay) {
        const text = overlay.querySelector('#wm-text').value || 'WATERMARK';
        const size = +overlay.querySelector('#wm-size').value;
        const opacity = +overlay.querySelector('#wm-opacity').value / 100;
        const color = overlay.querySelector('#wm-color').value;
        const angle = +overlay.querySelector('#wm-angle').value;
        const tiled = overlay.querySelector('#wm-tiled').checked;
        if (tiled) {
            const spacing = size * 4;
            for (let y = -spacing; y < this.canvasH + spacing; y += spacing) {
                for (let x = -spacing; x < this.canvasW + spacing; x += spacing) {
                    const wm = new fabric.IText(text, {
                        left: x, top: y, fontSize: size, fill: color, opacity,
                        angle, fontFamily: 'DM Sans', selectable: true, evented: true,
                    });
                    this.canvas.add(wm);
                    this.layers[this.activeLayerIdx].objects.push(wm);
                }
            }
        } else {
            const wm = new fabric.IText(text, {
                left: this.canvasW / 2, top: this.canvasH / 2,
                originX: 'center', originY: 'center',
                fontSize: size, fill: color, opacity, angle,
                fontFamily: 'DM Sans', selectable: true,
            });
            this.canvas.add(wm);
            this.layers[this.activeLayerIdx].objects.push(wm);
        }
        this.canvas.renderAll(); this.saveHistory('Watermark'); this.updateLayersPanel();
        overlay.remove(); this.toast('Watermark added', 'success');
    },

    // ====================== IMAGE INFO DIALOG ======================
    showImageInfo() {
        const objs = this.canvas.getObjects().filter(o => o.name !== '__boundary__');
        const imgObjs = objs.filter(o => o.type === 'image');
        const textObjs = objs.filter(o => o.type === 'i-text' || o.type === 'text' || o.type === 'textbox');
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>Image Information</h3>
            <dl class="info-grid" style="font-size:12px">
                <dt>Canvas Size</dt><dd>${this.canvasW} x ${this.canvasH} px</dd>
                <dt>Layers</dt><dd>${this.layers.length}</dd>
                <dt>Total Objects</dt><dd>${objs.length}</dd>
                <dt>Images</dt><dd>${imgObjs.length}</dd>
                <dt>Text Objects</dt><dd>${textObjs.length}</dd>
                <dt>Shapes</dt><dd>${objs.length - imgObjs.length - textObjs.length}</dd>
                <dt>History States</dt><dd>${this.history.length} / ${this.maxHistory}</dd>
                <dt>Zoom</dt><dd>${Math.round(this.zoom * 100)}%</dd>
                <dt>Color Mode</dt><dd>RGB 8-bit</dd>
                <dt>Est. Memory</dt><dd>~${Math.round(this.canvasW * this.canvasH * 4 / 1024 / 1024)} MB (uncompressed)</dd>
            </dl>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },

    // ====================== PREFERENCES ======================
    showPreferences() {
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal" style="min-width:380px"><h3>Preferences</h3>
            <div class="pref-section">
                <h4>Canvas</h4>
                <div class="pref-row"><label>Default Width</label><input id="pref-dw" type="number" value="${this._prefs.defaultW}" min="1" max="10000"></div>
                <div class="pref-row"><label>Default Height</label><input id="pref-dh" type="number" value="${this._prefs.defaultH}" min="1" max="10000"></div>
            </div>
            <div class="pref-section">
                <h4>Grid & Snap</h4>
                <div class="pref-row"><label>Grid Size (px)</label><input id="pref-grid" type="number" value="${this.gridSize}" min="2" max="200"></div>
                <div class="pref-row"><label>Snap Tolerance</label><input id="pref-snap" type="number" value="${this._prefs.snapTolerance}" min="1" max="50"></div>
            </div>
            <div class="pref-section">
                <h4>Performance</h4>
                <div class="pref-row"><label>History States</label><input id="pref-hist" type="number" value="${this.maxHistory}" min="10" max="200"></div>
            </div>
            <div class="pref-section">
                <h4>Interface</h4>
                <div class="pref-row"><label>Accent Color</label><input id="pref-accent" type="color" value="#6c8cff"></div>
            </div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS._applyPreferences(this.closest('.modal-overlay'))">Apply</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },
    _applyPreferences(overlay) {
        this._prefs.defaultW = +overlay.querySelector('#pref-dw').value || 1920;
        this._prefs.defaultH = +overlay.querySelector('#pref-dh').value || 1080;
        this.canvasW = this._prefs.defaultW; this.canvasH = this._prefs.defaultH;
        this.gridSize = +overlay.querySelector('#pref-grid').value || 20;
        this._prefs.snapTolerance = +overlay.querySelector('#pref-snap').value || 5;
        this.maxHistory = +overlay.querySelector('#pref-hist').value || 60;
        const accent = overlay.querySelector('#pref-accent').value;
        document.documentElement.style.setProperty('--accent', accent);
        if (this.gridVisible) this.drawGrid();
        overlay.remove(); this.toast('Preferences saved', 'success');
    },

    // ====================== LAYER DRAG REORDER ======================
    initLayerDrag(layerEl, idx) {
        layerEl.setAttribute('draggable', 'true');
        layerEl.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', idx);
            layerEl.classList.add('dragging');
        });
        layerEl.addEventListener('dragend', () => layerEl.classList.remove('dragging'));
        layerEl.addEventListener('dragover', e => {
            e.preventDefault();
            const rect = layerEl.getBoundingClientRect();
            const mid = rect.top + rect.height / 2;
            layerEl.classList.remove('drop-above', 'drop-below');
            layerEl.classList.add(e.clientY < mid ? 'drop-above' : 'drop-below');
        });
        layerEl.addEventListener('dragleave', () => layerEl.classList.remove('drop-above', 'drop-below'));
        layerEl.addEventListener('drop', e => {
            e.preventDefault();
            layerEl.classList.remove('drop-above', 'drop-below');
            const fromIdx = +e.dataTransfer.getData('text/plain');
            const toIdx = idx;
            if (fromIdx === toIdx) return;
            const [moved] = this.layers.splice(fromIdx, 1);
            this.layers.splice(toIdx, 0, moved);
            if (this.activeLayerIdx === fromIdx) this.activeLayerIdx = toIdx;
            else if (fromIdx < this.activeLayerIdx && toIdx >= this.activeLayerIdx) this.activeLayerIdx--;
            else if (fromIdx > this.activeLayerIdx && toIdx <= this.activeLayerIdx) this.activeLayerIdx++;
            this.updateLayersPanel(); this.saveHistory('Reorder Layers');
            this.toast('Layer moved', 'info');
        });
    },

    // ====================== UPDATE INFO PANEL ======================
    updateInfoPanel() {
        const el = id => document.getElementById(id);
        if (el('info-dims')) el('info-dims').textContent = `${this.canvasW} x ${this.canvasH}`;
        if (el('info-layers')) el('info-layers').textContent = this.layers.length;
        if (el('info-objects')) el('info-objects').textContent = this.canvas.getObjects().filter(o => o.name !== '__boundary__').length;
        if (el('info-zoom')) el('info-zoom').textContent = Math.round(this.zoom * 100) + '%';
    },

    // ====================== PHASE 7: ADVANCED FILTERS ======================
    _getActiveImageData() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return null; }
        const el = active.getElement();
        const oc = document.createElement('canvas'); oc.width = el.naturalWidth||el.width; oc.height = el.naturalHeight||el.height;
        const ctx = oc.getContext('2d'); ctx.drawImage(el, 0, 0);
        return { active, canvas: oc, ctx, imgData: ctx.getImageData(0, 0, oc.width, oc.height) };
    },
    _commitImageData(info, name) {
        info.ctx.putImageData(info.imgData, 0, 0);
        this._replaceActiveImage(info.active, info.canvas.toDataURL(), name);
    },
    filterPosterize() {
        const body = `<div class="modal-row"><label>Levels</label><input id="fp-lvl" type="range" min="2" max="32" value="6" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">6</span></div>`;
        this._openFilterPanel('posterize-overlay', 'Posterize', body,
            ()=>this._removeFilterPanel('posterize-overlay'), ()=>this._doPosterize());
    },
    _doPosterize() {
        const panel = document.getElementById('posterize-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('posterize-overlay'); return; }
        const levels = +(panel.querySelector('#fp-lvl')?.value||6), d = info.imgData.data;
        const step = 255 / (levels - 1);
        for (let i = 0; i < d.length; i += 4) { for (let c = 0; c < 3; c++) d[i+c] = Math.round(Math.round(d[i+c] / step) * step); }
        this._commitImageData(info, 'Posterize'); this._removeFilterPanel('posterize-overlay'); this.toast('Posterize applied', 'success');
    },
    filterThreshold() {
        const body = `<div class="modal-row"><label>Level</label><input id="ft-thr" type="range" min="0" max="255" value="128" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">128</span></div>`;
        this._openFilterPanel('threshold-overlay', 'Threshold', body,
            ()=>this._removeFilterPanel('threshold-overlay'), ()=>this._doThreshold());
    },
    _doThreshold() {
        const panel = document.getElementById('threshold-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('threshold-overlay'); return; }
        const thr = +(panel.querySelector('#ft-thr')?.value||128), d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) { const l = 0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; const v = l >= thr ? 255 : 0; d[i]=d[i+1]=d[i+2]=v; }
        this._commitImageData(info, 'Threshold'); this._removeFilterPanel('threshold-overlay'); this.toast('Threshold applied', 'success');
    },
    filterSolarize() {
        const info = this._getActiveImageData(); if (!info) return;
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) { for (let c = 0; c < 3; c++) { if (d[i+c] > 128) d[i+c] = 255 - d[i+c]; } }
        this._commitImageData(info, 'Solarize'); this.toast('Solarize applied', 'success');
    },
    filterEdgeDetect() {
        const info = this._getActiveImageData(); if (!info) return;
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const src = new Uint8ClampedArray(d);
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                const idx = (y * w + x) * 4;
                for (let c = 0; c < 3; c++) {
                    const gx = -src[((y-1)*w+x-1)*4+c] + src[((y-1)*w+x+1)*4+c] - 2*src[(y*w+x-1)*4+c] + 2*src[(y*w+x+1)*4+c] - src[((y+1)*w+x-1)*4+c] + src[((y+1)*w+x+1)*4+c];
                    const gy = -src[((y-1)*w+x-1)*4+c] - 2*src[((y-1)*w+x)*4+c] - src[((y-1)*w+x+1)*4+c] + src[((y+1)*w+x-1)*4+c] + 2*src[((y+1)*w+x)*4+c] + src[((y+1)*w+x+1)*4+c];
                    d[idx+c] = Math.min(255, Math.sqrt(gx*gx + gy*gy));
                }
            }
        }
        this._commitImageData(info, 'Edge Detect'); this.toast('Edge detect applied', 'success');
    },
    filterVignette() {
        const body = `<div class="modal-row"><label>Amount</label><input id="fv-amt" type="range" min="10" max="100" value="50" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">50%</span></div><div class="modal-row"><label>Softness</label><input id="fv-soft" type="range" min="10" max="100" value="60" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">60%</span></div>`;
        this._openFilterPanel('vignette-overlay', 'Vignette', body,
            ()=>this._removeFilterPanel('vignette-overlay'), ()=>this._doVignette());
    },
    _doVignette() {
        const panel = document.getElementById('vignette-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('vignette-overlay'); return; }
        const amt = +(panel.querySelector('#fv-amt')?.value||50) / 100, soft = +(panel.querySelector('#fv-soft')?.value||60) / 100;
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const cx = w/2, cy = h/2, maxR = Math.sqrt(cx*cx + cy*cy);
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const dist = Math.sqrt((x-cx)**2 + (y-cy)**2) / maxR;
                const factor = 1 - amt * Math.pow(Math.max(0, dist - (1-soft)) / soft, 2);
                const idx = (y*w+x)*4;
                d[idx] *= factor; d[idx+1] *= factor; d[idx+2] *= factor;
            }
        }
        this._commitImageData(info, 'Vignette'); this._removeFilterPanel('vignette-overlay'); this.toast('Vignette applied', 'success');
    },
    filterUnsharpMask() {
        const body = `<div class="modal-row"><label>Amount</label><input id="fu-amt" type="range" min="10" max="300" value="100" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">100%</span></div><div class="modal-row"><label>Radius</label><input id="fu-rad" type="range" min="1" max="10" value="2" oninput="this.nextElementSibling.textContent=this.value+'px'"><span class="opt-val">2px</span></div>`;
        this._openFilterPanel('unsharpmask-overlay', 'Unsharp Mask', body,
            ()=>this._removeFilterPanel('unsharpmask-overlay'), ()=>this._doUnsharpMask());
    },
    _doUnsharpMask() {
        const panel = document.getElementById('unsharpmask-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('unsharpmask-overlay'); return; }
        const amount = +(panel.querySelector('#fu-amt')?.value||100) / 100, radius = +(panel.querySelector('#fu-rad')?.value||2);
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const blurred = new Uint8ClampedArray(d);
        const r = Math.ceil(radius);
        for (let y = r; y < h-r; y++) {
            for (let x = r; x < w-r; x++) {
                let sr=0,sg=0,sb=0,cnt=0;
                for (let dy=-r;dy<=r;dy++) for (let dx=-r;dx<=r;dx++) { const i=((y+dy)*w+x+dx)*4; sr+=d[i]; sg+=d[i+1]; sb+=d[i+2]; cnt++; }
                const i=(y*w+x)*4; blurred[i]=sr/cnt; blurred[i+1]=sg/cnt; blurred[i+2]=sb/cnt;
            }
        }
        for (let i = 0; i < d.length; i += 4) {
            for (let c = 0; c < 3; c++) d[i+c] = Math.max(0, Math.min(255, Math.round(d[i+c] + amount * (d[i+c] - blurred[i+c]))));
        }
        this._commitImageData(info, 'Unsharp Mask'); this._removeFilterPanel('unsharpmask-overlay'); this.toast('Unsharp mask applied', 'success');
    },
    filterOilPaint() {
        const body = `<div class="modal-row"><label>Radius</label><input id="fo-rad" type="range" min="1" max="6" value="3" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">3</span></div><div class="modal-row"><label>Levels</label><input id="fo-lvl" type="range" min="4" max="32" value="16" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">16</span></div>`;
        this._openFilterPanel('oilpaint-overlay', 'Oil Paint', body,
            ()=>this._removeFilterPanel('oilpaint-overlay'), ()=>this._doOilPaint());
    },
    _doOilPaint() {
        const panel = document.getElementById('oilpaint-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('oilpaint-overlay'); return; }
        const radius = +(panel.querySelector('#fo-rad')?.value||3), levels = +(panel.querySelector('#fo-lvl')?.value||16);
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const src = new Uint8ClampedArray(d);
        for (let y = radius; y < h-radius; y++) {
            for (let x = radius; x < w-radius; x++) {
                const bins = new Array(levels).fill(0); const sr = new Array(levels).fill(0); const sg = new Array(levels).fill(0); const sb = new Array(levels).fill(0);
                for (let dy=-radius;dy<=radius;dy++) for (let dx=-radius;dx<=radius;dx++) {
                    const i=((y+dy)*w+x+dx)*4; const l=Math.round((src[i]+src[i+1]+src[i+2])/3/(256/levels));
                    const b=Math.min(l,levels-1); bins[b]++; sr[b]+=src[i]; sg[b]+=src[i+1]; sb[b]+=src[i+2];
                }
                let maxBin=0,maxCount=0; for(let b=0;b<levels;b++){if(bins[b]>maxCount){maxCount=bins[b];maxBin=b;}}
                const i=(y*w+x)*4; d[i]=sr[maxBin]/maxCount; d[i+1]=sg[maxBin]/maxCount; d[i+2]=sb[maxBin]/maxCount;
            }
        }
        this._commitImageData(info, 'Oil Paint'); this._removeFilterPanel('oilpaint-overlay'); this.toast('Oil paint applied', 'success');
    },
    filterHalftone() {
        const body = `<div class="modal-row"><label>Dot Size</label><input id="fh-size" type="range" min="2" max="16" value="6" oninput="this.nextElementSibling.textContent=this.value+'px'"><span class="opt-val">6px</span></div>`;
        this._openFilterPanel('halftone-overlay', 'Halftone', body,
            ()=>this._removeFilterPanel('halftone-overlay'), ()=>this._doHalftone());
    },
    _doHalftone() {
        const panel = document.getElementById('halftone-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('halftone-overlay'); return; }
        const size = +(panel.querySelector('#fh-size')?.value||6);
        const w = info.canvas.width, h = info.canvas.height;
        const ctx = info.ctx; ctx.putImageData(info.imgData, 0, 0);
        const src = ctx.getImageData(0, 0, w, h).data;
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = '#000';
        for (let y = 0; y < h; y += size) {
            for (let x = 0; x < w; x += size) {
                let sum = 0, cnt = 0;
                for (let dy=0;dy<size&&y+dy<h;dy++) for (let dx=0;dx<size&&x+dx<w;dx++) {
                    const i=((y+dy)*w+x+dx)*4; sum+=(src[i]+src[i+1]+src[i+2])/3; cnt++;
                }
                const avg = sum / cnt; const r = size * (1 - avg / 255) / 2;
                if (r > 0.3) { ctx.beginPath(); ctx.arc(x+size/2, y+size/2, r, 0, Math.PI*2); ctx.fill(); }
            }
        }
        info.imgData = ctx.getImageData(0, 0, w, h);
        this._commitImageData(info, 'Halftone'); this._removeFilterPanel('halftone-overlay'); this.toast('Halftone applied', 'success');
    },
    filterDuotone() {
        const body = `<div class="modal-row"><label>Shadow</label><input id="fd-shadow" type="color" value="#1a1a2e"></div><div class="modal-row"><label>Highlight</label><input id="fd-high" type="color" value="#e94560"></div>`;
        this._openFilterPanel('duotone-overlay', 'Duotone', body,
            ()=>this._removeFilterPanel('duotone-overlay'), ()=>this._doDuotone());
    },
    _doDuotone() {
        const panel = document.getElementById('duotone-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('duotone-overlay'); return; }
        const sc = panel.querySelector('#fd-shadow')?.value||'#1a1a2e', hc = panel.querySelector('#fd-high')?.value||'#e94560';
        const sr=parseInt(sc.slice(1,3),16),sg=parseInt(sc.slice(3,5),16),sb=parseInt(sc.slice(5,7),16);
        const hr=parseInt(hc.slice(1,3),16),hg=parseInt(hc.slice(3,5),16),hb=parseInt(hc.slice(5,7),16);
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const l = (0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])/255;
            d[i]=Math.round(sr+(hr-sr)*l); d[i+1]=Math.round(sg+(hg-sg)*l); d[i+2]=Math.round(sb+(hb-sb)*l);
        }
        this._commitImageData(info, 'Duotone'); this._removeFilterPanel('duotone-overlay'); this.toast('Duotone applied', 'success');
    },
    filterTiltShift() {
        const body = `<div class="modal-row"><label>Focus Y</label><input id="fts-y" type="range" min="0" max="100" value="50" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">50%</span></div><div class="modal-row"><label>Focus Width</label><input id="fts-w" type="range" min="5" max="60" value="20" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">20%</span></div><div class="modal-row"><label>Blur</label><input id="fts-blur" type="range" min="1" max="10" value="4" oninput="this.nextElementSibling.textContent=this.value+'px'"><span class="opt-val">4px</span></div>`;
        this._openFilterPanel('tiltshift-overlay', 'Tilt Shift', body,
            ()=>this._removeFilterPanel('tiltshift-overlay'), ()=>this._doTiltShift());
    },
    _doTiltShift() {
        const panel = document.getElementById('tiltshift-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('tiltshift-overlay'); return; }
        const focusY = +(panel.querySelector('#fts-y')?.value||50)/100, focusW = +(panel.querySelector('#fts-w')?.value||20)/100, blurR = +(panel.querySelector('#fts-blur')?.value||4);
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const src = new Uint8ClampedArray(d);
        for (let y = 0; y < h; y++) {
            const ny = y / h, dist = Math.abs(ny - focusY);
            const blurAmt = Math.max(0, (dist - focusW/2) / (0.5 - focusW/2));
            const r = Math.round(blurAmt * blurR);
            if (r < 1) continue;
            for (let x = 0; x < w; x++) {
                let sr=0,sg=0,sb=0,cnt=0;
                for (let dy=-r;dy<=r;dy++) for (let dx=-r;dx<=r;dx++) {
                    const sy=Math.max(0,Math.min(h-1,y+dy)), sx=Math.max(0,Math.min(w-1,x+dx));
                    const i=(sy*w+sx)*4; sr+=src[i]; sg+=src[i+1]; sb+=src[i+2]; cnt++;
                }
                const i=(y*w+x)*4; d[i]=sr/cnt; d[i+1]=sg/cnt; d[i+2]=sb/cnt;
            }
        }
        this._commitImageData(info, 'Tilt Shift'); this._removeFilterPanel('tiltshift-overlay'); this.toast('Tilt shift applied', 'success');
    },
    filterChromaticAberration() {
        const body = `<div class="modal-row"><label>Offset</label><input id="fca-off" type="range" min="1" max="15" value="4" oninput="this.nextElementSibling.textContent=this.value+'px'"><span class="opt-val">4px</span></div>`;
        this._openFilterPanel('chromab-overlay', 'Chromatic Aberration', body,
            ()=>this._removeFilterPanel('chromab-overlay'), ()=>this._doChromaticAberration());
    },
    _doChromaticAberration() {
        const panel = document.getElementById('chromab-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('chromab-overlay'); return; }
        const off = +(panel.querySelector('#fca-off')?.value||4);
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const src = new Uint8ClampedArray(d);
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const i = (y*w+x)*4;
                const rx = Math.min(w-1, x+off), bx = Math.max(0, x-off);
                d[i] = src[(y*w+rx)*4];
                d[i+2] = src[(y*w+bx)*4+2];
            }
        }
        this._commitImageData(info, 'Chromatic Aberration'); this._removeFilterPanel('chromab-overlay'); this.toast('Chromatic aberration applied', 'success');
    },
    filterNoiseGen() {
        const body = `<div class="modal-row"><label>Type</label><select id="fn-type"><option value="uniform">Uniform</option><option value="gaussian">Gaussian</option><option value="salt-pepper">Salt & Pepper</option></select></div><div class="modal-row"><label>Amount</label><input id="fn-amt" type="range" min="1" max="100" value="30" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">30%</span></div><div class="modal-row"><label><input type="checkbox" id="fn-mono" checked> Monochrome</label></div>`;
        this._openFilterPanel('noisegen-overlay', 'Generate Noise', body,
            ()=>this._removeFilterPanel('noisegen-overlay'), ()=>this._doNoiseGen());
    },
    _doNoiseGen() {
        const panel = document.getElementById('noisegen-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('noisegen-overlay'); return; }
        const type = panel.querySelector('#fn-type')?.value||'uniform';
        const amt = +(panel.querySelector('#fn-amt')?.value||30) / 100;
        const mono = panel.querySelector('#fn-mono')?.checked ?? true;
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            if (type === 'salt-pepper') {
                if (Math.random() < amt * 0.1) { const v = Math.random() > 0.5 ? 255 : 0; d[i]=d[i+1]=d[i+2]=v; }
            } else {
                const strength = amt * 128;
                if (mono) {
                    const n = type === 'gaussian' ? (Math.random()+Math.random()+Math.random()-1.5)*strength : (Math.random()-0.5)*2*strength;
                    d[i]+=n; d[i+1]+=n; d[i+2]+=n;
                } else {
                    for (let c=0;c<3;c++) {
                        const n = type === 'gaussian' ? (Math.random()+Math.random()+Math.random()-1.5)*strength : (Math.random()-0.5)*2*strength;
                        d[i+c] = Math.max(0, Math.min(255, d[i+c]+n));
                    }
                }
            }
        }
        this._commitImageData(info, 'Noise'); this._removeFilterPanel('noisegen-overlay'); this.toast('Noise applied', 'success');
    },

    // ====================== GRADIENT MAP ======================
    showGradientMap() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first', 'info'); return; }
        const body = `<div class="gm-preview" id="gm-preview" style="background:linear-gradient(to right,#000,#6c8cff,#fff)"></div>
            <div class="modal-row"><label>Shadow</label><input id="gm-c1" type="color" value="#000000" onchange="OS._updateGMPreview()"></div>
            <div class="modal-row"><label>Midtone</label><input id="gm-c2" type="color" value="#6c8cff" onchange="OS._updateGMPreview()"></div>
            <div class="modal-row"><label>Highlight</label><input id="gm-c3" type="color" value="#ffffff" onchange="OS._updateGMPreview()"></div>`;
        this._openFilterPanel('gradmap-overlay', 'Gradient Map', body,
            ()=>this._removeFilterPanel('gradmap-overlay'), ()=>this._applyGradientMap());
    },
    _updateGMPreview() {
        const c1=document.getElementById('gm-c1').value,c2=document.getElementById('gm-c2').value,c3=document.getElementById('gm-c3').value;
        document.getElementById('gm-preview').style.background=`linear-gradient(to right,${c1},${c2},${c3})`;
    },
    _applyGradientMap() {
        const panel = document.getElementById('gradmap-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('gradmap-overlay'); return; }
        const parse = hex => [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)];
        const c1=parse(panel.querySelector('#gm-c1')?.value||'#000000'), c2=parse(panel.querySelector('#gm-c2')?.value||'#6c8cff'), c3=parse(panel.querySelector('#gm-c3')?.value||'#ffffff');
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const l = (0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])/255;
            let r,g,b;
            if (l < 0.5) { const t = l*2; r=c1[0]+(c2[0]-c1[0])*t; g=c1[1]+(c2[1]-c1[1])*t; b=c1[2]+(c2[2]-c1[2])*t; }
            else { const t=(l-0.5)*2; r=c2[0]+(c3[0]-c2[0])*t; g=c2[1]+(c3[1]-c2[1])*t; b=c2[2]+(c3[2]-c2[2])*t; }
            d[i]=Math.round(r); d[i+1]=Math.round(g); d[i+2]=Math.round(b);
        }
        this._commitImageData(info, 'Gradient Map'); this._removeFilterPanel('gradmap-overlay'); this.toast('Gradient map applied', 'success');
    },

    // ====================== LAYER STYLES ======================
    previewLayerStyle() {
        const active = this.canvas.getActiveObject(); if (!active) return;
        const dsX = +document.getElementById('ls-ds-x').value, dsY = +document.getElementById('ls-ds-y').value;
        const dsBlur = +document.getElementById('ls-ds-blur').value, dsColor = document.getElementById('ls-ds-color').value;
        const ogSize = +document.getElementById('ls-og-size').value, ogColor = document.getElementById('ls-og-color').value;
        const stW = +document.getElementById('ls-st-w').value, stColor = document.getElementById('ls-st-color').value;
        // Drop shadow via fabric shadow
        if (dsBlur > 0 || dsX !== 0 || dsY !== 0) {
            active.set('shadow', new fabric.Shadow({ color: dsColor, offsetX: dsX, offsetY: dsY, blur: dsBlur }));
        }
        // Outer glow via secondary shadow
        if (ogSize > 0) {
            active.set('shadow', new fabric.Shadow({ color: ogColor, offsetX: 0, offsetY: 0, blur: ogSize }));
        }
        // Stroke
        if (stW > 0) { active.set({ stroke: stColor, strokeWidth: stW, paintFirst: 'stroke' }); }
        else { active.set({ stroke: null, strokeWidth: 0 }); }
        this.canvas.renderAll();
    },
    applyLayerStyle() {
        this.previewLayerStyle();
        this.saveHistory('Layer Style');
        this.toast('Layer style applied', 'success');
    },
    clearLayerStyle() {
        const active = this.canvas.getActiveObject(); if (!active) return;
        active.set({ shadow: null, stroke: null, strokeWidth: 0 });
        this.canvas.renderAll(); this.saveHistory('Clear Layer Style');
        this.toast('Layer style cleared', 'info');
    },

    // ====================== EXPORT SETTINGS ======================
    showExportSettings() {
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal" style="min-width:380px"><h3>Export Settings</h3>
            <div class="export-format-row">
                <button class="btn active" id="es-png" onclick="OS._esFormat('png',this)">PNG</button>
                <button class="btn" id="es-jpeg" onclick="OS._esFormat('jpeg',this)">JPEG</button>
                <button class="btn" id="es-webp" onclick="OS._esFormat('webp',this)">WebP</button>
            </div>
            <div class="modal-row" id="es-quality-row" style="display:none"><label>Quality</label><input id="es-quality" type="range" min="1" max="100" value="92" oninput="this.nextElementSibling.textContent=this.value+'%';OS._esUpdateSize()"><span class="opt-val">92%</span></div>
            <div class="modal-row"><label>Scale</label><select id="es-scale"><option value="1">1x (Original)</option><option value="0.5">0.5x (Half)</option><option value="2">2x (Double)</option><option value="0.25">0.25x (Quarter)</option></select></div>
            <div class="modal-row"><label><input type="checkbox" id="es-transparent"> Transparent Background</label></div>
            <div class="export-size-est" id="es-size">Est. size: calculating...</div>
            <div class="export-preview" id="es-preview"></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="btn btn-primary" onclick="OS._doExportSettings(this.closest('.modal-overlay'))">Export</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => { o.classList.add('show'); this._esUpdateSize(); });
    },
    _esFormat(fmt, btn) {
        btn.parentElement.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('es-quality-row').style.display = fmt === 'png' ? 'none' : 'flex';
        this._esUpdateSize();
    },
    _esUpdateSize() {
        const fmt = document.querySelector('.export-format-row .btn.active')?.textContent?.toLowerCase() || 'png';
        const scale = +document.getElementById('es-scale')?.value || 1;
        const w = Math.round(this.canvasW * scale), h = Math.round(this.canvasH * scale);
        const bpp = fmt === 'png' ? 4 : 3;
        const raw = w * h * bpp;
        const ratio = fmt === 'png' ? 0.5 : fmt === 'jpeg' ? 0.1 : 0.08;
        const est = Math.round(raw * ratio / 1024);
        const el = document.getElementById('es-size');
        if (el) el.textContent = `${w}x${h} — Est. ~${est > 1024 ? (est/1024).toFixed(1)+'MB' : est+'KB'}`;
    },
    _doExportSettings(overlay) {
        const fmt = document.querySelector('.export-format-row .btn.active')?.textContent?.toLowerCase() || 'png';
        const quality = (+document.getElementById('es-quality').value || 92) / 100;
        const scale = +document.getElementById('es-scale').value || 1;
        const transparent = document.getElementById('es-transparent').checked;
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
        const opts = { format: fmt, left: 0, top: 0, width: this.canvasW, height: this.canvasH, multiplier: scale };
        if (fmt !== 'png') opts.quality = quality;
        const dataUrl = this.canvas.toDataURL(opts);
        this.canvas.viewportTransform = vpt; this.canvas.renderAll();
        const link = document.createElement('a'); link.download = `openshop-export.${fmt==='jpeg'?'jpg':fmt}`;
        link.href = dataUrl; link.click();
        overlay.remove(); this.toast(`Exported ${fmt.toUpperCase()} @ ${Math.round(scale*100)}%`, 'success');
    },

    // ====================== BEFORE / AFTER COMPARE ======================
    _captureBA() {
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0];
        const boundary = this.canvas.getObjects().find(o => o.name === '__boundary__');
        if (boundary) boundary.set('opacity', 0);
        this.canvas.renderAll();
        this._baSnapshot = this.canvas.toDataURL({ format:'png', left:0, top:0, width:this.canvasW, height:this.canvasH });
        if (boundary) boundary.set('opacity', 1);
        this.canvas.viewportTransform = vpt; this.canvas.renderAll();
    },
    showBeforeAfter() {
        if (!this._baSnapshot) { this._captureBA(); }
        if (!this._baSnapshot) { this.toast('Could not capture state', 'error'); return; }
        const overlay = document.getElementById('ba-overlay');
        overlay.classList.add('visible');
        const container = document.getElementById('ba-container');
        const cw = container.clientWidth, ch = container.clientHeight;
        // Before canvas
        const bcv = document.getElementById('ba-before');
        bcv.width = cw; bcv.height = ch;
        const bctx = bcv.getContext('2d');
        const beforeImg = new Image(); beforeImg.onload = () => {
            const scale = Math.min(cw / this.canvasW, ch / this.canvasH);
            const dx = (cw - this.canvasW * scale) / 2, dy = (ch - this.canvasH * scale) / 2;
            bctx.fillStyle = '#1a1a1a'; bctx.fillRect(0, 0, cw, ch);
            bctx.drawImage(beforeImg, dx, dy, this.canvasW * scale, this.canvasH * scale);
        }; beforeImg.src = this._baSnapshot;
        // After canvas
        const acv = document.getElementById('ba-after');
        acv.width = cw; acv.height = ch;
        const actx = acv.getContext('2d');
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
        const afterData = this.canvas.toDataURL({ format:'png', left:0, top:0, width:this.canvasW, height:this.canvasH });
        this.canvas.viewportTransform = vpt; this.canvas.renderAll();
        const afterImg = new Image(); afterImg.onload = () => {
            const scale = Math.min(cw / this.canvasW, ch / this.canvasH);
            const dx = (cw - this.canvasW * scale) / 2, dy = (ch - this.canvasH * scale) / 2;
            actx.fillStyle = '#1a1a1a'; actx.fillRect(0, 0, cw, ch);
            actx.drawImage(afterImg, dx, dy, this.canvasW * scale, this.canvasH * scale);
        }; afterImg.src = afterData;
        // Divider drag
        const divider = document.getElementById('ba-divider');
        divider.style.left = '50%';
        acv.style.clipPath = `inset(0 0 0 50%)`;
        let dragging = false;
        const onMove = e => {
            if (!dragging) return;
            const rect = container.getBoundingClientRect();
            const x = Math.max(0, Math.min(cw, e.clientX - rect.left));
            const pct = (x / cw * 100);
            divider.style.left = pct + '%';
            acv.style.clipPath = `inset(0 0 0 ${pct}%)`;
        };
        divider.onmousedown = () => { dragging = true; };
        container.onmousemove = onMove;
        container.onmouseup = () => { dragging = false; };
    },
    closeBeforeAfter() {
        document.getElementById('ba-overlay').classList.remove('visible');
    },

    // ====================== CANVAS ROTATE / FLIP ======================
    canvasRotate(deg) {
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0];
        const boundary = this.canvas.getObjects().find(o => o.name === '__boundary__');
        if (boundary) boundary.set('opacity', 0);
        this.canvas.renderAll();
        const data = this.canvas.toDataURL({ format:'png', left:0, top:0, width:this.canvasW, height:this.canvasH });
        if (boundary) boundary.set('opacity', 1);
        this.canvas.viewportTransform = vpt;
        const img = new Image(); img.onload = () => {
            const nw = deg === 90 || deg === -90 ? this.canvasH : this.canvasW;
            const nh = deg === 90 || deg === -90 ? this.canvasW : this.canvasH;
            const oc = document.createElement('canvas'); oc.width = nw; oc.height = nh;
            const ctx = oc.getContext('2d');
            ctx.translate(nw/2, nh/2);
            ctx.rotate(deg * Math.PI / 180);
            ctx.drawImage(img, -this.canvasW/2, -this.canvasH/2);
            this.createNewDocument(nw, nh);
            fabric.Image.fromURL(oc.toDataURL(), fImg => {
                fImg.set({ left: 0, top: 0, selectable: true });
                this.canvas.add(fImg);
                this.layers[this.activeLayerIdx].objects.push(fImg);
                this.canvas.renderAll(); this.zoomFit(); this.saveHistory('Rotate Canvas ' + deg);
                this.updateLayersPanel();
            });
        }; img.src = data;
        this.toast(`Canvas rotated ${deg > 0 ? 'CW' : 'CCW'}`, 'success');
    },
    canvasFlip(dir) {
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0];
        const boundary = this.canvas.getObjects().find(o => o.name === '__boundary__');
        if (boundary) boundary.set('opacity', 0);
        this.canvas.renderAll();
        const data = this.canvas.toDataURL({ format:'png', left:0, top:0, width:this.canvasW, height:this.canvasH });
        if (boundary) boundary.set('opacity', 1);
        this.canvas.viewportTransform = vpt;
        const img = new Image(); img.onload = () => {
            const oc = document.createElement('canvas'); oc.width = this.canvasW; oc.height = this.canvasH;
            const ctx = oc.getContext('2d');
            if (dir === 'h') { ctx.translate(this.canvasW, 0); ctx.scale(-1, 1); }
            else { ctx.translate(0, this.canvasH); ctx.scale(1, -1); }
            ctx.drawImage(img, 0, 0);
            this.createNewDocument(this.canvasW, this.canvasH);
            fabric.Image.fromURL(oc.toDataURL(), fImg => {
                fImg.set({ left: 0, top: 0, selectable: true });
                this.canvas.add(fImg);
                this.layers[this.activeLayerIdx].objects.push(fImg);
                this.canvas.renderAll(); this.zoomFit(); this.saveHistory('Flip Canvas ' + dir);
                this.updateLayersPanel();
            });
        }; img.src = data;
        this.toast(`Canvas flipped ${dir === 'h' ? 'horizontally' : 'vertically'}`, 'success');
    },

    // ====================== PHASE 8: COMMAND PALETTE ======================
    _commands: null,
    _getCommands() {
        if (this._commands) return this._commands;
        this._commands = [
            {label:'New Document',cat:'File',fn:()=>this.newImage(),key:'Ctrl+N'},
            {label:'Open Image',cat:'File',fn:()=>this.openFile()},
            {label:'Open PSD',cat:'File',fn:()=>this.openPSD()},
            {label:'Export PNG',cat:'File',fn:()=>this.saveFile('png'),key:'Ctrl+Shift+P'},
            {label:'Export JPEG',cat:'File',fn:()=>this.saveFile('jpeg')},
            {label:'Export WebP',cat:'File',fn:()=>this.saveFile('webp')},
            {label:'Export SVG',cat:'File',fn:()=>this.saveFile('svg')},
            {label:'Export PDF',cat:'File',fn:()=>this.exportPDF()},
            {label:'Export Settings',cat:'File',fn:()=>this.showExportSettings()},
            {label:'Save Project',cat:'File',fn:()=>this.saveProject()},
            {label:'Open Project',cat:'File',fn:()=>this.openProject()},
            {label:'Templates',cat:'File',fn:()=>this.showTemplates()},
            {label:'Undo',cat:'Edit',fn:()=>this.undo(),key:'Ctrl+Z'},
            {label:'Redo',cat:'Edit',fn:()=>this.redo(),key:'Ctrl+Shift+Z'},
            {label:'Copy',cat:'Edit',fn:()=>this.copyObj(),key:'Ctrl+C'},
            {label:'Paste',cat:'Edit',fn:()=>this.pasteObj(),key:'Ctrl+V'},
            {label:'Duplicate',cat:'Edit',fn:()=>this.duplicateSelected(),key:'Ctrl+J'},
            {label:'Delete',cat:'Edit',fn:()=>this.deleteSelected(),key:'Del'},
            {label:'Select All',cat:'Select',fn:()=>this.selectAll(),key:'Ctrl+A'},
            {label:'Deselect',cat:'Select',fn:()=>this.deselectAll(),key:'Ctrl+D'},
            {label:'Reselect',cat:'Select',fn:()=>this.reselectSelection(),key:'Ctrl+Shift+D'},
            {label:'Inverse Selection',cat:'Select',fn:()=>this.invertSelection(),key:'Ctrl+Shift+I'},
            {label:'Color Range...',cat:'Select',fn:()=>this.showColorRange()},
            {label:'Grow Selection',cat:'Select',fn:()=>this.growSelection()},
            {label:'Similar',cat:'Select',fn:()=>this.similarSelection()},
            {label:'Expand Selection...',cat:'Select',fn:()=>this.modifySelection('expand')},
            {label:'Contract Selection...',cat:'Select',fn:()=>this.modifySelection('contract')},
            {label:'Feather Selection...',cat:'Select',fn:()=>this.modifySelection('feather')},
            {label:'Smooth Selection',cat:'Select',fn:()=>this.modifySelection('smooth')},
            {label:'Free Transform',cat:'Edit',fn:()=>this.showFreeTransform(),key:'Ctrl+T'},
            {label:'Preferences',cat:'Edit',fn:()=>this.showPreferences()},
            {label:'Resize Canvas',cat:'Image',fn:()=>this.showResize()},
            {label:'Flip Horizontal',cat:'Image',fn:()=>this.flipH()},
            {label:'Flip Vertical',cat:'Image',fn:()=>this.flipV()},
            {label:'Rotate 90 CW',cat:'Image',fn:()=>this.rotateObj(90)},
            {label:'Rotate 90 CCW',cat:'Image',fn:()=>this.rotateObj(-90)},
            {label:'Flatten Image',cat:'Image',fn:()=>this.flattenImage()},
            {label:'Canvas Rotate CW',cat:'Image',fn:()=>this.canvasRotate(90)},
            {label:'Canvas Rotate CCW',cat:'Image',fn:()=>this.canvasRotate(-90)},
            {label:'Add Watermark',cat:'Image',fn:()=>this.addWatermark()},
            {label:'Image Info',cat:'Image',fn:()=>this.showImageInfo()},
            {label:'Before / After',cat:'Image',fn:()=>this.showBeforeAfter()},
            {label:'Grayscale',cat:'Filter',fn:()=>this.applyFilter('Grayscale')},
            {label:'Invert',cat:'Filter',fn:()=>this.applyFilter('Invert')},
            {label:'Sepia',cat:'Filter',fn:()=>this.applyFilter('Sepia')},
            {label:'B&W',cat:'Filter',fn:()=>this.applyFilter('Black & White')},
            {label:'Posterize',cat:'Filter',fn:()=>this.filterPosterize()},
            {label:'Threshold',cat:'Filter',fn:()=>this.filterThreshold()},
            {label:'Solarize',cat:'Filter',fn:()=>this.filterSolarize()},
            {label:'Edge Detect',cat:'Filter',fn:()=>this.filterEdgeDetect()},
            {label:'Vignette',cat:'Filter',fn:()=>this.filterVignette()},
            {label:'Unsharp Mask',cat:'Filter',fn:()=>this.filterUnsharpMask()},
            {label:'Oil Paint',cat:'Filter',fn:()=>this.filterOilPaint()},
            {label:'Halftone',cat:'Filter',fn:()=>this.filterHalftone()},
            {label:'Duotone',cat:'Filter',fn:()=>this.filterDuotone()},
            {label:'Tilt Shift',cat:'Filter',fn:()=>this.filterTiltShift()},
            {label:'Chromatic Aberration',cat:'Filter',fn:()=>this.filterChromaticAberration()},
            {label:'Generate Noise',cat:'Filter',fn:()=>this.filterNoiseGen()},
            {label:'Gradient Map',cat:'Filter',fn:()=>this.showGradientMap()},
            {label:'Curves',cat:'Filter',fn:()=>this.showCurvesDialog()},
            {label:'Levels',cat:'Filter',fn:()=>this.showLevelsDialog()},
            {label:'Color Balance',cat:'Filter',fn:()=>this.showColorBalanceDialog()},
            {label:'Channel Mixer',cat:'Filter',fn:()=>this.showChannelMixer()},
            {label:'Auto Levels',cat:'Filter',fn:()=>this.autoLevels()},
            {label:'Auto Contrast',cat:'Filter',fn:()=>this.autoContrast()},
            {label:'Vibrance',cat:'Filter',fn:()=>this.adjVibrance()},
            {label:'Exposure',cat:'Filter',fn:()=>this.adjExposure()},
            {label:'Shadows/Highlights',cat:'Filter',fn:()=>this.adjShadowsHighlights()},
            {label:'Photo Filter',cat:'Filter',fn:()=>this.adjPhotoFilter()},
            {label:'Selective Color',cat:'Filter',fn:()=>this.adjSelectiveColor()},
            {label:'Replace Color',cat:'Filter',fn:()=>this.adjReplaceColor()},
            {label:'Lens Correction',cat:'Filter',fn:()=>this.adjLensCorrection()},
            {label:'Liquify',cat:'Edit',fn:()=>this.showLiquify()},
            {label:'AI Background Remove',cat:'AI',fn:()=>this.aiRemoveBackground()},
            {label:'AI Depth Map',cat:'AI',fn:()=>this.aiDepthMap()},
            {label:'AI Object Detection',cat:'AI',fn:()=>this.aiObjectDetect()},
            {label:'AI Smart Upscale 2x',cat:'AI',fn:()=>this.aiUpscale(2)},
            {label:'AI Smart Upscale 4x',cat:'AI',fn:()=>this.aiUpscale(4)},
            {label:'Curved Text',cat:'Edit',fn:()=>this.showCurvedText()},
            {label:'Animation Timeline',cat:'View',fn:()=>this.toggleTimeline()},
            {label:'Actions / Macros',cat:'View',fn:()=>this.toggleMacroPanel()},
            {label:'Pixel Grid',cat:'View',fn:()=>this.togglePixelGrid()},
            {label:'Toggle Grid',cat:'View',fn:()=>this.toggleGrid(),key:'Ctrl+G'},
            {label:'Toggle Rulers',cat:'View',fn:()=>this.toggleRulers()},
            {label:'Toggle Snap',cat:'View',fn:()=>this.toggleSnap()},
            {label:'Fullscreen',cat:'View',fn:()=>this.toggleFullscreen(),key:'F11'},
            {label:'Zoom In',cat:'View',fn:()=>this.zoomIn(),key:'Ctrl++'},
            {label:'Zoom Out',cat:'View',fn:()=>this.zoomOut(),key:'Ctrl+-'},
            {label:'Zoom Fit',cat:'View',fn:()=>this.zoomFit(),key:'Ctrl+0'},
            {label:'Keyboard Shortcuts',cat:'View',fn:()=>this.showShortcuts()},
            {label:'Theme: Dark',cat:'View',fn:()=>this.setTheme('default')},
            {label:'Theme: Midnight',cat:'View',fn:()=>this.setTheme('midnight')},
            {label:'Theme: OLED',cat:'View',fn:()=>this.setTheme('oled')},
            {label:'Add Layer',cat:'Layer',fn:()=>this.addLayer()},
            {label:'Delete Layer',cat:'Layer',fn:()=>this.deleteLayer()},
            {label:'Duplicate Layer',cat:'Layer',fn:()=>this.duplicateLayer()},
            {label:'Merge Down',cat:'Layer',fn:()=>this.mergeDown()},
            // Tools
            ...['select','marquee-rect','marquee-ellipse','wand','lasso','brush','eraser','pencil','spray',
                'clone','healing','line','rect','circle','triangle','arrow','polygon','star','pen',
                'text','gradient','pattern','fill','eyedropper','measure','note','crop','pan','zoom'
            ].map(t => ({label:'Tool: '+t.charAt(0).toUpperCase()+t.slice(1).replace(/-/g,' '),cat:'Tool',fn:()=>this.setTool(t)})),
        ];
        return this._commands;
    },
    initCmdPalette() {
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') { e.preventDefault(); this.toggleCmdPalette(); }
            if (e.key === 'Escape') {
                this.closeCmdPalette();
                const ctx = document.getElementById('context-menu'); if (ctx) ctx.classList.remove('visible');
            }
        });
    },
    toggleCmdPalette() {
        const el = document.getElementById('cmd-palette');
        if (el.classList.contains('visible')) { this.closeCmdPalette(); return; }
        el.classList.add('visible');
        const input = document.getElementById('cmd-input');
        input.value = ''; input.focus();
        this._cmdIdx = 0;
        this.filterCommands('');
    },
    closeCmdPalette() {
        document.getElementById('cmd-palette').classList.remove('visible');
    },
    filterCommands(q) {
        const results = document.getElementById('cmd-results');
        const cmds = this._getCommands();
        const lower = q.toLowerCase();
        const filtered = lower ? cmds.filter(c => c.label.toLowerCase().includes(lower) || c.cat.toLowerCase().includes(lower)) : cmds.slice(0, 20);
        this._cmdIdx = 0;
        results.innerHTML = filtered.slice(0, 20).map((c, i) =>
            `<div class="cmd-item${i===0?' active':''}" onmouseenter="OS._cmdHover(${i})" onclick="OS._cmdExec(${i})">
                <span class="cmd-label">${c.label}</span>
                ${c.key ? `<span class="cmd-shortcut">${c.key}</span>` : ''}
                <span class="cmd-cat">${c.cat}</span>
            </div>`
        ).join('');
        this._cmdFiltered = filtered.slice(0, 20);
    },
    _cmdHover(i) {
        this._cmdIdx = i;
        document.querySelectorAll('#cmd-results .cmd-item').forEach((el, j) => el.classList.toggle('active', j === i));
    },
    cmdKeyDown(e) {
        const items = document.querySelectorAll('#cmd-results .cmd-item');
        if (e.key === 'ArrowDown') { e.preventDefault(); this._cmdIdx = Math.min(this._cmdIdx + 1, items.length - 1); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); this._cmdIdx = Math.max(this._cmdIdx - 1, 0); }
        else if (e.key === 'Enter') { e.preventDefault(); this._cmdExec(this._cmdIdx); return; }
        else return;
        items.forEach((el, j) => el.classList.toggle('active', j === this._cmdIdx));
        items[this._cmdIdx]?.scrollIntoView({ block: 'nearest' });
    },
    _cmdExec(i) {
        if (this._cmdFiltered && this._cmdFiltered[i]) {
            this._cmdFiltered[i].fn();
            this.closeCmdPalette();
        }
    },

    // ====================== CONTEXT MENU ======================
    initContextMenu() {
        const ca = document.getElementById('canvas-area');
        ca.addEventListener('contextmenu', e => {
            e.preventDefault();
            const menu = document.getElementById('context-menu');
            const active = this.canvas.getActiveObject();
            const hasSelection = this._selectionMask || this._selectionPath;
            let items = [];

            if (active) {
                // Object selected — object operations
                items.push({label:'Cut',fn:()=>{this.copyObj();this.deleteSelected();},key:'Ctrl+X'});
                items.push({label:'Copy',fn:()=>this.copyObj(),key:'Ctrl+C'});
                items.push({label:'Paste',fn:()=>this.pasteObj(),key:'Ctrl+V'});
                items.push({label:'Duplicate',fn:()=>this.duplicateSelected(),key:'Ctrl+J'});
                items.push({label:'Delete',fn:()=>this.deleteSelected(),key:'Del'});
                items.push({sep:true});
                items.push({label:'Transform',children:[
                    {label:'Free Transform',fn:()=>this.showFreeTransform(),key:'Ctrl+T'},
                    {label:'Flip Horizontal',fn:()=>this.flipH()},
                    {label:'Flip Vertical',fn:()=>this.flipV()},
                    {sep:true},
                    {label:'Rotate 90\u00b0 CW',fn:()=>this.rotateObj(90)},
                    {label:'Rotate 90\u00b0 CCW',fn:()=>this.rotateObj(-90)},
                ]});
                items.push({label:'Arrange',children:[
                    {label:'Bring to Front',fn:()=>{active.bringToFront();this.canvas.renderAll();this.saveHistory('Bring Front');}},
                    {label:'Bring Forward',fn:()=>{active.bringForward();this.canvas.renderAll();this.saveHistory('Bring Forward');}},
                    {label:'Send Backward',fn:()=>{active.sendBackwards();this.canvas.renderAll();this.saveHistory('Send Backward');}},
                    {label:'Send to Back',fn:()=>{active.sendToBack();this.canvas.renderAll();this.saveHistory('Send Back');}},
                ]});
                items.push({sep:true});
                items.push({label:'Layer Via Copy',fn:()=>this._layerViaCopy()});
                items.push({label:'Layer Via Cut',fn:()=>this._layerViaCut()});
                if (active.type === 'image') {
                    items.push({sep:true});
                    if (this._lastFilter) {
                        items.push({label:'Last Filter: ' + this._lastFilter,fn:()=>this._reapplyLastFilter()});
                    }
                    items.push({label:'Clear Filters',fn:()=>this.clearFilters()});
                }
            } else if (hasSelection) {
                // Pixel selection active — selection operations
                items.push({label:'Deselect',fn:()=>this.deselectSelection(),key:'Ctrl+D'});
                items.push({label:'Select Inverse',fn:()=>this.invertSelection(),key:'Ctrl+Shift+I'});
                items.push({sep:true});
                items.push({label:'Modify',children:[
                    {label:'Feather...',fn:()=>this.modifySelection('feather')},
                    {label:'Expand...',fn:()=>this.modifySelection('expand')},
                    {label:'Contract...',fn:()=>this.modifySelection('contract')},
                    {label:'Smooth',fn:()=>this.modifySelection('smooth')},
                ]});
                items.push({label:'Grow',fn:()=>this.growSelection()});
                items.push({label:'Similar',fn:()=>this.similarSelection()});
                items.push({sep:true});
                items.push({label:'Layer Via Copy',fn:()=>this._layerViaCopy()});
                items.push({label:'Layer Via Cut',fn:()=>this._layerViaCut()});
            } else {
                // No object, no selection — canvas operations
                items.push({label:'Paste',fn:()=>this.pasteObj(),key:'Ctrl+V'});
                items.push({label:'Select All',fn:()=>this.selectAll(),key:'Ctrl+A'});
                items.push({sep:true});
                items.push({label:'New Layer',fn:()=>this.addLayer()});
                items.push({label:'Flatten Image',fn:()=>this.flattenImage()});
                items.push({sep:true});
                items.push({label:'Zoom',children:[
                    {label:'Zoom In',fn:()=>this.zoomIn()},
                    {label:'Zoom Out',fn:()=>this.zoomOut()},
                    {label:'Zoom to Fit',fn:()=>this.zoomFit(),key:'Ctrl+0'},
                    {label:'Actual Pixels',fn:()=>this.zoomActual(),key:'Ctrl+1'},
                ]});
                items.push({sep:true});
                items.push({label:'Toggle Grid',fn:()=>this.toggleGrid(),key:'Ctrl+G'});
                items.push({label:'Toggle Rulers',fn:()=>this.toggleRulers(),key:'Ctrl+R'});
                items.push({sep:true});
                items.push({label:'Canvas Size...',fn:()=>this.showResize()});
                items.push({label:'Image Info...',fn:()=>this.showImageInfo()});
            }
            // Store items for click handler (flatten for indexing)
            this._ctxItems = [];
            const flattenItems = (arr) => {
                arr.forEach(it => { if (it.children) flattenItems(it.children); else this._ctxItems.push(it); });
            };
            flattenItems(items);

            const renderItems = (arr) => arr.map(it => {
                if (it.sep) return '<div class="ctx-sep"></div>';
                if (it.children) {
                    const childIdx = this._ctxItems.indexOf(it.children[0]);
                    return `<div class="ctx-item ctx-sub">${it.label}<div class="ctx-submenu">${renderItems(it.children)}</div></div>`;
                }
                const idx = this._ctxItems.indexOf(it);
                return `<div class="ctx-item" data-ctx="${idx}">${it.label}${it.key?`<span class="ctx-shortcut">${it.key}</span>`:''}</div>`;
            }).join('');

            menu.innerHTML = renderItems(items);
            menu.querySelectorAll('.ctx-item[data-ctx]').forEach(el => {
                el.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const idx = +el.dataset.ctx;
                    if (this._ctxItems[idx] && this._ctxItems[idx].fn) this._ctxItems[idx].fn();
                    menu.classList.remove('visible');
                });
            });
            // Position with bounds check
            const mw = 220, mh = items.length * 28;
            let mx = e.clientX, my = e.clientY;
            if (mx + mw > window.innerWidth) mx = window.innerWidth - mw - 4;
            if (my + mh > window.innerHeight) my = window.innerHeight - mh - 4;
            menu.style.left = mx + 'px';
            menu.style.top = my + 'px';
            menu.classList.add('visible');
        });
        document.addEventListener('click', () => document.getElementById('context-menu').classList.remove('visible'));
    },

    // ====================== DROPZONE ======================
    initDropzone() {
        let dragCounter = 0;
        document.addEventListener('dragenter', e => {
            e.preventDefault(); dragCounter++;
            if (e.dataTransfer.types.includes('Files')) document.getElementById('dropzone-overlay').classList.add('visible');
        });
        document.addEventListener('dragleave', e => {
            e.preventDefault(); dragCounter--;
            if (dragCounter <= 0) { dragCounter = 0; document.getElementById('dropzone-overlay').classList.remove('visible'); }
        });
        document.addEventListener('dragover', e => e.preventDefault());
        document.addEventListener('drop', e => {
            e.preventDefault(); dragCounter = 0;
            document.getElementById('dropzone-overlay').classList.remove('visible');
            // Canvas area drop is handled by existing handler, but this handles full-window drops
            if (e.target.closest('#canvas-area')) return; // already handled
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = ev => {
                    fabric.Image.fromURL(ev.target.result, img => {
                        img.scaleToWidth(Math.min(this.canvasW, img.width));
                        this.canvas.add(img); this.canvas.setActiveObject(img);
                        this.layers[this.activeLayerIdx].objects.push(img);
                        this.saveHistory('Drop Image'); this.updateLayersPanel();
                    });
                }; reader.readAsDataURL(file);
            }
        });
    },

    // ====================== CLIPBOARD PASTE ======================
    initClipboardPaste() {
        document.addEventListener('paste', e => {
            const items = e.clipboardData?.items;
            if (!items) return;
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = ev => {
                        fabric.Image.fromURL(ev.target.result, img => {
                            img.scaleToWidth(Math.min(this.canvasW, img.width));
                            this.canvas.add(img); this.canvas.setActiveObject(img);
                            this.layers[this.activeLayerIdx].objects.push(img);
                            this.saveHistory('Paste Image'); this.updateLayersPanel();
                            this.toast('Image pasted from clipboard', 'success');
                        });
                    }; reader.readAsDataURL(blob);
                    return;
                }
            }
        });
    },

    // ====================== MINIMAP / NAVIGATOR ======================
    initMinimap() { this.updateMinimap(); },
    updateMinimap() {
        const cv = document.getElementById('minimap-canvas');
        const wrap = document.getElementById('minimap-wrap');
        if (!cv || !wrap) return;
        const w = wrap.clientWidth, h = wrap.clientHeight;
        cv.width = w; cv.height = h;
        const ctx = cv.getContext('2d');
        ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, w, h);
        try {
            const vpt = this.canvas.viewportTransform.slice();
            this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
            const dataUrl = this.canvas.toDataURL({ format: 'png', left: 0, top: 0, width: this.canvasW, height: this.canvasH });
            this.canvas.viewportTransform = vpt; this.canvas.renderAll();
            const img = new Image();
            img.onload = () => {
                const scale = Math.min(w / this.canvasW, h / this.canvasH);
                const dx = (w - this.canvasW * scale) / 2, dy = (h - this.canvasH * scale) / 2;
                ctx.drawImage(img, dx, dy, this.canvasW * scale, this.canvasH * scale);
                // Viewport rect
                const vpEl = document.getElementById('minimap-vp');
                const cvw = this.canvas.width, cvh = this.canvas.height;
                const z = this.zoom;
                const vpW = cvw / z / this.canvasW * (this.canvasW * scale);
                const vpH = cvh / z / this.canvasH * (this.canvasH * scale);
                const vpX = dx + (-vpt[4] / z / this.canvasW) * (this.canvasW * scale);
                const vpY = dy + (-vpt[5] / z / this.canvasH) * (this.canvasH * scale);
                vpEl.style.left = vpX + 'px'; vpEl.style.top = vpY + 'px';
                vpEl.style.width = Math.min(vpW, w) + 'px'; vpEl.style.height = Math.min(vpH, h) + 'px';
            }; img.src = dataUrl;
        } catch(e) {}
    },
    _minimapClick(e) {
        const wrap = document.getElementById('minimap-wrap');
        const rect = wrap.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const w = wrap.clientWidth, h = wrap.clientHeight;
        const scale = Math.min(w / this.canvasW, h / this.canvasH);
        const dx = (w - this.canvasW * scale) / 2, dy = (h - this.canvasH * scale) / 2;
        const canvasX = (x - dx) / scale;
        const canvasY = (y - dy) / scale;
        const cvw = this.canvas.width, cvh = this.canvas.height;
        const z = this.zoom;
        const vpt = this.canvas.viewportTransform.slice();
        vpt[4] = -(canvasX * z - cvw / 2);
        vpt[5] = -(canvasY * z - cvh / 2);
        this.canvas.setViewportTransform(vpt);
        this.drawGrid(); this.drawRulers(); this.updateMinimap();
    },

    // ====================== STICKY NOTES / ANNOTATIONS ======================
    addStickyNote(e) {
        const colors = ['#FFE066','#66D9E8','#D0BFFF','#FFB3B3','#A9E34B','#FFC078'];
        const color = colors[this._stickyNotes.length % colors.length];
        const container = document.getElementById('sticky-container');
        const note = document.createElement('div');
        note.className = 'sticky-note';
        note.style.background = color;
        note.style.left = (e.clientX || 200) + 'px';
        note.style.top = (e.clientY || 200) + 'px';
        note.style.pointerEvents = 'all';
        note.innerHTML = `<span class="sticky-close" onclick="this.parentElement.remove();OS._stickyNotes=OS._stickyNotes.filter(n=>n!==this.parentElement)">×</span>
            <textarea placeholder="Type a note..."></textarea>`;
        // Make draggable
        let dragging = false, offX, offY;
        note.addEventListener('mousedown', ev => {
            if (ev.target.tagName === 'TEXTAREA' || ev.target.classList.contains('sticky-close')) return;
            dragging = true; offX = ev.clientX - note.offsetLeft; offY = ev.clientY - note.offsetTop;
        });
        document.addEventListener('mousemove', ev => {
            if (!dragging) return;
            note.style.left = (ev.clientX - offX) + 'px';
            note.style.top = (ev.clientY - offY) + 'px';
        });
        document.addEventListener('mouseup', () => { dragging = false; });
        container.appendChild(note);
        this._stickyNotes.push(note);
        note.querySelector('textarea').focus();
        this.toast('Note added', 'info');
    },

    // ====================== COLOR PALETTES ======================
    initDefaultPalette() {
        const defaults = ['#ffffff','#000000','#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff',
            '#ff6b6b','#ffa500','#48bb78','#4299e1','#9f7aea','#ed64a6','#667eea','#38b2ac',
            '#e53e3e','#dd6b20','#2f855a','#2b6cb0','#6b46c1','#d53f8c','#434190','#285e61'];
        const row = document.getElementById('palette-default');
        if (!row) return;
        row.innerHTML = defaults.map(c => `<div class="palette-swatch" style="background:${c}" onclick="OS.setFgColor('${c}')" title="${c}"></div>`).join('');
    },
    loadSavedPalette() {
        try { this._savedPalette = JSON.parse(localStorage.getItem('os_palette') || '[]'); } catch(e) { this._savedPalette = []; }
        this._renderSavedPalette();
    },
    _renderSavedPalette() {
        const row = document.getElementById('palette-saved');
        if (!row) return;
        row.innerHTML = this._savedPalette.map(c => `<div class="palette-swatch" style="background:${c}" onclick="OS.setFgColor('${c}')" title="${c}"></div>`).join('');
    },
    savePaletteColor() {
        const color = this.state.fgColor;
        if (!this._savedPalette.includes(color)) {
            this._savedPalette.push(color);
            try { localStorage.setItem('os_palette', JSON.stringify(this._savedPalette)); } catch(e) {}
            this._renderSavedPalette();
            this.toast(`Added ${color} to palette`, 'success');
        }
    },
    clearPalette() {
        this._savedPalette = [];
        try { localStorage.setItem('os_palette', '[]'); } catch(e) {}
        this._renderSavedPalette();
        this.toast('Palette cleared', 'info');
    },
    exportPalette() {
        const all = this._savedPalette.length > 0 ? this._savedPalette : ['#ffffff','#000000'];
        const data = JSON.stringify({ name: 'OpenShop Palette', colors: all }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = 'openshop-palette.json'; a.click();
        this.toast('Palette exported', 'success');
    },
    importPalette() {
        const input = document.createElement('input'); input.type = 'file'; input.accept = '.json,.gpl,.ase';
        input.onchange = e => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                try {
                    const data = JSON.parse(ev.target.result);
                    if (data.colors && Array.isArray(data.colors)) {
                        this._savedPalette = [...this._savedPalette, ...data.colors];
                        try { localStorage.setItem('os_palette', JSON.stringify(this._savedPalette)); } catch(e) {}
                        this._renderSavedPalette();
                        this.toast(`Imported ${data.colors.length} colors`, 'success');
                    }
                } catch(e) { this.toast('Invalid palette file', 'error'); }
            }; reader.readAsText(file);
        }; input.click();
    },

    // ====================== KEYBOARD SHORTCUTS ======================
    showShortcuts() {
        const shortcuts = [
            // General
            ['Ctrl+K','Command Palette'],['Ctrl+S','Save Project'],['Ctrl+N','New Document'],
            // Edit
            ['Ctrl+Z','Undo'],['Ctrl+Shift+Z','Redo'],['Ctrl+Y','Redo (alt)'],
            ['Ctrl+C','Copy'],['Ctrl+X','Cut'],['Ctrl+V','Paste'],['Ctrl+J','Duplicate Object'],
            ['Delete','Delete Selected'],['Ctrl+T','Free Transform'],
            // Selection
            ['Ctrl+A','Select All'],['Ctrl+D','Deselect'],
            ['Ctrl+Shift+D','Reselect'],['Ctrl+Shift+I','Inverse Selection'],
            // Layer
            ['Ctrl+E','Merge Down'],['Ctrl+Shift+E','Merge Visible'],
            // View
            ['Ctrl+G','Toggle Grid'],['Ctrl+R','Toggle Rulers'],
            ['Ctrl+1','Zoom 100%'],['Ctrl+0','Zoom Fit'],
            ['Ctrl++','Zoom In'],['Ctrl+-','Zoom Out'],
            ['Tab','Toggle UI Panels'],['F','Fullscreen'],['Scroll','Zoom'],
            // Tools
            ['Enter','Apply Crop / Finish Pen'],['Escape','Cancel / Deselect'],
            ['Space (hold)','Temporary Pan'],['[ / ]','Brush Size'],['X','Swap Colors'],['D','Default Colors'],
            ['V','Move'],['B','Brush'],['E','Eraser'],['T','Text'],['G','Gradient'],
            ['C','Crop'],['Z','Zoom'],['H','Pan'],['L','Line'],['R / U','Rectangle'],
            ['O','Ellipse'],['P','Pen'],['M','Marquee'],['W','Magic Wand'],
            ['S','Clone Stamp'],['I','Eyedropper'],['J','Healing'],['A','Arrow'],
            ['N','Sticky Note'],['Alt+Click','Set Clone Source'],
        ];
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal" style="min-width:400px"><h3>Keyboard Shortcuts</h3>
            <dl class="shortcut-grid">${shortcuts.map(([k,v]) => `<dt>${k}</dt><dd>${v}</dd>`).join('')}</dl>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => o.classList.add('show'));
    },

    // ====================== KEYBOARD SHORTCUT HANDLER ======================
    _clipboard: null,
    _initKeyboardShortcuts() {
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
            const ctrl = e.ctrlKey || e.metaKey;

            // === Ctrl/Cmd shortcuts ===
            if (ctrl) {
                switch(e.key.toLowerCase()) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) this.redo(); else this.undo();
                        return;
                    case 'y':
                        e.preventDefault(); this.redo(); return;
                    case 's':
                        e.preventDefault(); this.saveProject(); return;
                    case 'a':
                        e.preventDefault(); this.selectAll(); return;
                    case 'd':
                        e.preventDefault();
                        if (e.shiftKey) { this.reselectSelection(); }
                        else { this.deselectAll(); }
                        return;
                    case 'c':
                        e.preventDefault(); this._copySelection(); return;
                    case 'x':
                        e.preventDefault(); this._cutSelection(); return;
                    case 'v':
                        e.preventDefault(); this._pasteSelection(); return;
                    case 'j':
                        e.preventDefault(); this._duplicateSelection(); return;
                    case 'g':
                        e.preventDefault(); this.toggleGrid(); return;
                    case 'r':
                        e.preventDefault(); this.toggleRulers(); return;
                    case 't':
                        e.preventDefault(); this.freeTransform(); return;
                    case '0':
                        e.preventDefault(); this.zoomFit(); return;
                    case '1':
                        e.preventDefault(); this.setZoom(1); return;
                    case '+': case '=':
                        e.preventDefault(); this.zoomIn(); return;
                    case '-':
                        e.preventDefault(); this.zoomOut(); return;
                    case 'k':
                        // Handled by cmd palette init
                        return;
                    case 'e':
                        e.preventDefault();
                        if (e.shiftKey) this.mergeVisibleLayers();
                        else this.mergeDown();
                        return;
                    case 'n':
                        e.preventDefault(); this.newImage(); return;
                }
                // Ctrl+Shift combos
                if (e.shiftKey && e.key.toLowerCase() === 'i') {
                    e.preventDefault();
                    this.invertSelection();
                    return;
                }
                // Ctrl+Shift+D handled inside case 'd' above
                return;
            }

            // === Non-modifier shortcuts ===
            switch(e.key) {
                case 'Escape':
                    if (this.state.tool === 'crop' && this._cropRegion) { this.cancelCrop(); return; }
                    if (this._selectionBounds || this._lassoPoints.length > 0) { this.clearSelection(); return; }
                    this.deselectAll();
                    return;
                case 'Enter':
                    if (this.state.tool === 'crop' && this._cropRegion) { e.preventDefault(); this.applyCrop(); return; }
                    if (this.state.tool === 'pen' && this._penPoints.length > 1) { e.preventDefault(); this._penFinish(); return; }
                    return;
                case 'Delete': case 'Backspace':
                    e.preventDefault();
                    if (this._selectionBounds) {
                        this._deleteSelectionPixels();
                    } else if (this.canvas.getActiveObject()) {
                        this._deleteSelected();
                    }
                    return;
                case ' ':
                    e.preventDefault();
                    if (!this._tempPanning) {
                        this._tempPanning = true;
                        this._prevCursor = this.canvas.defaultCursor;
                        this.canvas.defaultCursor = 'grab';
                        this.canvas.hoverCursor = 'grab';
                    }
                    return;
                case 'Tab':
                    e.preventDefault();
                    // Toggle panels visibility like Photoshop
                    const panels = document.getElementById('panels');
                    const toolbar = document.getElementById('toolbar');
                    const toolopts = document.getElementById('tool-options');
                    const hidden = panels.style.display === 'none';
                    panels.style.display = hidden ? '' : 'none';
                    toolbar.style.display = hidden ? '' : 'none';
                    toolopts.style.display = hidden ? '' : 'none';
                    return;
                case 'F':
                case 'f':
                    if (!ctrl) { this.toggleFullscreen(); return; }
                    return;
                case '[':
                    this.state.brushSize = Math.max(1, this.state.brushSize - 2);
                    this.setBrushSize(this.state.brushSize);
                    return;
                case ']':
                    this.state.brushSize = Math.min(200, this.state.brushSize + 2);
                    this.setBrushSize(this.state.brushSize);
                    return;
                case 'x':
                case 'X':
                    this.swapColors(); return;
                case 'd':
                case 'D':
                    this.setFgColor('#000000'); this.setBgColor('#ffffff');
                    this.toast('Colors reset', 'info'); return;
            }

            // Tool switch shortcuts (single letter)
            const map = {v:'select',b:'brush',e:'eraser',t:'text',g:'gradient',c:'crop',z:'zoom',h:'pan',
                l:'line',r:'rect',o:'circle',p:'pen',m:'marquee-rect',w:'magic-wand',s:'clone',i:'eyedropper',
                j:'healing',n:'note',a:'arrow',u:'rect',k:'polygon'};
            const lower = e.key.toLowerCase();
            if (map[lower] && !ctrl) { e.preventDefault(); this.setTool(map[lower]); }
        });
        // Space key release - exit temporary pan
        document.addEventListener('keyup', e => {
            if (e.key === ' ' && this._tempPanning) {
                this._tempPanning = false;
                this.canvas.defaultCursor = this._prevCursor || 'crosshair';
                // Restore hover cursor based on current tool
                if (this.state.tool === 'select') { this.canvas.defaultCursor = 'default'; this.canvas.hoverCursor = 'move'; }
                else { this.canvas.hoverCursor = 'crosshair'; }
            }
        });
    },
    selectAll() {
        this.setTool('select');
        const objs = this.canvas.getObjects().filter(o => o.name !== '__boundary__' && !o._wandOverlay && o.selectable !== false);
        if (objs.length === 0) return;
        if (objs.length === 1) { this.canvas.setActiveObject(objs[0]); }
        else { const sel = new fabric.ActiveSelection(objs, { canvas: this.canvas }); this.canvas.setActiveObject(sel); }
        this.canvas.requestRenderAll();
    },
    deselectAll() {
        this.canvas.discardActiveObject();
        this.clearSelection();
        this.canvas.requestRenderAll();
    },
    _copySelection() {
        const active = this.canvas.getActiveObject();
        if (!active) { this.toast('Nothing selected', 'info'); return; }
        active.clone(cloned => { this._clipboard = cloned; });
        this.toast('Copied', 'info');
    },
    _cutSelection() {
        this._copySelection();
        this._deleteSelected();
        this.toast('Cut', 'info');
    },
    _pasteSelection() {
        if (!this._clipboard) { this.toast('Nothing to paste', 'info'); return; }
        this._clipboard.clone(cloned => {
            this.canvas.discardActiveObject();
            cloned.set({ left: cloned.left + 20, top: cloned.top + 20, evented: true });
            if (cloned.type === 'activeSelection') {
                cloned.canvas = this.canvas;
                cloned.forEachObject(obj => { this.canvas.add(obj); this.layers[this.activeLayerIdx].objects.push(obj); });
                cloned.setCoords();
            } else {
                this.canvas.add(cloned);
                this.layers[this.activeLayerIdx].objects.push(cloned);
            }
            this._clipboard.set({ left: this._clipboard.left + 20, top: this._clipboard.top + 20 });
            this.canvas.setActiveObject(cloned);
            this.canvas.requestRenderAll();
            this.saveHistory('Paste');
            this.updateLayersPanel();
        });
    },
    _duplicateSelection() {
        const active = this.canvas.getActiveObject();
        if (!active) return;
        active.clone(cloned => {
            cloned.set({ left: cloned.left + 20, top: cloned.top + 20, evented: true });
            if (cloned.type === 'activeSelection') {
                cloned.canvas = this.canvas;
                cloned.forEachObject(obj => { this.canvas.add(obj); this.layers[this.activeLayerIdx].objects.push(obj); });
            } else {
                this.canvas.add(cloned);
                this.layers[this.activeLayerIdx].objects.push(cloned);
            }
            this.canvas.setActiveObject(cloned);
            this.canvas.requestRenderAll();
            this.saveHistory('Duplicate');
            this.updateLayersPanel();
        });
    },
    _deleteSelected() {
        const active = this.canvas.getActiveObject();
        if (!active) return;
        if (active.type === 'activeSelection') {
            active.forEachObject(obj => {
                this.canvas.remove(obj);
                this.layers.forEach(l => { const idx = l.objects.indexOf(obj); if (idx >= 0) l.objects.splice(idx, 1); });
            });
            this.canvas.discardActiveObject();
        } else {
            if (active.name === '__boundary__') return;
            this.canvas.remove(active);
            this.layers.forEach(l => { const idx = l.objects.indexOf(active); if (idx >= 0) l.objects.splice(idx, 1); });
        }
        this.canvas.requestRenderAll();
        this.saveHistory('Delete');
        this.updateLayersPanel();
    },
    // Delete pixels within current selection on the active image
    _deleteSelectionPixels() {
        // Find the target image — active object or first image under selection
        let target = this.canvas.getActiveObject();
        if (!target || target.type !== 'image') {
            const imgs = this.canvas.getObjects().filter(o => o.type === 'image');
            target = imgs.length ? imgs[imgs.length - 1] : null;
        }
        if (!target || target.type !== 'image') {
            // No image? Just delete selected objects
            if (this.canvas.getActiveObject()) this._deleteSelected();
            this.clearSelection();
            return;
        }
        const el = target.getElement();
        const oc = document.createElement('canvas');
        oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        const ctx = oc.getContext('2d');
        ctx.drawImage(el, 0, 0);
        if (this._selectionMask) {
            // Magic wand: use pixel mask
            const mask = this._selectionMask;
            const vpt = this.canvas.viewportTransform;
            const matrix = target.calcTransformMatrix();
            const inv = fabric.util.invertTransform(matrix);
            const imgData = ctx.getImageData(0, 0, oc.width, oc.height);
            const d = imgData.data;
            for (let sy = 0; sy < mask.h; sy++) {
                for (let sx = 0; sx < mask.w; sx++) {
                    if (!mask.mask[sy * mask.w + sx]) continue;
                    // Convert screen pixel to canvas coords then to image local
                    const cx = (sx - vpt[4]) / vpt[0], cy = (sy - vpt[5]) / vpt[3];
                    const local = fabric.util.transformPoint({ x: cx, y: cy }, inv);
                    const ix = Math.round(local.x + oc.width / 2), iy = Math.round(local.y + oc.height / 2);
                    if (ix >= 0 && iy >= 0 && ix < oc.width && iy < oc.height) {
                        const i = (iy * oc.width + ix) * 4;
                        d[i + 3] = 0; // Set alpha to 0
                    }
                }
            }
            ctx.putImageData(imgData, 0, 0);
        } else {
            // Marquee: use bounding box
            const sel = this._selToCanvasCoords();
            if (!sel) return;
            const matrix = target.calcTransformMatrix();
            const inv = fabric.util.invertTransform(matrix);
            // Convert selection corners to image local space
            const tl = fabric.util.transformPoint({ x: sel.x, y: sel.y }, inv);
            const br = fabric.util.transformPoint({ x: sel.x + sel.w, y: sel.y + sel.h }, inv);
            const lx = Math.round(tl.x + oc.width / 2), ly = Math.round(tl.y + oc.height / 2);
            const lw = Math.round(br.x - tl.x), lh = Math.round(br.y - tl.y);
            ctx.clearRect(lx, ly, lw, lh);
        }
        this._replaceActiveImage(target, oc.toDataURL('image/png'), 'Delete Pixels');
        this.clearSelection();
        this.toast('Deleted selected pixels', 'success');
    },
    setZoom(level) {
        const center = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
        this.canvas.zoomToPoint(center, level);
        this.zoom = level;
        document.getElementById('zoom-display').textContent = Math.round(level * 100) + '%';
        this.drawGrid(); this.drawRulers(); this._drawPixelGrid();
    },
    freeTransform() {
        const active = this.canvas.getActiveObject();
        if (!active || active.name === '__boundary__') { this.toast('Select an object first', 'info'); return; }
        active.set({ hasControls: true, hasBorders: true, lockRotation: false, lockScalingX: false, lockScalingY: false, cornerStyle: 'circle', cornerColor: 'var(--accent, #6c8cff)', transparentCorners: false });
        this.canvas.setActiveObject(active);
        this.canvas.requestRenderAll();
        this.toast('Free Transform - drag handles to resize/rotate', 'info');
    },
    mergeVisibleLayers() {
        const visible = this.layers.filter(l => l.visible);
        if (visible.length < 2) { this.toast('Need 2+ visible layers', 'info'); return; }
        this.flattenImage();
    },
    newDocument() { this.newImage(); },
    _doNewDoc(overlay) {
        const w = +overlay.querySelector('#nd-w').value || 1920;
        const h = +overlay.querySelector('#nd-h').value || 1080;
        overlay.remove();
        this.createNewDocument(w, h);
    },

    // ====================== THEME SYSTEM ======================
    setTheme(theme) {
        document.documentElement.classList.remove('theme-midnight', 'theme-oled');
        if (theme !== 'default') document.documentElement.classList.add('theme-' + theme);
        this._currentTheme = theme;
        this.toast(`Theme: ${theme.charAt(0).toUpperCase() + theme.slice(1)}`, 'info');
    },


    // ====================== PHASE 9: RETOUCHING TOOLS ======================
    _retouchOC: null,
    _retouchTarget: null,
    _retouchStart(tool, ptr, evt) {
        let target = this.canvas.getActiveObject();
        if (!target || target.type !== 'image') {
            const objs = this.canvas.getObjects().filter(o => o.type === 'image' && o.containsPoint(ptr));
            target = objs.length ? objs[objs.length-1] : null;
        }
        if (!target || target.type !== 'image') { this.toast('Select an image to retouch', 'info'); return; }
        const el = target.getElement();
        const oc = document.createElement('canvas');
        oc.width = el.naturalWidth || el.width; oc.height = el.naturalHeight || el.height;
        oc.getContext('2d').drawImage(el, 0, 0);
        this._retouchOC = oc; this._retouchTarget = target;
        this._retouchStroke(tool, ptr);
        const commitFn = () => {
            document.removeEventListener('mouseup', commitFn);
            if (this._retouchOC && this._retouchTarget) {
                this._replaceActiveImage(this._retouchTarget, this._retouchOC.toDataURL(), 'Retouch');
                this._retouchOC = null; this._retouchTarget = null;
            }
        };
        document.addEventListener('mouseup', commitFn);
    },
    _retouchStroke(tool, ptr) {
        if (!this._retouchOC || !this._retouchTarget) return;
        const oc = this._retouchOC, ctx = oc.getContext('2d'), target = this._retouchTarget;
        const matrix = target.calcTransformMatrix();
        const inv = fabric.util.invertTransform(matrix);
        const local = fabric.util.transformPoint(ptr, inv);
        const lx = local.x + oc.width/2, ly = local.y + oc.height/2;
        let size, exposure;
        if (tool === 'dodge') { size = this.state.dodgeSize; exposure = this.state.dodgeExposure / 100; }
        else if (tool === 'burn') { size = this.state.burnSize; exposure = this.state.burnExposure / 100; }
        else if (tool === 'sponge') { size = this.state.spongeSize; exposure = this.state.spongeFlow / 100; }
        else { size = this.state.smudgeSize; exposure = this.state.smudgeStrength / 100; }
        const r = Math.ceil(size / 2);
        const x0 = Math.max(0, Math.floor(lx-r)), y0 = Math.max(0, Math.floor(ly-r));
        const x1 = Math.min(oc.width, Math.ceil(lx+r)), y1 = Math.min(oc.height, Math.ceil(ly+r));
        if (x1 <= x0 || y1 <= y0) return;
        try {
            const imgData = ctx.getImageData(x0, y0, x1-x0, y1-y0);
            const d = imgData.data, w = imgData.width;
            for (let py = 0; py < imgData.height; py++) {
                for (let px = 0; px < w; px++) {
                    const dist = Math.sqrt((px+x0-lx)**2 + (py+y0-ly)**2);
                    if (dist > r) continue;
                    const falloff = 1 - dist / r;
                    const i = (py * w + px) * 4;
                    const strength = exposure * falloff * 0.2;
                    if (tool === 'dodge') {
                        for (let c=0;c<3;c++) d[i+c] = Math.min(255, d[i+c] + (255 - d[i+c]) * strength);
                    } else if (tool === 'burn') {
                        for (let c=0;c<3;c++) d[i+c] = Math.max(0, d[i+c] * (1 - strength));
                    } else if (tool === 'sponge') {
                        const l = (d[i]+d[i+1]+d[i+2]) / 3;
                        const sat = this.state.spongeMode === 'saturate' ? 1 : -1;
                        for (let c=0;c<3;c++) d[i+c] = Math.max(0, Math.min(255, d[i+c] + (d[i+c]-l) * strength * sat));
                    } else {
                        if (px > 0) { const b = strength*0.5; for (let c=0;c<3;c++) d[i+c] = d[i+c]*(1-b) + d[i-4+c]*b; }
                    }
                }
            }
            ctx.putImageData(imgData, x0, y0);
            // Live preview: update fabric canvas directly
            const vpt = this.canvas.viewportTransform;
            const dCtx = this.canvas.getContext('2d');
            const sx = ptr.x * vpt[0] + vpt[4], sy = ptr.y * vpt[3] + vpt[5];
            try { dCtx.putImageData(imgData, sx-(lx-x0)*vpt[0], sy-(ly-y0)*vpt[3]); } catch(e2) {}
        } catch(e) {}
    },
    // ====================== VIBRANCE ======================
    adjVibrance() {
        const body = `<div class="modal-row"><label>Vibrance</label><input id="adj-vib" type="range" min="-100" max="100" value="30" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">30</span></div>`;
        this._openFilterPanel('vibrance-overlay', 'Vibrance', body,
            ()=>this._removeFilterPanel('vibrance-overlay'), ()=>this._doVibrance());
    },
    _doVibrance() {
        const panel = document.getElementById('vibrance-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('vibrance-overlay'); return; }
        const amt = +panel.querySelector('#adj-vib').value / 100, d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const max = Math.max(d[i],d[i+1],d[i+2]), min = Math.min(d[i],d[i+1],d[i+2]);
            const sat = max === 0 ? 0 : (max - min) / max;
            const boost = amt * (1 - sat) * (sat < 0.5 ? 1 : 0.5);
            const avg = (d[i]+d[i+1]+d[i+2])/3;
            for (let c=0;c<3;c++) d[i+c] = Math.max(0,Math.min(255, d[i+c] + (d[i+c] - avg) * boost));
        }
        this._commitImageData(info, 'Vibrance'); this._removeFilterPanel('vibrance-overlay'); this.toast('Vibrance applied','success');
    },

    // ====================== EXPOSURE ======================
    adjExposure() {
        const body = `<div class="modal-row"><label>Exposure</label><input id="adj-exp" type="range" min="-300" max="300" value="0" oninput="this.nextElementSibling.textContent=(this.value/100).toFixed(1)+'EV'"><span class="opt-val">0.0EV</span></div><div class="modal-row"><label>Offset</label><input id="adj-exp-off" type="range" min="-50" max="50" value="0" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">0</span></div><div class="modal-row"><label>Gamma</label><input id="adj-exp-gam" type="range" min="10" max="400" value="100" oninput="this.nextElementSibling.textContent=(this.value/100).toFixed(2)"><span class="opt-val">1.00</span></div>`;
        this._openFilterPanel('exposure-overlay', 'Exposure', body,
            ()=>this._removeFilterPanel('exposure-overlay'), ()=>this._doExposure());
    },
    _doExposure() {
        const panel = document.getElementById('exposure-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('exposure-overlay'); return; }
        const ev = +panel.querySelector('#adj-exp').value / 100;
        const offset = +panel.querySelector('#adj-exp-off').value;
        const gamma = +panel.querySelector('#adj-exp-gam').value / 100;
        const mult = Math.pow(2, ev), d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            for (let c=0;c<3;c++) {
                let v = d[i+c] / 255; v = v * mult + offset / 255;
                v = Math.pow(Math.max(0, v), 1 / gamma);
                d[i+c] = Math.max(0, Math.min(255, Math.round(v * 255)));
            }
        }
        this._commitImageData(info, 'Exposure'); this._removeFilterPanel('exposure-overlay'); this.toast('Exposure applied','success');
    },

    // ====================== SHADOWS / HIGHLIGHTS ======================
    adjShadowsHighlights() {
        const body = `<div class="modal-row"><label>Shadows</label><input id="adj-sh-s" type="range" min="0" max="100" value="50" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">50%</span></div><div class="modal-row"><label>Highlights</label><input id="adj-sh-h" type="range" min="0" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div>`;
        this._openFilterPanel('shadowhl-overlay', 'Shadows / Highlights', body,
            ()=>this._removeFilterPanel('shadowhl-overlay'), ()=>this._doShadowsHighlights());
    },
    _doShadowsHighlights() {
        const panel = document.getElementById('shadowhl-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('shadowhl-overlay'); return; }
        const shAmt = +panel.querySelector('#adj-sh-s').value / 100;
        const hlAmt = +panel.querySelector('#adj-sh-h').value / 100;
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const l = (0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])/255;
            for (let c=0;c<3;c++) {
                let v = d[i+c];
                if (l < 0.5) { const w = 1 - l*2; v += (255 - v) * shAmt * w * 0.5; }
                if (l > 0.5) { const w = (l-0.5)*2; v -= v * hlAmt * w * 0.5; }
                d[i+c] = Math.max(0, Math.min(255, Math.round(v)));
            }
        }
        this._commitImageData(info, 'Shadows/Highlights'); this._removeFilterPanel('shadowhl-overlay'); this.toast('Shadows/Highlights applied','success');
    },

    // ====================== PHOTO FILTER ======================
    adjPhotoFilter() {
        const body = `<div class="modal-row"><label>Filter</label><select id="adj-pf-type"><option value="warming">Warming (85)</option><option value="cooling">Cooling (80)</option><option value="sunset">Sunset</option><option value="underwater">Underwater</option><option value="sepia">Sepia</option><option value="custom">Custom Color</option></select></div><div class="modal-row"><label>Color</label><input id="adj-pf-color" type="color" value="#ec8a00"></div><div class="modal-row"><label>Density</label><input id="adj-pf-dens" type="range" min="5" max="100" value="30" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">30%</span></div>`;
        this._openFilterPanel('photofilter-overlay', 'Photo Filter', body,
            ()=>this._removeFilterPanel('photofilter-overlay'), ()=>this._doPhotoFilter());
    },
    _doPhotoFilter() {
        const panel = document.getElementById('photofilter-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('photofilter-overlay'); return; }
        const type = panel.querySelector('#adj-pf-type').value;
        const density = +panel.querySelector('#adj-pf-dens').value / 100;
        const presets = { warming:[236,138,0], cooling:[0,109,204], sunset:[255,90,20], underwater:[0,180,200], sepia:[162,138,101] };
        let color;
        if (type === 'custom') { const hex = panel.querySelector('#adj-pf-color').value; color = [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)]; }
        else color = presets[type] || presets.warming;
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            d[i] = Math.min(255, d[i] + (color[0] - d[i]) * density);
            d[i+1] = Math.min(255, d[i+1] + (color[1] - d[i+1]) * density);
            d[i+2] = Math.min(255, d[i+2] + (color[2] - d[i+2]) * density);
        }
        this._commitImageData(info, 'Photo Filter'); this._removeFilterPanel('photofilter-overlay'); this.toast('Photo filter applied','success');
    },

    // ====================== SELECTIVE COLOR ======================
    adjSelectiveColor() {
        const body = `<div class="modal-row"><label>Target</label><select id="adj-sc-target"><option value="reds">Reds</option><option value="yellows">Yellows</option><option value="greens">Greens</option><option value="cyans">Cyans</option><option value="blues">Blues</option><option value="magentas">Magentas</option></select></div><div class="modal-row"><label>Cyan</label><input id="adj-sc-c" type="range" min="-100" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">0</span></div><div class="modal-row"><label>Magenta</label><input id="adj-sc-m" type="range" min="-100" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">0</span></div><div class="modal-row"><label>Yellow</label><input id="adj-sc-y" type="range" min="-100" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">0</span></div><div class="modal-row"><label>Black</label><input id="adj-sc-k" type="range" min="-100" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">0</span></div>`;
        this._openFilterPanel('selcolor-overlay', 'Selective Color', body,
            ()=>this._removeFilterPanel('selcolor-overlay'), ()=>this._doSelectiveColor());
    },
    _doSelectiveColor() {
        const panel = document.getElementById('selcolor-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('selcolor-overlay'); return; }
        const target = panel.querySelector('#adj-sc-target')?.value;
        const cc = +(panel.querySelector('#adj-sc-c')?.value||0)/100, mc = +(panel.querySelector('#adj-sc-m')?.value||0)/100;
        const yc = +(panel.querySelector('#adj-sc-y')?.value||0)/100, kc = +(panel.querySelector('#adj-sc-k')?.value||0)/100;
        const d = info.imgData.data;
        const hueRanges = { reds:[330,30], yellows:[30,90], greens:[90,150], cyans:[150,210], blues:[210,270], magentas:[270,330] };
        const [hmin,hmax] = hueRanges[target] || [0,360];
        for (let i = 0; i < d.length; i += 4) {
            const r=d[i]/255,g=d[i+1]/255,b=d[i+2]/255;
            const max=Math.max(r,g,b),min=Math.min(r,g,b),delta=max-min;
            let hue=0; if(delta>0){if(max===r)hue=60*((g-b)/delta%6);else if(max===g)hue=60*((b-r)/delta+2);else hue=60*((r-g)/delta+4);}
            if(hue<0)hue+=360;
            let inRange;
            if(hmin>hmax) inRange=(hue>=hmin||hue<=hmax); else inRange=(hue>=hmin&&hue<=hmax);
            if(!inRange||delta<0.05)continue;
            const strength = delta;
            d[i]   = Math.max(0,Math.min(255, d[i]   - d[i]*cc*strength + d[i]*kc*strength*(-1)));
            d[i+1] = Math.max(0,Math.min(255, d[i+1] - d[i+1]*mc*strength + d[i+1]*kc*strength*(-1)));
            d[i+2] = Math.max(0,Math.min(255, d[i+2] - d[i+2]*yc*strength + d[i+2]*kc*strength*(-1)));
        }
        this._commitImageData(info, 'Selective Color'); this._removeFilterPanel('selcolor-overlay'); this.toast('Selective color applied','success');
    },

    // ====================== REPLACE COLOR ======================
    adjReplaceColor() {
        const body = `<div class="modal-row"><label>Source</label><input id="adj-rc-src" type="color" value="#ff0000"></div><div class="modal-row"><label>Target</label><input id="adj-rc-tgt" type="color" value="#0000ff"></div><div class="modal-row"><label>Fuzziness</label><input id="adj-rc-fuzz" type="range" min="5" max="150" value="40" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">40</span></div>`;
        this._openFilterPanel('replcolor-overlay', 'Replace Color', body,
            ()=>this._removeFilterPanel('replcolor-overlay'), ()=>this._doReplaceColor());
    },
    _doReplaceColor() {
        const panel = document.getElementById('replcolor-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('replcolor-overlay'); return; }
        const parse = hex => [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)];
        const src = parse(panel.querySelector('#adj-rc-src').value);
        const tgt = parse(panel.querySelector('#adj-rc-tgt').value);
        const fuzz = +panel.querySelector('#adj-rc-fuzz').value;
        const d = info.imgData.data;
        for (let i = 0; i < d.length; i += 4) {
            const dist = Math.sqrt((d[i]-src[0])**2 + (d[i+1]-src[1])**2 + (d[i+2]-src[2])**2);
            if (dist <= fuzz) {
                const blend = 1 - dist / fuzz;
                d[i]   = Math.round(d[i]   + (tgt[0] - src[0]) * blend);
                d[i+1] = Math.round(d[i+1] + (tgt[1] - src[1]) * blend);
                d[i+2] = Math.round(d[i+2] + (tgt[2] - src[2]) * blend);
            }
        }
        this._commitImageData(info, 'Replace Color'); this._removeFilterPanel('replcolor-overlay'); this.toast('Color replaced','success');
    },

    // ====================== LENS CORRECTION ======================
    adjLensCorrection() {
        const body = `<div class="modal-row"><label>Barrel/Pin</label><input id="adj-lc-dist" type="range" min="-100" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value"><span class="opt-val">0</span></div><div class="modal-row"><label>Vignette</label><input id="adj-lc-vig" type="range" min="0" max="100" value="0" oninput="this.nextElementSibling.textContent=this.value+'%'"><span class="opt-val">0%</span></div><div class="modal-row"><label>CA Fix</label><input id="adj-lc-ca" type="range" min="0" max="10" value="0" oninput="this.nextElementSibling.textContent=this.value+'px'"><span class="opt-val">0px</span></div>`;
        this._openFilterPanel('lenscorr-overlay', 'Lens Correction', body,
            ()=>this._removeFilterPanel('lenscorr-overlay'), ()=>this._doLensCorrection());
    },
    _doLensCorrection() {
        const panel = document.getElementById('lenscorr-overlay');
        const info = this._getActiveImageData(); if (!info) { this._removeFilterPanel('lenscorr-overlay'); return; }
        const dist = +panel.querySelector('#adj-lc-dist').value / 1000;
        const vig = +panel.querySelector('#adj-lc-vig').value / 100;
        const ca = +panel.querySelector('#adj-lc-ca').value;
        const d = info.imgData.data, w = info.canvas.width, h = info.canvas.height;
        const src = new Uint8ClampedArray(d);
        const cx = w/2, cy = h/2, maxR = Math.sqrt(cx*cx + cy*cy);
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const dx = (x - cx) / cx, dy = (y - cy) / cy;
                const r2 = dx*dx + dy*dy;
                const barrel = 1 + dist * r2;
                const srcX = Math.round(cx + dx * barrel * cx);
                const srcY = Math.round(cy + dy * barrel * cy);
                const i = (y * w + x) * 4;
                if (srcX >= 0 && srcX < w && srcY >= 0 && srcY < h) {
                    const si = (srcY * w + srcX) * 4;
                    d[i] = src[si]; d[i+1] = src[si+1]; d[i+2] = src[si+2];
                    // CA fix
                    if (ca > 0) {
                        const caX = Math.round(cx + dx * (barrel + dist*0.002*ca) * cx);
                        if (caX >= 0 && caX < w) d[i] = src[(srcY*w+caX)*4]; // shift red
                    }
                } else { d[i]=d[i+1]=d[i+2]=0; }
                // Vignette
                if (vig > 0) {
                    const vDist = Math.sqrt((x-cx)**2+(y-cy)**2)/maxR;
                    const vFactor = 1 - vig * vDist * vDist;
                    d[i]*=vFactor; d[i+1]*=vFactor; d[i+2]*=vFactor;
                }
            }
        }
        this._commitImageData(info, 'Lens Correction'); this._removeFilterPanel('lenscorr-overlay'); this.toast('Lens correction applied','success');
    },

    // ====================== LIQUIFY ======================
    showLiquify() {
        const active = this.canvas.getActiveObject();
        if (!active || active.type !== 'image') { this.toast('Select an image first','info'); return; }
        const overlay = document.getElementById('liquify-overlay');
        overlay.classList.add('visible');
        const el = active.getElement();
        const lc = document.getElementById('liquify-canvas');
        lc.width = el.naturalWidth || el.width;
        lc.height = el.naturalHeight || el.height;
        const ctx = lc.getContext('2d');
        ctx.drawImage(el, 0, 0);
        this._liquifyData = { original: ctx.getImageData(0,0,lc.width,lc.height), active };
        lc.style.maxWidth = '90%'; lc.style.maxHeight = '90%'; lc.style.cursor = 'crosshair';
        let painting = false;
        lc.onmousedown = e => { painting = true; this._liquifyApplyBrush(e, lc); };
        lc.onmousemove = e => { if (painting) this._liquifyApplyBrush(e, lc); };
        lc.onmouseup = () => { painting = false; };
    },
    _liquifyApplyBrush(e, cv) {
        const rect = cv.getBoundingClientRect();
        const scaleX = cv.width / rect.width, scaleY = cv.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX, y = (e.clientY - rect.top) * scaleY;
        const ctx = cv.getContext('2d');
        const tool = document.getElementById('liq-tool').value;
        const size = +document.getElementById('liq-size').value;
        const pressure = +document.getElementById('liq-pressure').value / 100;
        const r = size / 2;
        const imgData = ctx.getImageData(Math.max(0,x-r-5),Math.max(0,y-r-5),r*2+10,r*2+10);
        const d = imgData.data, w = imgData.width, h = imgData.height;
        const src = new Uint8ClampedArray(d);
        const cx = Math.min(x, r+5), cy = Math.min(y, r+5);
        for (let py = 0; py < h; py++) {
            for (let px = 0; px < w; px++) {
                const dx = px - cx, dy = py - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > r) continue;
                const falloff = (1 - dist/r) * pressure;
                let sx = px, sy = py;
                if (tool === 'push') { sx -= e.movementX * scaleX * falloff * 0.5; sy -= e.movementY * scaleY * falloff * 0.5; }
                else if (tool === 'bloat') { sx = cx + dx * (1 + falloff*0.1); sy = cy + dy * (1 + falloff*0.1); }
                else if (tool === 'pucker') { sx = cx + dx * (1 - falloff*0.1); sy = cy + dy * (1 - falloff*0.1); }
                else if (tool === 'twirl-cw' || tool === 'twirl-ccw') {
                    const angle = falloff * 0.1 * (tool === 'twirl-cw' ? 1 : -1);
                    sx = cx + dx*Math.cos(angle) - dy*Math.sin(angle);
                    sy = cy + dx*Math.sin(angle) + dy*Math.cos(angle);
                }
                sx = Math.max(0,Math.min(w-1,Math.round(sx)));
                sy = Math.max(0,Math.min(h-1,Math.round(sy)));
                const di = (py*w+px)*4, si = (sy*w+sx)*4;
                d[di]=src[si]; d[di+1]=src[si+1]; d[di+2]=src[si+2]; d[di+3]=src[si+3];
            }
        }
        ctx.putImageData(imgData, Math.max(0,x-r-5), Math.max(0,y-r-5));
    },
    _liquifyReset() {
        if (!this._liquifyData) return;
        const cv = document.getElementById('liquify-canvas');
        cv.getContext('2d').putImageData(this._liquifyData.original, 0, 0);
    },
    closeLiquify() { document.getElementById('liquify-overlay').classList.remove('visible'); this._liquifyData = null; },
    _liquifyApply() {
        if (!this._liquifyData) return;
        const cv = document.getElementById('liquify-canvas');
        this._replaceActiveImage(this._liquifyData.active, cv.toDataURL(), 'Liquify');
        this.closeLiquify(); this.toast('Liquify applied','success');
    },

    // ====================== CURVED TEXT ======================
    showCurvedText() {
        const o = document.createElement('div'); o.className = 'modal-overlay';
        o.innerHTML = `<div class="modal"><h3>Curved Text</h3>
            <div class="curved-text-preview"><canvas id="ct-preview" width="280" height="120"></canvas></div>
            <div class="modal-row"><label>Text</label><input id="ct-text" type="text" value="Curved Text" style="flex:1;background:var(--bg-depth-3);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);padding:4px 8px" oninput="OS._updateCurvedPreview()"></div>
            <div class="modal-row"><label>Radius</label><input id="ct-radius" type="range" min="50" max="500" value="150" oninput="this.nextElementSibling.textContent=this.value+'px';OS._updateCurvedPreview()"><span class="opt-val">150px</span></div>
            <div class="modal-row"><label>Start Angle</label><input id="ct-angle" type="range" min="-180" max="180" value="-90" oninput="this.nextElementSibling.textContent=this.value+'&deg;';OS._updateCurvedPreview()"><span class="opt-val">-90&deg;</span></div>
            <div class="modal-row"><label>Size</label><input id="ct-size" type="range" min="10" max="80" value="24" oninput="this.nextElementSibling.textContent=this.value+'px';OS._updateCurvedPreview()"><span class="opt-val">24px</span></div>
            <div class="modal-row"><label>Color</label><input id="ct-color" type="color" value="#ffffff" onchange="OS._updateCurvedPreview()"></div>
            <div class="modal-btns"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button><button class="btn btn-primary" onclick="OS._applyCurvedText(this.closest('.modal-overlay'))">Apply</button></div></div>`;
        document.body.appendChild(o); requestAnimationFrame(() => { o.classList.add('show'); this._updateCurvedPreview(); });
    },
    _updateCurvedPreview() {
        const cv = document.getElementById('ct-preview'); if (!cv) return;
        const ctx = cv.getContext('2d');
        ctx.clearRect(0, 0, cv.width, cv.height);
        const text = document.getElementById('ct-text')?.value || 'Curved Text';
        const radius = +(document.getElementById('ct-radius')?.value || 150);
        const startAngle = +(document.getElementById('ct-angle')?.value || -90) * Math.PI / 180;
        const fontSize = +(document.getElementById('ct-size')?.value || 24);
        const color = document.getElementById('ct-color')?.value || '#fff';
        ctx.font = `${fontSize}px DM Sans`;
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        const cx = cv.width/2, cy = cv.height/2 + radius * 0.3;
        const r = Math.min(radius, 100);
        for (let i = 0; i < text.length; i++) {
            const charAngle = startAngle + (i - text.length/2) * fontSize * 0.8 / r;
            ctx.save();
            ctx.translate(cx + r * Math.cos(charAngle), cy + r * Math.sin(charAngle));
            ctx.rotate(charAngle + Math.PI/2);
            ctx.fillText(text[i], 0, 0);
            ctx.restore();
        }
    },
    _applyCurvedText(overlay) {
        const text = overlay.querySelector('#ct-text').value || 'Curved Text';
        const radius = +overlay.querySelector('#ct-radius').value;
        const startAngle = +overlay.querySelector('#ct-angle').value * Math.PI / 180;
        const fontSize = +overlay.querySelector('#ct-size').value;
        const color = overlay.querySelector('#ct-color').value;
        const size = radius * 2 + fontSize * 2;
        const oc = document.createElement('canvas'); oc.width = size; oc.height = size;
        const ctx = oc.getContext('2d');
        ctx.font = `${fontSize}px DM Sans`; ctx.fillStyle = color; ctx.textAlign = 'center';
        const cx = size/2, cy = size/2;
        for (let i = 0; i < text.length; i++) {
            const charAngle = startAngle + (i - text.length/2) * fontSize * 0.8 / radius;
            ctx.save();
            ctx.translate(cx + radius * Math.cos(charAngle), cy + radius * Math.sin(charAngle));
            ctx.rotate(charAngle + Math.PI/2);
            ctx.fillText(text[i], 0, 0);
            ctx.restore();
        }
        fabric.Image.fromURL(oc.toDataURL(), img => {
            img.set({ left: this.canvasW/2 - size/2, top: this.canvasH/2 - size/2, selectable: true });
            this.canvas.add(img); this.canvas.setActiveObject(img);
            this.layers[this.activeLayerIdx].objects.push(img);
            this.saveHistory('Curved Text'); this.updateLayersPanel();
        });
        overlay.remove(); this.toast('Curved text created','success');
    },

    // ====================== PIXEL GRID ======================
    togglePixelGrid() {
        this._pixelGridVisible = !this._pixelGridVisible;
        this.toast(this._pixelGridVisible ? 'Pixel grid on (visible at high zoom)' : 'Pixel grid off', 'info');
        this._drawPixelGrid();
    },
    _drawPixelGrid() {
        let cv = document.querySelector('.pixel-grid-canvas');
        if (!this._pixelGridVisible) { if (cv) cv.remove(); return; }
        if (this.zoom < 8) { if (cv) cv.remove(); return; }
        const ca = document.getElementById('canvas-area');
        if (!cv) { cv = document.createElement('canvas'); cv.className = 'pixel-grid-canvas'; ca.appendChild(cv); }
        cv.width = ca.clientWidth; cv.height = ca.clientHeight;
        const ctx = cv.getContext('2d');
        ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 0.5;
        const z = this.zoom, vpt = this.canvas.viewportTransform;
        const startX = vpt[4] % z, startY = vpt[5] % z;
        for (let x = startX; x < cv.width; x += z) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
        for (let y = startY; y < cv.height; y += z) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }
    },

    // ====================== ANIMATION TIMELINE ======================
    toggleTimeline() {
        const p = document.getElementById('timeline-panel');
        p.classList.toggle('visible');
        if (p.classList.contains('visible') && this._animFrames.length === 0) this.addFrame();
    },
    addFrame() {
        const vpt = this.canvas.viewportTransform.slice();
        this.canvas.viewportTransform = [1,0,0,1,0,0]; this.canvas.renderAll();
        const data = this.canvas.toDataURL({ format:'png', left:0, top:0, width:this.canvasW, height:this.canvasH });
        this.canvas.viewportTransform = vpt; this.canvas.renderAll();
        this._animFrames.push(data);
        this._animIdx = this._animFrames.length - 1;
        this._renderFrames();
        this.toast(`Frame ${this._animFrames.length} added`, 'info');
    },
    dupFrame() {
        if (this._animFrames.length === 0) return;
        this._animFrames.splice(this._animIdx + 1, 0, this._animFrames[this._animIdx]);
        this._animIdx++;
        this._renderFrames();
    },
    removeFrame(idx) {
        if (this._animFrames.length <= 1) return;
        this._animFrames.splice(idx, 1);
        if (this._animIdx >= this._animFrames.length) this._animIdx = this._animFrames.length - 1;
        this._renderFrames();
    },
    selectFrame(idx) {
        this._animIdx = idx;
        this._renderFrames();
        // Load frame onto canvas
        const data = this._animFrames[idx];
        fabric.Image.fromURL(data, img => {
            this.canvas.clear();
            this.canvas.add(img);
            this.canvas.renderAll();
        });
    },
    _renderFrames() {
        const container = document.getElementById('timeline-frames');
        container.innerHTML = '';
        this._animFrames.forEach((data, i) => {
            const div = document.createElement('div');
            div.className = 'frame-thumb' + (i === this._animIdx ? ' active' : '');
            const cv = document.createElement('canvas'); cv.width = 80; cv.height = Math.round(80 * this.canvasH / this.canvasW);
            const ctx = cv.getContext('2d');
            const img = new Image(); img.onload = () => ctx.drawImage(img, 0, 0, cv.width, cv.height); img.src = data;
            div.appendChild(cv);
            div.innerHTML += `<span class="frame-num">#${i+1}</span><span class="frame-del" onclick="event.stopPropagation();OS.removeFrame(${i})">&times;</span>`;
            div.onclick = () => this.selectFrame(i);
            container.appendChild(div);
        });
    },
    prevFrame() { if (this._animIdx > 0) this.selectFrame(this._animIdx - 1); },
    nextFrame() { if (this._animIdx < this._animFrames.length - 1) this.selectFrame(this._animIdx + 1); },
    togglePlay() {
        if (this._animPlaying) {
            clearInterval(this._animTimer); this._animPlaying = false;
            document.getElementById('tl-play').classList.remove('active');
            return;
        }
        const fps = +document.getElementById('tl-fps').value || 12;
        this._animPlaying = true;
        document.getElementById('tl-play').classList.add('active');
        this._animTimer = setInterval(() => {
            this._animIdx = (this._animIdx + 1) % this._animFrames.length;
            this._renderFrames();
            // Quick preview without loading to canvas
            const cv = document.querySelector('.frame-thumb.active canvas');
            if (cv) { /* visual highlight is enough for preview */ }
        }, 1000 / fps);
    },
    exportGIF() {
        if (this._animFrames.length < 2) { this.toast('Add at least 2 frames','info'); return; }
        this.toast('Exporting frames as PNG sequence (GIF requires gif.js library)...','info');
        // Export as individual frames + spritesheet
        const fps = +document.getElementById('tl-fps').value || 12;
        // Create spritesheet
        const first = new Image();
        first.onload = () => {
            const fw = first.width, fh = first.height;
            const cols = Math.ceil(Math.sqrt(this._animFrames.length));
            const rows = Math.ceil(this._animFrames.length / cols);
            const oc = document.createElement('canvas'); oc.width = fw * cols; oc.height = fh * rows;
            const ctx = oc.getContext('2d');
            let loaded = 0;
            this._animFrames.forEach((data, i) => {
                const img = new Image();
                img.onload = () => {
                    const col = i % cols, row = Math.floor(i / cols);
                    ctx.drawImage(img, col * fw, row * fh);
                    loaded++;
                    if (loaded === this._animFrames.length) {
                        const link = document.createElement('a');
                        link.download = `openshop-spritesheet-${cols}x${rows}-${fps}fps.png`;
                        link.href = oc.toDataURL('image/png');
                        link.click();
                        this.toast(`Spritesheet exported (${cols}x${rows}, ${this._animFrames.length} frames @ ${fps}fps)`, 'success');
                    }
                }; img.src = data;
            });
        }; first.src = this._animFrames[0];
    },

    // ====================== ACTION / MACRO RECORDING ======================
    toggleMacroPanel() {
        document.getElementById('macro-panel').classList.toggle('visible');
    },
    toggleMacroRec() {
        this._macroRecording = !this._macroRecording;
        const btn = document.getElementById('macro-rec-btn');
        const indicator = document.getElementById('macro-rec-indicator');
        if (this._macroRecording) {
            btn.textContent = 'Stop'; btn.style.color = '#ff4444';
            indicator.style.display = 'flex';
            this.toast('Recording actions...', 'info');
        } else {
            btn.textContent = 'Record'; btn.style.color = '';
            indicator.style.display = 'none';
            this.toast(`Recorded ${this._macroSteps.length} steps`, 'success');
        }
    },
    recordMacroStep(action, params) {
        if (!this._macroRecording) return;
        this._macroSteps.push({ action, params, timestamp: Date.now() });
        this._renderMacroList();
    },
    _renderMacroList() {
        const list = document.getElementById('macro-list');
        list.innerHTML = this._macroSteps.map((s, i) =>
            `<div class="macro-step">${i+1}. ${s.action}</div>`
        ).join('');
    },
    playMacro() {
        if (this._macroSteps.length === 0) { this.toast('No actions recorded','info'); return; }
        this.toast(`Playing ${this._macroSteps.length} actions...`, 'info');
        let i = 0;
        const playNext = () => {
            if (i >= this._macroSteps.length) { this.toast('Macro complete', 'success'); return; }
            const step = this._macroSteps[i++];
            // Execute by calling named functions
            if (typeof this[step.action] === 'function') {
                try { this[step.action](...(step.params || [])); } catch(e) {}
            }
            setTimeout(playNext, 100);
        };
        playNext();
    },
    clearMacro() { this._macroSteps = []; this._renderMacroList(); this.toast('Actions cleared', 'info'); },
    saveMacro() {
        if (this._macroSteps.length === 0) return;
        const data = JSON.stringify(this._macroSteps, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = 'openshop-action.json'; a.click();
        this.toast('Action saved', 'success');
    },
    loadMacro() {
        const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => {
                try { this._macroSteps = JSON.parse(ev.target.result); this._renderMacroList();
                    this.toast(`Loaded ${this._macroSteps.length} actions`, 'success');
                } catch(e) { this.toast('Invalid action file', 'error'); }
            }; reader.readAsText(file);
        }; input.click();
    },


    // ====================== AI MODULE (Transformers.js) ======================
    // On-demand model loading — no API keys, runs 100% in-browser
    // Models cached in IndexedDB after first download
    _aiPipelines: {},
    _aiLib: null,
    _aiLoading: false,

    _showAIProgress(title, msg) {
        const el = document.getElementById('ai-progress');
        document.getElementById('ai-title').innerHTML = '<span class="ai-spinner"></span>' + title;
        document.getElementById('ai-msg').textContent = msg || '';
        document.getElementById('ai-bar').style.width = '0%';
        document.getElementById('ai-pct').textContent = '0%';
        el.classList.add('visible');
    },
    _updateAIProgress(pct, msg) {
        document.getElementById('ai-bar').style.width = Math.round(pct) + '%';
        document.getElementById('ai-pct').textContent = Math.round(pct) + '%';
        if (msg) document.getElementById('ai-msg').textContent = msg;
    },
    _hideAIProgress() {
        document.getElementById('ai-progress').classList.remove('visible');
    },

    async _loadTransformers() {
        if (this._aiLib) return this._aiLib;
        this._showAIProgress('Loading Transformers.js', 'Fetching AI runtime library...');
        try {
            this._aiLib = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.3.3');
            return this._aiLib;
        } catch(e) {
            this._hideAIProgress();
            this.toast('Failed to load AI library: ' + e.message, 'error');
            throw e;
        }
    },

    async _loadPipeline(task, model, label) {
        const key = task + ':' + model;
        if (this._aiPipelines[key]) {
            this.toast(label + ' model ready (cached)', 'info');
            return this._aiPipelines[key];
        }
        if (this._aiLoading) { this.toast('Another AI model is loading, please wait', 'info'); return null; }
        this._aiLoading = true;
        try {
            const lib = await this._loadTransformers();
            this._showAIProgress('Downloading ' + label + ' Model', 'First-time download, will be cached for future use');
            let lastPct = 0;
            const pipe = await lib.pipeline(task, model, {
                dtype: 'q8',
                device: 'wasm',
                progress_callback: (p) => {
                    if (p.status === 'progress' && p.progress) {
                        lastPct = p.progress;
                        this._updateAIProgress(p.progress, p.file ? 'Downloading: ' + p.file.split('/').pop() : '');
                    } else if (p.status === 'done') {
                        this._updateAIProgress(100, 'Model loaded');
                    } else if (p.status === 'initiate') {
                        this._updateAIProgress(lastPct, 'Loading: ' + (p.file ? p.file.split('/').pop() : ''));
                    }
                }
            });
            this._aiPipelines[key] = pipe;
            this._aiLoading = false;
            this._hideAIProgress();
            this.toast(label + ' model ready', 'success');
            return pipe;
        } catch(e) {
            this._aiLoading = false;
            this._hideAIProgress();
            this.toast('Failed to load ' + label + ': ' + e.message, 'error');
            console.error('AI model load error:', e);
            return null;
        }
    },

    _getActiveImage() {
        let target = this.canvas.getActiveObject();
        if (target && target.type === 'image') return target;
        const imgs = this.canvas.getObjects().filter(o => o.type === 'image');
        if (imgs.length === 1) return imgs[0];
        if (imgs.length > 1) { this.toast('Select an image first', 'info'); return null; }
        this.toast('No image found on canvas', 'info');
        return null;
    },

    _imageToDataURL(target) {
        const el = target.getElement();
        const oc = document.createElement('canvas');
        oc.width = el.naturalWidth || el.width;
        oc.height = el.naturalHeight || el.height;
        oc.getContext('2d').drawImage(el, 0, 0);
        return oc.toDataURL('image/png');
    },

    // === AI BACKGROUND REMOVAL ===
    // Uses Xenova/modnet — proper ONNX model with full Transformers.js support
    _aiRmbgModel: null,
    _aiRmbgProcessor: null,
    async _loadRmbgModel() {
        if (this._aiRmbgModel) return true;
        if (this._aiLoading) { this.toast('Another AI model is loading', 'info'); return false; }
        this._aiLoading = true;
        try {
            const lib = await this._loadTransformers();
            this._showAIProgress('Downloading Background Removal Model', 'First-time download, cached for future use');
            let lastPct = 0;
            const progressCb = (p) => {
                if (p.status === 'progress' && p.progress) {
                    lastPct = p.progress;
                    this._updateAIProgress(p.progress, p.file ? 'Downloading: ' + p.file.split('/').pop() : '');
                } else if (p.status === 'done') {
                    this._updateAIProgress(100, 'Model loaded');
                } else if (p.status === 'initiate') {
                    this._updateAIProgress(lastPct, 'Loading: ' + (p.file ? p.file.split('/').pop() : ''));
                }
            };
            lib.env.allowLocalModels = false;
            this._aiRmbgModel = await lib.AutoModel.from_pretrained('Xenova/modnet', {
                device: 'wasm',
                dtype: 'fp32',
                progress_callback: progressCb
            });
            this._aiRmbgProcessor = await lib.AutoProcessor.from_pretrained('Xenova/modnet');
            this._aiLoading = false;
            this._hideAIProgress();
            this.toast('Background Removal model ready', 'success');
            return true;
        } catch(e) {
            this._aiLoading = false;
            this._hideAIProgress();
            this.toast('Failed to load BG model: ' + e.message, 'error');
            console.error('MODNet load error:', e);
            return false;
        }
    },
    async aiRemoveBackground() {
        const target = this._getActiveImage();
        if (!target) return;
        const ready = await this._loadRmbgModel();
        if (!ready) return;
        this._showAIProgress('Removing Background', 'Processing image...');
        try {
            const lib = this._aiLib;
            const el = target.getElement();
            const origW = el.naturalWidth || el.width;
            const origH = el.naturalHeight || el.height;
            const dataUrl = this._imageToDataURL(target);
            const image = await lib.RawImage.fromURL(dataUrl);
            const { pixel_values } = await this._aiRmbgProcessor(image);
            const { output } = await this._aiRmbgModel({ input: pixel_values });
            // output is a tensor — convert to mask and resize to original dimensions
            const mask = await lib.RawImage.fromTensor(output[0].mul(255).to('uint8')).resize(origW, origH);
            // Apply mask as alpha channel on original image
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = origW; resultCanvas.height = origH;
            const rctx = resultCanvas.getContext('2d');
            rctx.drawImage(el, 0, 0);
            const imgData = rctx.getImageData(0, 0, origW, origH);
            const d = imgData.data;
            const mPx = mask.data;
            const channels = mask.channels || 1;
            for (let i = 0; i < origW * origH; i++) {
                d[i * 4 + 3] = mPx[i * channels];
            }
            rctx.putImageData(imgData, 0, 0);
            const newUrl = resultCanvas.toDataURL('image/png');
            this._replaceActiveImage(target, newUrl, 'AI BG Remove');
            this._hideAIProgress();
            this.toast('Background removed (AI)', 'success');
        } catch(e) {
            this._hideAIProgress();
            this.toast('Background removal error: ' + e.message, 'error');
            console.error('AI BG Remove error:', e);
        }
    },

    // === AI DEPTH MAP ===
    async aiDepthMap() {
        const target = this._getActiveImage();
        if (!target) return;
        const pipe = await this._loadPipeline(
            'depth-estimation', 'Xenova/depth-anything-small-hf', 'Depth Estimation'
        );
        if (!pipe) return;
        this._showAIProgress('Generating Depth Map', 'Processing image...');
        try {
            const dataUrl = this._imageToDataURL(target);
            const result = await pipe(dataUrl);
            // result.depth is a RawImage
            const depth = result.depth;
            const w = depth.width, h = depth.height;
            const depthCanvas = document.createElement('canvas');
            depthCanvas.width = w; depthCanvas.height = h;
            const dctx = depthCanvas.getContext('2d');
            const imgData = dctx.createImageData(w, h);
            const pixels = imgData.data;
            const depthData = depth.data;
            // Normalize to 0-255 range
            let minD = Infinity, maxD = -Infinity;
            for (let i = 0; i < depthData.length; i++) {
                if (depthData[i] < minD) minD = depthData[i];
                if (depthData[i] > maxD) maxD = depthData[i];
            }
            const range = maxD - minD || 1;
            for (let i = 0; i < w * h; i++) {
                const val = Math.round(((depthData[i] - minD) / range) * 255);
                // Apply plasma colormap for visual depth
                const t = val / 255;
                pixels[i * 4]     = Math.round(Math.min(1, 1.5 - Math.abs(t - 0.75) * 4) * 255); // R
                pixels[i * 4 + 1] = Math.round(Math.min(1, 1.5 - Math.abs(t - 0.5) * 4) * 255);  // G
                pixels[i * 4 + 2] = Math.round(Math.min(1, 1.5 - Math.abs(t - 0.25) * 4) * 255); // B
                pixels[i * 4 + 3] = 255;
            }
            dctx.putImageData(imgData, 0, 0);
            // Scale to match original image
            const el = target.getElement();
            const origW = el.naturalWidth || el.width;
            const origH = el.naturalHeight || el.height;
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = origW; finalCanvas.height = origH;
            finalCanvas.getContext('2d').drawImage(depthCanvas, 0, 0, origW, origH);
            const depthUrl = finalCanvas.toDataURL('image/png');
            // Add as new layer above current
            fabric.Image.fromURL(depthUrl, img => {
                img.set({ left: target.left, top: target.top, scaleX: target.scaleX, scaleY: target.scaleY, selectable: true, name: 'Depth Map', opacity: 0.85 });
                this.canvas.add(img); this.canvas.setActiveObject(img);
                this.layers[this.activeLayerIdx].objects.push(img);
                this.canvas.renderAll(); this.saveHistory('AI Depth Map'); this.updateLayersPanel();
                this._hideAIProgress();
                this.toast('Depth map generated — added as overlay', 'success');
            });
        } catch(e) {
            this._hideAIProgress();
            this.toast('Depth map error: ' + e.message, 'error');
            console.error('AI Depth error:', e);
        }
    },

    // === AI OBJECT DETECTION ===
    async aiObjectDetect() {
        const target = this._getActiveImage();
        if (!target) return;
        const pipe = await this._loadPipeline(
            'object-detection', 'Xenova/detr-resnet-50', 'Object Detection'
        );
        if (!pipe) return;
        this._showAIProgress('Detecting Objects', 'Analyzing image...');
        try {
            const dataUrl = this._imageToDataURL(target);
            const results = await pipe(dataUrl, { threshold: 0.7, percentage: true });
            this._hideAIProgress();
            if (!results || results.length === 0) {
                this.toast('No objects detected', 'info'); return;
            }
            // Draw bounding boxes as fabric objects
            const el = target.getElement();
            const imgW = el.naturalWidth || el.width;
            const imgH = el.naturalHeight || el.height;
            const scaleX = target.scaleX || 1;
            const scaleY = target.scaleY || 1;
            const originX = target.left;
            const originY = target.top;
            const colors = ['#ff6b6b','#6bff6b','#6b6bff','#ffff6b','#ff6bff','#6bffff','#ffa06b','#a06bff'];
            let ci = 0;
            results.forEach(det => {
                const box = det.box;
                const x = originX + (box.xmin * imgW * scaleX);
                const y = originY + (box.ymin * imgH * scaleY);
                const w = (box.xmax - box.xmin) * imgW * scaleX;
                const h = (box.ymax - box.ymin) * imgH * scaleY;
                const color = colors[ci % colors.length]; ci++;
                // Bounding box
                const rect = new fabric.Rect({
                    left: x, top: y, width: w, height: h,
                    fill: 'transparent', stroke: color, strokeWidth: 2,
                    selectable: true, name: 'detect-' + det.label,
                    strokeDashArray: [4, 2]
                });
                // Label
                const label = new fabric.Text(
                    det.label + ' ' + Math.round(det.score * 100) + '%',
                    { left: x, top: y - 16, fontSize: 12, fill: color,
                      fontFamily: 'JetBrains Mono, monospace', fontWeight: '600',
                      backgroundColor: 'rgba(0,0,0,0.7)', padding: 2,
                      selectable: true, name: 'detect-label-' + det.label }
                );
                this.canvas.add(rect); this.canvas.add(label);
                this.layers[this.activeLayerIdx].objects.push(rect, label);
            });
            this.canvas.renderAll(); this.saveHistory('AI Object Detection'); this.updateLayersPanel();
            this.toast('Detected ' + results.length + ' object(s)', 'success');
        } catch(e) {
            this._hideAIProgress();
            this.toast('Object detection error: ' + e.message, 'error');
            console.error('AI Detect error:', e);
        }
    },

    // === SMART UPSCALE (Lanczos + Adaptive Sharpening) ===
    async aiUpscale(factor) {
        const target = this._getActiveImage();
        if (!target) return;
        factor = factor || 2;
        const el = target.getElement();
        const srcW = el.naturalWidth || el.width;
        const srcH = el.naturalHeight || el.height;
        const dstW = srcW * factor;
        const dstH = srcH * factor;
        if (dstW * dstH > 16000000) {
            this.toast('Result would be ' + dstW + 'x' + dstH + ' (' + Math.round(dstW*dstH/1e6) + 'MP) — too large for browser', 'error');
            return;
        }
        this._showAIProgress('Smart Upscale ' + factor + 'x', 'Resizing ' + srcW + 'x' + srcH + ' to ' + dstW + 'x' + dstH);
        await new Promise(r => setTimeout(r, 50)); // let UI update
        try {
            // Step 1: High-quality multi-pass upscale
            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = srcW; srcCanvas.height = srcH;
            srcCanvas.getContext('2d').drawImage(el, 0, 0);
            // Use stepped upscale (2x at a time) for better quality
            let current = srcCanvas;
            let remaining = factor;
            let step = 0;
            while (remaining > 1) {
                const scale = remaining >= 2 ? 2 : remaining;
                const newW = Math.round(current.width * scale);
                const newH = Math.round(current.height * scale);
                const next = document.createElement('canvas');
                next.width = newW; next.height = newH;
                const nctx = next.getContext('2d');
                nctx.imageSmoothingEnabled = true;
                nctx.imageSmoothingQuality = 'high';
                nctx.drawImage(current, 0, 0, newW, newH);
                current = next;
                remaining /= scale;
                step++;
                this._updateAIProgress(30 + step * 20, 'Upscale pass ' + step);
            }
            this._updateAIProgress(70, 'Applying adaptive sharpening...');
            await new Promise(r => setTimeout(r, 30));
            // Step 2: Adaptive unsharp mask (enhances edges without amplifying noise)
            const finalCtx = current.getContext('2d');
            const imgData = finalCtx.getImageData(0, 0, current.width, current.height);
            const d = imgData.data;
            const w = current.width, h = current.height;
            // Create blurred copy for unsharp mask
            const blurCanvas = document.createElement('canvas');
            blurCanvas.width = w; blurCanvas.height = h;
            const bctx = blurCanvas.getContext('2d');
            bctx.filter = 'blur(1px)';
            bctx.drawImage(current, 0, 0);
            const blurData = bctx.getImageData(0, 0, w, h).data;
            // Unsharp mask: original + strength * (original - blurred)
            const strength = 0.5;
            for (let i = 0; i < d.length; i += 4) {
                for (let c = 0; c < 3; c++) {
                    const diff = d[i + c] - blurData[i + c];
                    d[i + c] = Math.max(0, Math.min(255, d[i + c] + diff * strength));
                }
            }
            finalCtx.putImageData(imgData, 0, 0);
            this._updateAIProgress(95, 'Finalizing...');
            await new Promise(r => setTimeout(r, 30));
            const newUrl = current.toDataURL('image/png');
            this._replaceActiveImage(target, newUrl, 'Upscale ' + factor + 'x');
            this._hideAIProgress();
            this.toast('Upscaled to ' + dstW + 'x' + dstH, 'success');
        } catch(e) {
            this._hideAIProgress();
            this.toast('Upscale error: ' + e.message, 'error');
            console.error('Upscale error:', e);
        }
    },

    // ====================== PLUGIN SYSTEM ======================
    registerPlugin(plugin) {
        if(!plugin.name||!plugin.init) { console.error('Plugin must have name and init'); return; }
        this.plugins.push(plugin); plugin.init(this);
        this.toast(`Plugin: ${plugin.name}`, 'info');
    },

    // ====================== STATUS / TOAST ======================
    updateStatus() {
        const objs=this.canvas.getObjects().filter(o=>o.name!=='__boundary__');
        document.getElementById('object-count').textContent=`${objs.length} object${objs.length!==1?'s':''}`;
        this.updateInfoPanel();
    },
    toast(msg, type='info') {
        const el=document.getElementById('toast-container');
        const t=document.createElement('div'); t.className=`toast ${type}`; t.textContent=msg;
        el.appendChild(t); requestAnimationFrame(()=>t.classList.add('show'));
        setTimeout(()=>{t.classList.remove('show');setTimeout(()=>t.remove(),300);},2500);
    },
};

window.addEventListener('DOMContentLoaded', () => OS.init());
</script>
</body>
</html>
